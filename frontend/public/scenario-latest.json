{
  "courseTitle": "LogiCore Tech 신입 개발자 과정",
  "description": "LogiCore Tech 신입 개발자 과정을 통해 파이썬 프로그래밍의 기초부터 실무 적용까지 단계별로 학습합니다. 각 주차별로 실습 중심의 과제를 수행하며, 변수, 자료형, 연산자, 제어문 등 핵심 개념을 익히고, 실제 업무에 활용할 수 있는 능력을 키웁니다.",
  "weeks": [
    {
      "week": 1,
      "title": "첫 코드 작성과 데이터 저장",
      "cycles": [
        {
          "title": "첫 파이썬 프로그램 작성 (print)",
          "filename": "hello.py",
          "lecture": {
            "character": "profKim",
            "title": "강의 노트: print() 함수와 문자열",
            "keyTakeaway": "`print()` 함수는 괄호 안의 내용을 화면에 보여주는 가장 기본적인 명령입니다.",
            "sandboxCode": "print(\"파이썬, 반가워!\")",
            "sections": [
              {
                "heading": "핵심 개념",
                "text": "프로그램은 컴퓨터에 내리는 '명령문'들의 순차적인 나열입니다[cite: 871]. `print()`는 파이썬이 기본으로 제공하는 '함수'이며, 괄호 안에 주어진 값을 화면(터미널)에 출력하라는 명령을 수행합니다[cite: 586, 872].",
                "code": null
              },
              {
                "heading": "기본 문법",
                "text": "따옴표 안에 출력하고 싶은 문장을 넣어 함수를 호출합니다[cite: 937, 940].",
                "code": "# 큰따옴표 사용\nprint(\"Hello, World!\")\n\n# 작은따옴표도 가능\nprint('Hello, Python!')"
              },
              {
                "heading": "활용 사례",
                "text": "프로그램의 실행 상태를 확인하거나, 사용자에게 메시지를 보여주거나, 계산 결과를 출력하는 등 가장 기본적이고 중요한 기능입니다[cite: 870].",
                "code": null
              },
              {
                "heading": "주의점 및 팁",
                "text": "문자열은 반드시 작은따옴표('')나 큰따옴표(\"\")로 감싸야 합니다[cite: 937, 940]. 또한, 파이썬은 대소문자를 구분하므로 `Print()`가 아닌 `print()`로 정확하게 입력해야 합니다[cite: 868].",
                "code": null
              }
            ]
          },
          "syntax_key": {
            "syntax_title": "산술 연산자",
            "syntax_comment": "숫자를 계산하는 기호입니다. `+`, `-`, `*`, `/` 등이 있습니다.",
            "systax_code": "result = 10 + 5"
          },
          "task": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "환영 메시지 출력 함수 완성",
            "content": "${userName}님, 환영합니다! 개발자로서의 첫 임무는 간단합니다. 화면에 <span class='font-bold text-yellow-300'>\"Welcome to LogiCore Tech!\"</span> 라는 환영 메시지를 출력하는 파이썬 코드를 작성해주세요. 개발 환경은 이미 준비되어 있습니다."
          },
          "briefing": {
            "character": "sena",
            "subtitle": "직속 선임의 힌트",
            "title": "화면에 글자 출력하기",
            "content": "세나 선임이에요! 반갑습니다. 화면에 글자를 출력하려면 <span class='font-bold text-teal-300'>`print()`</span> 라는 명령어를 써요. `starterCode`에 보면 `print()` 괄호가 비어있죠? 그 안에 <span class='font-bold text-teal-300'>`\"Welcome to LogiCore Tech!\"`</span> 라고 큰따옴표까지 똑같이 입력해보세요. 그러면 화면에 그 글자가 나타날 거예요!"
          },
          "starterCode": "# TODO: 괄호 안에 \"Welcome to LogiCore Tech!\" 를 따옴표와 함께 그대로 입력하세요.\nprint()\n",
          "testCode": "import io; from contextlib import redirect_stdout; f = io.StringIO(); with redirect_stdout(f): source_code = student_code; exec(source_code); output = f.getvalue().strip(); expected = 'Welcome to LogiCore Tech!'; assert output == expected, f\"출력된 메시지가 요청과 다릅니다. 기대값: '{expected}', 실제 출력값: '{output}'\"",
          "feedback": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "첫 코드 실행 성공!",
              "content": "환영 메시지가 정확하게 출력되었군요. <span class='font-bold text-green-300'>첫 파이썬 코드 실행을 성공적으로 마쳤습니다.</span> 좋습니다! LogiCore Tech에서의 여정을 시작한 것을 축하합니다."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "출력 내용을 확인해볼까요?",
              "content": "앗, 출력된 메시지가 요청한 것과 조금 다르네요. `print()` 괄호 안에 <span class='font-bold text-teal-300'>큰따옴표(`\"`)</span>까지 포함해서 `\"Welcome to LogiCore Tech!\"`를 정확히 입력했는지 확인해보세요. 오타나 빠진 글자가 없는지도요!"
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, 문법 오류!",
              "content": "어이쿠, 코드를 실행하다가 오류가 발생했어요. 혹시 `print`를 `Print`로 잘못 쓰시진 않았나요? 아니면 문자열 양쪽에 따옴표를 빠뜨렸을 수도 있고요. 파이썬은 이런 사소한 실수에 민감하거든요. 오류 메시지를 천천히 읽어보시면 어디가 틀렸는지 힌트를 얻을 수 있을 거예요."
            }
          },
          "task_adv": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "환영 메시지 출력 함수 완성",
            "content": "${userName}님, 환영합니다! 첫 업무로, 이미 작성된 `print_welcome` 함수가 <span class='font-bold text-yellow-300'>\"Welcome to LogiCore Tech!\"</span> 메시지를 화면에 출력하도록 완성해주세요. 함수 구조는 이미 잡혀있으니, 핵심 출력 부분만 구현하면 됩니다."
          },
          "briefing_adv": {
            "character": "sena",
            "subtitle": "직속 선임의 팁",
            "title": "함수 안에서 출력하기",
            "content": "함수 안에서 값을 화면에 보여줄 때도 똑같이 <span class='font-bold text-teal-300'>`print()` 함수</span>를 쓰면 돼요. 이미 `message` 변수에 원하는 문자열이 들어있으니, 그 변수를 `print()` 함수에 넘겨주기만 하면 되겠네요!"
          },
          "starterCode_adv": "# 아래 함수는 환영 메시지를 반환합니다.\n# TODO: 함수 본문에서 \"Welcome to LogiCore Tech!\" 문자열을 print() 함수로 출력하도록 수정하세요.\ndef print_welcome():\n    message = \"Welcome to LogiCore Tech!\"\n    # 여기에 코드를 작성하여 message 변수를 출력하세요.\n\n\n# 함수 호출 (이 부분은 수정하지 마세요)\nprint_welcome()\n",
          "testCode_adv": "import io; from contextlib import redirect_stdout; assert callable(print_welcome), 'print_welcome 함수가 정의되지 않았습니다.'; f = io.StringIO(); with redirect_stdout(f): print_welcome(); output = f.getvalue().strip(); expected = 'Welcome to LogiCore Tech!'; assert output == expected, f\"함수 호출 시 출력된 메시지가 요청과 다릅니다. 기대값: '{expected}', 실제 출력값: '{output}'\"",
          "feedback_adv": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "첫 코드 실행 성공!",
              "content": "환영 메시지가 정확하게 출력되었군요. <span class='font-bold text-green-300'>첫 파이썬 코드 실행을 성공적으로 마쳤습니다.</span> 좋습니다! LogiCore Tech에서의 여정을 시작한 것을 축하합니다."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "출력 내용을 확인해볼까요?",
              "content": "앗, 출력된 메시지가 요청한 것과 조금 다르네요. `print()` 괄호 안에 <span class='font-bold text-teal-300'>큰따옴표(`\"`)</span>까지 포함해서 `\"Welcome to LogiCore Tech!\"`를 정확히 입력했는지 확인해보세요. 오타나 빠진 글자가 없는지도요!"
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, 문법 오류!",
              "content": "어이쿠, 코드를 실행하다가 오류가 발생했어요. 혹시 `print`를 `Print`로 잘못 쓰시진 않았나요? 아니면 문자열 양쪽에 따옴표를 빠뜨렸을 수도 있고요. 파이썬은 이런 사소한 실수에 민감하거든요. 오류 메시지를 천천히 읽어보시면 어디가 틀렸는지 힌트를 얻을 수 있을 거예요."
            }
          }
        },
        {
          "title": "코드 설명 남기기 (주석)",
          "filename": "welcome_commented.py",
          "lecture": {
            "character": "profKim",
            "title": "강의 노트: 주석 (Comment)",
            "keyTakeaway": "주석은 `#` 기호로 시작하며, 코드의 가독성을 높이고 설명을 추가하는 데 사용됩니다.",
            "sandboxCode": "# 이 줄은 주석입니다. 아래 코드는 5를 출력합니다.\nprint(5)",
            "sections": [
              {
                "heading": "핵심 개념",
                "text": "주석은 프로그램 코드 내에 포함되지만, 파이썬 인터프리터가 실행하지 않고 무시하는 설명문입니다[cite: 891]. 코드를 읽는 사람의 이해를 돕기 위해 사용됩니다[cite: 904].",
                "code": null
              },
              {
                "heading": "기본 문법",
                "text": "`#` 기호를 사용하면 그 줄의 `#` 이후 모든 내용이 주석 처리됩니다[cite: 891].",
                "code": "# 이것은 한 줄 전체 주석입니다.\n\nprint(\"Hello\") # 이것은 코드 뒤에 붙는 주석입니다."
              },
              {
                "heading": "활용 사례",
                "text": "복잡한 로직 설명, 코드 작성 의도 명시, 임시로 코드 비활성화 등 다양한 목적으로 사용됩니다 [cite: 898-902].",
                "code": null
              },
              {
                "heading": "주의점 및 팁",
                "text": "주석은 코드가 '어떻게' 동작하는지보다 '왜' 그렇게 작성되었는지를 설명하는 데 집중하는 것이 좋습니다[cite: 903]. 너무 당연한 내용의 주석은 오히려 가독성을 해칠 수 있습니다.",
                "code": null
              }
            ]
          },
          "syntax_key": {
            "syntax_title": "print()",
            "syntax_comment": "`print()`는 괄호 안의 값을 화면에 출력하는 내장 함수입니다.",
            "systax_code": "print(\"Hello World\")"
          },
          "task": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "코드 가독성 높이기",
            "content": "다른 개발자나 미래의 내가 코드를 쉽게 이해하려면 설명을 덧붙이는 것이 중요합니다. 방금 작성한 코드에 <span class='font-bold text-yellow-300'>'주석(Comment)'</span>을 추가하여, 해당 코드가 어떤 역할을 하는지 설명을 남겨주세요."
          },
          "briefing": {
            "character": "sena",
            "subtitle": "직속 선임의 팁",
            "title": "코드에 메모 남기기",
            "content": "주석은 코드에 남기는 메모 같은 거예요. 코드 실행에는 영향을 주지 않으면서 설명을 추가할 수 있죠[cite: 893, 904]. 파이썬에서는 <span class='font-bold text-teal-300'>`#` 기호 뒤에 오는 모든 내용</span>이 주석으로 처리돼요[cite: 891]. `starterCode`에 보면 `#` 기호만 덩그러니 있죠? 그 뒤에 `TODO` 주석에서 안내하는 대로 자유롭게 설명을 적어보세요!"
          },
          "starterCode": "# TODO: '#' 뒤에 이 파일에 대한 설명을 자유롭게 적어보세요. (예: 환영 메시지 출력 스크립트)\n\n\n# TODO: '#' 뒤에 아래 코드에 대한 설명을 자유롭게 적어보세요. (예: 환영 메시지를 화면에 출력)\n\nprint(\"Welcome again!\")\n",
          "testCode": "lines = source_code.strip().split('\\n'); assert lines[0].strip().startswith('#'), \"첫 줄에 주석이 작성되지 않았습니다.\"; assert len(lines) >= 3 and lines[-2].strip().startswith('#'), \"print문 바로 위에 주석이 작성되지 않았습니다.\"; assert 'print(\"Welcome again!\")' in lines[-1], \"print문이 코드의 마지막 줄에 있어야 합니다.\"",
          "feedback": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "가독성 향상",
              "content": "<span class='font-bold text-green-300'>주석을 적절하게 잘 추가했군요.</span> 이제 코드를 이해하기 훨씬 수월해졌습니다. 좋은 습관입니다. 다음 단계로 넘어가죠."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "주석 기호를 확인해보세요!",
              "content": "음, 주석 처리가 제대로 안 된 것 같아요. 설명을 적기 전에 <span class='font-bold text-teal-300'>`#` 기호</span>를 먼저 입력했는지 확인해주세요. `#` 기호가 없으면 파이썬이 코드로 인식해서 오류가 날 수 있어요!"
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, 주석 처리 오류!",
              "content": "코드를 실행하다가 오류가 발생했어요. 혹시 주석을 시작할 때 `#` 기호를 빠뜨린 건 아닐까요? `#` 기호가 없으면 파이썬은 그 줄을 코드로 인식하려고 해서 오류가 날 수 있어요."
            }
          },
          "task_adv": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "함수 설명 추가",
            "content": "코드 가독성을 위해 주석은 필수입니다. 제공된 `greet` 함수 코드에 <span class='font-bold text-yellow-300'>함수의 역할</span>과 <span class='font-bold text-yellow-300'>print문의 기능</span>을 설명하는 주석을 각각 적절한 위치에 추가해주세요."
          },
          "briefing_adv": {
            "character": "sena",
            "subtitle": "직속 선임의 팁",
            "title": "주석은 어디에?",
            "content": "함수나 중요한 코드 블록 바로 윗줄에 <span class='font-bold text-teal-300'>`#` 기호</span>를 사용해서 이게 어떤 기능을 하는지 설명해주는 게 일반적이에요. 복잡한 계산식이나 로직이 있다면 그 줄 끝에 간단한 설명을 덧붙이기도 하고요. 어디에 쓰는 게 다른 사람이 이해하기 쉬울지 생각해보세요!"
          },
          "starterCode_adv": "# TODO: 아래 함수 정의 바로 위에, 이 함수가 무엇을 하는 함수인지 설명하는 한 줄 주석을 추가하세요.\ndef greet(name):\n    # TODO: 아래 print문 바로 위에, 어떤 내용을 출력하는지 설명하는 주석을 추가하세요.\n    print(f\"{name}님, 다시 오신 것을 환영합니다!\")\n\n# 함수 호출 (수정 불필요)\ngreet(\"김선임\")\n",
          "testCode_adv": "lines = source_code.strip().split('\\n'); greet_def_line = -1; for i, line in enumerate(lines): if line.strip().startswith('def greet('): greet_def_line = i; break; assert greet_def_line > 0 and lines[greet_def_line - 1].strip().startswith('#'), '함수 정의 바로 위에 함수 설명 주석이 필요합니다.'; print_line = -1; for i, line in enumerate(lines): if line.strip().startswith('print(f\"'): print_line = i; break; assert print_line > 0 and lines[print_line - 1].strip().startswith('#'), 'print문 바로 위에 코드 설명 주석이 필요합니다.'",
          "feedback_adv": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "가독성 향상",
              "content": "<span class='font-bold text-green-300'>주석을 적절하게 잘 추가했군요.</span> 이제 코드를 이해하기 훨씬 수월해졌습니다. 좋은 습관입니다. 다음 단계로 넘어가죠."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "주석 기호를 확인해보세요!",
              "content": "음, 주석 처리가 제대로 안 된 것 같아요. 설명을 적기 전에 <span class='font-bold text-teal-300'>`#` 기호</span>를 먼저 입력했는지 확인해주세요. `#` 기호가 없으면 파이썬이 코드로 인식해서 오류가 날 수 있어요!"
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, 주석 처리 오류!",
              "content": "코드를 실행하다가 오류가 발생했어요. 혹시 주석을 시작할 때 `#` 기호를 빠뜨린 건 아닐까요? `#` 기호가 없으면 파이썬은 그 줄을 코드로 인식하려고 해서 오류가 날 수 있어요."
            }
          }
        },
        {
          "title": "데이터 저장하기 (변수와 자료형)",
          "filename": "server_status.py",
          "lecture": {
            "character": "profKim",
            "title": "강의 노트: 변수와 자료형",
            "keyTakeaway": "변수는 값을 저장하는 공간이며, `=` 기호를 사용해 값을 할당(저장)합니다.",
            "sandboxCode": "# my_age 변수에 자신의 나이를 숫자로 저장하고 출력해보세요.\nmy_age = 25\nprint(my_age)",
            "sections": [
              {
                "heading": "핵심 개념",
                "text": "변수(Variable)는 데이터를 저장하기 위해 이름표를 붙인 메모리 공간입니다 [cite: 1041-1043]. 파이썬에서는 변수를 만들기 전에 미리 타입을 선언할 필요가 없습니다 [cite: 1137-1138]. 값을 할당하면 그 값의 종류에 따라 자동으로 자료형(Data Type)이 결정됩니다[cite: 1052].",
                "code": null
              },
              {
                "heading": "기본 문법",
                "text": "`변수이름 = 값` 형태로 값을 할당합니다[cite: 1128].",
                "code": "# 숫자형 (Integer)\nuser_count = 100\n\n# 문자열 (String)\nserver_status = \"running\"\n\n# 불리언 (Boolean)\nis_admin = True"
              },
              {
                "heading": "활용 사례",
                "text": "사용자 이름, 나이, 점수 등 프로그램이 동작하는 동안 계속해서 사용되거나 변경될 수 있는 모든 데이터를 저장하는 데 사용됩니다[cite: 1052].",
                "code": null
              },
              {
                "heading": "주의점 및 팁",
                "text": "변수 이름은 숫자로 시작할 수 없으며, 공백을 포함할 수 없습니다 [cite: 1047-1048, 1050]. 또한, `my_name`과 `My_Name`은 서로 다른 변수로 인식될 만큼 대소문자를 엄격하게 구분합니다[cite: 1051].",
                "code": null
              }
            ]
          },
          "syntax_key": {
            "syntax_title": "변수 (Variable)",
            "syntax_comment": "데이터를 저장하기 위해 이름표를 붙인 공간입니다. `=` 기호로 값을 할당합니다.",
            "systax_code": "my_variable = 100"
          },
          "task": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "서비스 기본 정보 설정",
            "content": "좋은 아침입니다, ${userName}님. 간단한 업무부터 시작하죠. 우리 서비스의 <span class='font-bold text-yellow-300'>운영 상태를 관리할 변수</span>가 필요합니다. 서비스 이름(`service_name`)과 현재 동시 접속자 수(`concurrent_users`), 그리고 서비스 오픈 여부(`is_active`)를 각각 <span class='font-bold text-yellow-300'>문자열, 숫자, 불리언(True/False) 값</span>으로 변수에 저장해주세요."
          },
          "briefing": {
            "character": "sena",
            "subtitle": "직속 선임의 OJT",
            "title": "데이터를 담는 상자, 변수",
            "content": "세나 선임이에요! 변수는 데이터를 잠시 저장해두는 이름표 같은 거예요 [cite: 1041-1043]. `starterCode`를 보면 `이름 = ` 형태가 보이죠? <span class='font-bold text-teal-300'>`=` 기호</span>는 오른쪽 값을 왼쪽 이름표에 저장하라는 뜻이에요[cite: 1128]. `TODO` 주석대로 각 빈칸에 <span class='font-bold text-teal-300'>`\"LogiCore\"`, `100`, `True`</span>를 정확히 입력해보세요. 글자(`\"LogiCore\"`)는 따옴표가 필요하고, 숫자(`100`)나 참/거짓(`True`)은 필요 없다는 것도 기억해두면 좋아요!"
          },
          "starterCode": "# TODO: '=' 오른쪽에 \"LogiCore\"를 따옴표와 함께 그대로 입력하세요.\nservice_name = \n\n# TODO: '=' 오른쪽에 숫자 100을 입력하세요. (숫자는 따옴표가 필요 없어요)\nconcurrent_users = \n\n# TODO: '=' 오른쪽에 True (첫 글자 대문자)를 입력하세요.\nis_active = \n",
          "testCode": "assert 'service_name' in locals() and service_name == 'LogiCore', \"service_name 변수에 'LogiCore' 문자열을 할당해야 합니다.\"; assert 'concurrent_users' in locals() and concurrent_users == 100, \"concurrent_users 변수에 숫자 100을 할당해야 합니다.\"; assert 'is_active' in locals() and is_active is True, \"is_active 변수에 불리언 값 True를 할당해야 합니다.\"",
          "feedback": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "기본 설정 완료",
              "content": "<span class='font-bold text-green-300'>변수들이 정확하게 선언되었군요.</span> 좋습니다. 이제 이 변수들을 이용해 우리 서비스가 다양한 상황에 맞게 동작하도록 만들 수 있습니다. 다음 업무로 넘어가죠."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "값을 다시 확인해볼까요?",
              "content": "음, 저장된 값이 조금 다른 것 같아요. `service_name`에는 <span class='font-bold text-teal-300'>따옴표(`\"`)</span>로 감싼 `\"LogiCore\"`를 입력했나요? `concurrent_users`에는 숫자 <span class='font-bold text-teal-300'>`100`</span>을, `is_active`에는 <span class='font-bold text-teal-300'>`True`(대문자 T)</span>를 정확히 입력했는지 확인해주세요!"
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, 문법 오류!",
              "content": "코드를 실행하다가 오류가 발생했어요. 변수 이름 규칙을 어긴 건 아닐까요? 변수 이름은 숫자로 시작할 수 없고, `my-name`처럼 특수문자를 쓸 수 없어요. 변수 이름을 다시 한번 확인해주세요!"
            }
          },
          "task_adv": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "서버 상태 정보 함수 완성",
            "content": "서버 상태 정보를 반환하는 함수 `get_server_status`가 있습니다. 함수 내부에 <span class='font-bold text-yellow-300'>서비스 이름('LogiCore'), 동시 접속자 수(100), 오픈 여부(True)</span>를 각각 적절한 변수에 저장하고, 이 변수들을 사용하여 반환될 딕셔너리를 완성해주세요."
          },
          "briefing_adv": {
            "character": "sena",
            "subtitle": "직속 선임의 팁",
            "title": "함수 안에서의 변수 사용",
            "content": "함수 안에서도 변수를 만드는 건 똑같아요. `=` 기호를 써서 <span class='font-bold text-teal-300'>변수 이름에 값을 저장</span>하면 되죠. 문자열은 따옴표, 숫자는 그냥 쓰고, 참/거짓은 `True`나 `False`로 쓰는 것만 기억하면 돼요. 이렇게 만든 변수들을 딕셔너리에 넣어서 반환하는 구조네요!"
          },
          "starterCode_adv": "# 아래 함수는 서버 상태 정보를 딕셔너리로 반환합니다.\n# TODO: 함수 내부에 service_name, concurrent_users, is_active 변수를\n#       각각 \"LogiCore\", 100, True 값으로 정의하고,\n#       이 변수들을 사용하여 딕셔너리를 완성하세요.\ndef get_server_status():\n    # 여기에 변수들을 정의하세요.\n    service_name = \"\"\n    concurrent_users = 0\n    is_active = False\n    \n    status_info = {\n        \"name\": service_name,\n        \"users\": concurrent_users,\n        \"active\": is_active\n    }\n    return status_info\n\n# 함수 호출 및 결과 확인 (수정 불필요)\nserver_info = get_server_status()\nprint(server_info)\n",
          "testCode_adv": "assert 'get_server_status' in locals() and callable(get_server_status), 'get_server_status 함수가 정의되지 않았습니다.'; status = get_server_status(); assert isinstance(status, dict), 'get_server_status 함수는 딕셔너리를 반환해야 합니다.'; assert status.get('name') == 'LogiCore', \"딕셔너리의 'name' 값이 'LogiCore'여야 합니다.\"; assert status.get('users') == 100, \"딕셔너리의 'users' 값이 100이어야 합니다.\"; assert status.get('active') is True, \"딕셔너리의 'active' 값이 True여야 합니다.\"",
          "feedback_adv": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "기본 설정 완료",
              "content": "<span class='font-bold text-green-300'>변수들이 정확하게 선언되었군요.</span> 좋습니다. 이제 이 변수들을 이용해 우리 서비스가 다양한 상황에 맞게 동작하도록 만들 수 있습니다. 다음 업무로 넘어가죠."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "값을 다시 확인해볼까요?",
              "content": "음, 저장된 값이 조금 다른 것 같아요. `service_name`에는 <span class='font-bold text-teal-300'>따옴표(`\"`)</span>로 감싼 `\"LogiCore\"`를 입력했나요? `concurrent_users`에는 숫자 <span class='font-bold text-teal-300'>`100`</span>을, `is_active`에는 <span class='font-bold text-teal-300'>`True`(대문자 T)</span>를 정확히 입력했는지 확인해주세요!"
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, 문법 오류!",
              "content": "코드를 실행하다가 오류가 발생했어요. 변수 이름 규칙을 어긴 건 아닐까요? 변수 이름은 숫자로 시작할 수 없고, `my-name`처럼 특수문자를 쓸 수 없어요. 변수 이름을 다시 한번 확인해주세요!"
            }
          }
        }
      ]
    },
    {
      "week": 2,
      "title": "데이터 가공하기: 연산자와 문자열",
      "cycles": [
        {
          "title": "숫자 계산하기 (연산자)",
          "filename": "analysis.py",
          "lecture": {
            "character": "profKim",
            "title": "강의 노트: 연산자와 수식",
            "keyTakeaway": "연산자는 값을 계산하고 비교하는 데 사용되며, 괄호로 계산 순서를 제어할 수 있습니다.",
            "sandboxCode": "my_score = 85\npass_score = 60\n\n# my_score가 pass_score보다 높은지 확인해보세요.\nprint(my_score > pass_score)",
            "sections": [
              {
                "heading": "핵심 개념",
                "text": "연산자(Operator)는 덧셈, 뺄셈, 비교 등 특정 연산을 수행하는 기호입니다[cite: 1207]. 연산자와 값이 결합하여 만들어지는 하나의 식을 수식(Expression)이라고 합니다. 수식은 계산되어 하나의 결과값을 만들어냅니다 [cite: 1205-1206].",
                "code": null
              },
              {
                "heading": "기본 문법",
                "text": "다양한 연산자를 사용하여 수식을 만들 수 있습니다 [cite: 1218-1292].",
                "code": "# 산술 연산자\nresult = 10 + 5   # 15\nresult = 10 / 2   # 5.0 (파이썬 3 기준, 파이썬 2에서는 5)\n\n# 비교 연산자 (결과는 True 또는 False)\nis_equal = (10 == 5) # False\nis_greater = (10 > 5)  # True"
              },
              {
                "heading": "활용 사례",
                "text": "점수 합계 계산, 상품 가격 비교, 사용자 입력값 검증 등 데이터에 기반한 모든 판단과 계산에 사용됩니다[cite: 1203].",
                "code": null
              },
              {
                "heading": "주의점 및 팁",
                "text": "곱셈/나눗셈(`*`, `/`)이 덧셈/뺄셈(`+`, `-`)보다 먼저 계산됩니다 [cite: 1306-1307]. 계산 순서가 헷갈릴 때는, 괄호 `()`를 사용하여 명확하게 순서를 지정해주는 것이 좋은 습관입니다[cite: 1308, 1349].",
                "code": null
              }
            ]
          },
          "syntax_key": {
            "syntax_title": "산술 연산자",
            "syntax_comment": "숫자를 계산하는 기호입니다. `+`, `-`, `*`, `/` 등이 있습니다.",
            "systax_code": "result = 10 + 5"
          },
          "task": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "사용자 데이터 분석",
            "content": "기획팀에서 간단한 데이터 분석을 요청했습니다. 어제 하루 동안의 <span class='font-bold text-yellow-300'>총 방문자 수(total_visits)가 1,250명</span>이고, <span class='font-bold text-yellow-300'>유료 전환 사용자(paid_users)가 50명</span>일 때, '유료 전환율(conversion_rate)'이 몇 퍼센트인지 계산해서 출력해주세요."
          },
          "briefing": {
            "character": "sena",
            "subtitle": "직속 선임의 팁",
            "title": "파이썬으로 계산하기",
            "content": "간단한 계산이네요! (유료 전환 사용자 / 총 방문자 수) * 100 이죠? 파이썬에서는 <span class='font-bold text-teal-300'>나눗셈 `/`</span> 와 <span class='font-bold text-teal-300'>곱셈 `*`</span> 기호를 바로 쓸 수 있어요[cite: 1224, 1230]. `starterCode`의 `conversion_rate = ` 오른쪽 빈칸에 `(paid_users / total_visits) * 100` 이라고 그대로 입력해보세요. 괄호도 중요해요! 마지막으로 `print()` 괄호 안에는 계산 결과가 저장된 <span class='font-bold text-teal-300'>`conversion_rate`</span> 변수 이름을 넣으면 끝!"
          },
          "starterCode": "total_visits = 1250\npaid_users = 50\n\n# TODO: '=' 오른쪽에 전환율 계산식을 작성하세요.\n# 전환율 공식: (유료 전환 사용자 / 총 방문자 수) * 100\nconversion_rate = \n\n# TODO: print() 괄호 안에 conversion_rate 변수 이름을 넣어 값을 출력하세요.\nprint()\n",
          "testCode": "assert 'conversion_rate' in locals(), \"'conversion_rate' 변수가 선언되지 않았습니다.\"; assert abs(conversion_rate - 4.0) < 0.001, f\"계산된 전환율이 4.0이 아닙니다. 실제 계산값: {conversion_rate}\"; import io; from contextlib import redirect_stdout; f = io.StringIO(); with redirect_stdout(f): source_code = student_code; exec(source_code); output = f.getvalue().strip(); assert abs(float(output) - 4.0) < 0.001, 'conversion_rate의 값이 올바르게 출력되지 않았습니다.'",
          "feedback": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "분석 결과 확인",
              "content": "<span class='font-bold text-green-300'>전환율 계산이 정확하네요.</span> 좋습니다. 이런 간단한 계산 자동화가 개발의 시작입니다. 이제 이 결과를 보고서 형태로 보기 좋게 만드는 작업을 해보죠."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "계산식이나 출력을 확인해볼까요?",
              "content": "어라, 계산 결과가 4.0이 아닌데요? `conversion_rate = ` 오른쪽에 <span class='font-bold text-teal-300'>(paid_users / total_visits) * 100</span> 이라고 정확히 입력했는지 확인해보세요. 변수 이름에 오타가 있거나, 괄호 `()` 를 빠뜨렸을 수도 있어요! 마지막 `print()` 괄호 안에는 변수 이름 `conversion_rate`를 넣었는지도요."
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, 계산 중 오류!",
              "content": "코드를 실행하다가 오류가 발생했어요. 혹시 숫자가 아닌 값으로 계산을 시도했거나, 존재하지 않는 변수를 사용한 건 아닐까요? 변수 이름에 오타는 없는지 꼼꼼히 확인해보세요."
            }
          },
          "task_adv": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "전환율 계산 함수 완성",
            "content": "전환율을 계산하는 함수 `calculate_conversion_rate`가 있습니다. 함수 내부의 계산 로직을 완성하여, <span class='font-bold text-yellow-300'>총 방문자 수와 유료 사용자 수를 바탕으로 정확한 전환율(%)을 계산</span>하고 반환하도록 수정해주세요."
          },
          "briefing_adv": {
            "character": "sena",
            "subtitle": "직속 선임의 팁",
            "title": "함수 안에서의 계산",
            "content": "함수 안에서 계산하는 것도 똑같아요! 매개변수로 넘어온 `total_visits`와 `paid_users` 변수를 사용해서 <span class='font-bold text-teal-300'>산술 연산자(`*`, `/`)</span>로 계산식을 만들고, 그 결과를 `rate` 변수에 저장하면 돼요. 괄호를 써서 계산 순서를 명확히 하는 것도 좋고요!"
          },
          "starterCode_adv": "# 아래 함수는 방문자 수와 유료 사용자 수를 받아 전환율을 계산하여 반환합니다.\n# TODO: 함수 본문에서 전환율 계산 로직을 완성하세요.\n# 전환율 공식: (유료 사용자 / 총 방문자 수) * 100\ndef calculate_conversion_rate(total_visits, paid_users):\n    rate = 0\n    # 여기에 계산식을 작성하여 rate 변수에 저장하세요.\n    \n    return rate\n\n# 함수 호출 및 결과 확인 (수정 불필요)\nconversion_rate = calculate_conversion_rate(1250, 50)\nprint(conversion_rate)\n",
          "testCode_adv": "assert callable(calculate_conversion_rate), 'calculate_conversion_rate 함수가 정의되지 않았습니다.'; result = calculate_conversion_rate(1250, 50); assert abs(result - 4.0) < 0.001, f'함수 반환값이 올바르지 않습니다. 기대값: 4.0, 실제값: {result}'; assert 'conversion_rate' in locals() and abs(conversion_rate - 4.0) < 0.001, '전역 변수 conversion_rate 값이 올바르지 않습니다.'; import io; from contextlib import redirect_stdout; f = io.StringIO(); with redirect_stdout(f): source_code = student_code; exec(source_code); output = f.getvalue().strip(); assert abs(float(output) - 4.0) < 0.001, 'conversion_rate의 값이 올바르게 출력되지 않았습니다.'",
          "feedback_adv": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "분석 결과 확인",
              "content": "<span class='font-bold text-green-300'>전환율 계산이 정확하네요.</span> 좋습니다. 이런 간단한 계산 자동화가 개발의 시작입니다. 이제 이 결과를 보고서 형태로 보기 좋게 만드는 작업을 해보죠."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "계산식이나 출력을 확인해볼까요?",
              "content": "어라, 계산 결과가 4.0이 아닌데요? `conversion_rate = ` 오른쪽에 <span class='font-bold text-teal-300'>(paid_users / total_visits) * 100</span> 이라고 정확히 입력했는지 확인해보세요. 변수 이름에 오타가 있거나, 괄호 `()` 를 빠뜨렸을 수도 있어요! 마지막 `print()` 괄호 안에는 변수 이름 `conversion_rate`를 넣었는지도요."
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, 계산 중 오류!",
              "content": "코드를 실행하다가 오류가 발생했어요. 혹시 숫자가 아닌 값으로 계산을 시도했거나, 존재하지 않는 변수를 사용한 건 아닐까요? 변수 이름에 오타는 없는지 꼼꼼히 확인해보세요."
            }
          }
        },
        {
          "title": "문자열 조합하기 (포맷팅)",
          "filename": "report.py",
          "lecture": {
            "character": "profKim",
            "title": "강의 노트: 문자열 포맷팅",
            "keyTakeaway": "f-string은 `f\"...{변수}...\"` 형태로, 변수 값을 문자열에 삽입하는 가장 현대적이고 편리한 방법입니다.",
            "sandboxCode": "item = \"커피\"\nprice = 5000\n\n# f-string을 이용해 \"상품: 커피, 가격: 5000원\"을 출력해보세요.\nprint(f\"상품: {item}, 가격: {price}원\")",
            "sections": [
              {
                "heading": "핵심 개념",
                "text": "문자열 포맷팅(String Formatting)은 문자열의 특정 위치에 변수의 값을 삽입하여, 동적인 문자열을 생성하는 기법입니다 [cite: 960-961, 963]. 이를 통해 형식화된 보고서, 알림 메시지 등을 쉽게 만들 수 있습니다.",
                "code": null
              },
              {
                "heading": "기본 문법",
                "text": "문자열 시작 따옴표 앞에 `f`를 붙이고, 삽입할 변수나 값을 중괄호 `{}`로 감싸줍니다[cite: 988].",
                "code": "# f-string (가장 추천하는 방식)\nname = \"Sena\"\nage = 30\nmessage = f\"안녕하세요, 제 이름은 {name}이고, 나이는 {age}살 입니다.\""
              },
              {
                "heading": "활용 사례",
                "text": "로그 메시지 기록, 사용자에게 보내는 이메일 내용 생성, 데이터베이스 쿼리 문자열 생성 등 변수와 문자열을 조합해야 하는 모든 상황에 사용됩니다[cite: 960].",
                "code": null
              },
              {
                "heading": "주의점 및 팁",
                "text": "f-string을 사용할 때, 문자열 시작 따옴표 앞에 `f`를 빠뜨리지 않도록 주의하세요[cite: 988]. 중괄호 `{}` 안에는 변수뿐만 아니라 ` {age + 1} `과 같은 간단한 계산식도 넣을 수 있습니다.",
                "code": null
              }
            ]
          },
          "syntax_key": {
            "syntax_title": "f-string",
            "syntax_comment": "문자열 앞에 `f`를 붙여 중괄호 안에 변수를 넣어 출력하는 기능입니다.",
            "systax_code": "print(\"Hello World\")"
          },
          "task": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "동적 보고 메시지 생성",
            "content": "방금 계산한 <span class='font-bold text-yellow-300'>유료 전환율 결과를 보고 메시지로 만드는 업무</span>입니다. `report_date` 변수(예: '2025-09-29')와 `conversion_rate` 변수의 값을 조합해서, <span class='font-bold text-yellow-300'>\"[날짜] 기준, 유료 전환율은 [전환율]% 입니다.\"</span> 와 같은 최종 문자열을 만들어 출력해주세요."
          },
          "briefing": {
            "character": "sena",
            "subtitle": "직속 선임의 팁",
            "title": "f-string으로 문자열 꾸미기!",
            "content": "변수 값을 문자열 안에 쏙 넣고 싶을 때 <span class='font-bold text-teal-300'>f-string</span>을 쓰면 정말 편해요! `starterCode`의 `report_message = ` 오른쪽 빈칸에 이렇게 입력해보세요: <span class='font-bold text-teal-300'>`f\"{report_date} 기준, 유료 전환율은 {conversion_rate}% 입니다.\"`</span>. 문자열 시작 따옴표 앞에 <span class='font-bold text-teal-300'>`f`</span>를 붙이고, 변수 이름을 <span class='font-bold text-teal-300'>중괄호 `{}`</span>로 감싸는 게 핵심이에요! 마지막 `print()` 괄호 안에는 만들어진 문자열이 담긴 `report_message` 변수 이름을 넣으면 되겠죠?"
          },
          "starterCode": "report_date = '2025-09-29'\nconversion_rate = 4.0\n\n# TODO: '=' 오른쪽에 f-string을 사용하여 \"[날짜] 기준, 유료 전환율은 [전환율]% 입니다.\" 형식의 문자열을 만드세요.\n#       문자열 앞에 f를 붙이고, 변수는 {} 안에 넣으세요. 예: f\"날짜: {report_date}\"\nreport_message = \n\n# TODO: print() 괄호 안에 report_message 변수 이름을 넣어 값을 출력하세요.\nprint()\n",
          "testCode": "report_date = '2025-09-29'; conversion_rate = 4.0; expected_output = f\"{report_date} 기준, 유료 전환율은 {conversion_rate}% 입니다.\"; assert 'report_message' in locals(), \"'report_message' 변수를 선언해야 합니다.\"; assert report_message == expected_output, f\"report_message 변수의 값이 기대와 다릅니다. 기대값: '{expected_output}', 실제값: '{report_message}'\"; import io; from contextlib import redirect_stdout; f = io.StringIO(); with redirect_stdout(f): source_code = student_code; exec(source_code); output = f.getvalue().strip(); assert output == expected_output, 'report_message의 값이 올바르게 출력되지 않았습니다.'",
          "feedback": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "보고서 형식 완성",
              "content": "<span class='font-bold text-green-300'>메시지가 아주 깔끔하게 출력되는군요.</span> f-string을 잘 활용했네요. 데이터를 다루는 기본기를 모두 익혔으니, 다음 주차에는 더 복잡한 로직을 다뤄보겠습니다. 수고했어요."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "f-string 형식을 확인해보세요",
              "content": "음, 만들어진 메시지가 요청한 형식과 조금 다르네요. 문자열 시작 따옴표 앞에 <span class='font-bold text-teal-300'>`f`</span>를 붙였는지, 변수 이름(`report_date`, `conversion_rate`)을 <span class='font-bold text-teal-300'>중괄호 `{}`</span>로 정확히 감쌌는지 확인해주세요. 띄어쓰기나 `%` 같은 문자도 똑같이 입력해야 해요!"
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, 문법 오류!",
              "content": "코드를 실행하다가 오류가 발생했어요. f-string을 사용할 때 가장 흔한 실수는 문자열 앞에 `f`를 빠뜨리는 거예요. 혹시 잊으신 건 아닐까요? 아니면 중괄호 `{}`를 빠뜨렸거나, 변수 이름에 오타가 있을 수도 있어요!"
            }
          },
          "task_adv": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "보고서 메시지 생성 함수 완성",
            "content": "보고서 메시지를 생성하는 `create_report_message` 함수가 있습니다. 함수 내부 로직을 완성하여, <span class='font-bold text-yellow-300'>날짜 문자열과 전환율 숫자를 받아 지정된 형식의 보고서 문자열을 반환</span>하도록 수정해주세요."
          },
          "briefing_adv": {
            "character": "sena",
            "subtitle": "직속 선임의 팁",
            "title": "함수 안에서 f-string 활용!",
            "content": "함수 안에서도 <span class='font-bold text-teal-300'>f-string</span>을 똑같이 쓸 수 있어요! 매개변수로 받은 `date_str`과 `rate_float` 변수를 문자열 안에 `{}` 중괄호로 넣어서 조합하면 끝이에요. 참 쉽죠?"
          },
          "starterCode_adv": "# 아래 함수는 날짜와 전환율을 받아 보고서 문자열을 생성하여 반환합니다.\n# TODO: 함수 본문에서 f-string을 사용하여 지정된 형식의 보고서 문자열을 만들고 반환하세요.\n# 형식: \"[날짜] 기준, 유료 전환율은 [전환율]% 입니다.\"\ndef create_report_message(date_str, rate_float):\n    message = \"\"\n    # 여기에 f-string을 사용하여 message 변수에 문자열을 저장하세요.\n    \n    return message\n\n# 함수 호출 및 결과 확인 (수정 불필요)\nreport_message = create_report_message('2025-09-29', 4.0)\nprint(report_message)\n",
          "testCode_adv": "assert callable(create_report_message), 'create_report_message 함수가 정의되지 않았습니다.'; result = create_report_message('2025-09-29', 4.0); expected = '2025-09-29 기준, 유료 전환율은 4.0% 입니다.'; assert result == expected, f'함수 반환값이 올바르지 않습니다. 기대값: \"{expected}\", 실제값: \"{result}\"'; assert 'report_message' in locals() and report_message == expected, '전역 변수 report_message 값이 올바르지 않습니다.'; import io; from contextlib import redirect_stdout; f = io.StringIO(); with redirect_stdout(f): source_code = student_code; exec(source_code); output = f.getvalue().strip(); assert output == expected, 'report_message의 값이 올바르게 출력되지 않았습니다.'",
          "feedback_adv": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "보고서 형식 완성",
              "content": "<span class='font-bold text-green-300'>메시지가 아주 깔끔하게 출력되는군요.</span> f-string을 잘 활용했네요. 데이터를 다루는 기본기를 모두 익혔으니, 다음 주차에는 더 복잡한 로직을 다뤄보겠습니다. 수고했어요."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "f-string 형식을 확인해보세요",
              "content": "음, 만들어진 메시지가 요청한 형식과 조금 다르네요. 문자열 시작 따옴표 앞에 <span class='font-bold text-teal-300'>`f`</span>를 붙였는지, 변수 이름(`report_date`, `conversion_rate`)을 <span class='font-bold text-teal-300'>중괄호 `{}`</span>로 정확히 감쌌는지 확인해주세요. 띄어쓰기나 `%` 같은 문자도 똑같이 입력해야 해요!"
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, 문법 오류!",
              "content": "코드를 실행하다가 오류가 발생했어요. f-string을 사용할 때 가장 흔한 실수는 문자열 앞에 `f`를 빠뜨리는 거예요. 혹시 잊으신 건 아닐까요? 아니면 중괄호 `{}`를 빠뜨렸거나, 변수 이름에 오타가 있을 수도 있어요!"
            }
          }
        },
        {
          "title": "미니 프로젝트: 간단한 계산기 만들기",
          "filename": "calculator.py",
          "lecture": {
            "character": "profKim",
            "title": "교수님의 조언: 지식의 통합",
            "keyTakeaway": "프로그래밍은 배운 지식들을 연결하고 조합하여 실제 문제를 해결하는 과정입니다.",
            "sandboxCode": "# 변수 선언\nradius = 5\npi = 3.14\n\n# 원의 넓이 계산 (반지름 * 반지름 * 원주율)\narea = radius * radius * pi\n\n# 결과 출력\nprint(f\"반지름이 {radius}인 원의 넓이는 {area}입니다.\")",
            "sections": [
              {
                "heading": "핵심 조언",
                "text": "이번 미니 프로젝트는 새로운 개념보다는 지금까지 배운 변수 선언, 기본 자료형(숫자), 산술 연산자, 그리고 문자열 포맷팅(f-string)과 print 함수를 종합적으로 활용하는 연습입니다. 각 단계별로 필요한 도구를 떠올리고 조합하여 문제를 해결하는 개발자의 사고방식을 연습해보세요.",
                "code": null
              }
            ]
          },
          "syntax_key": {
            "syntax_title": "print()",
            "syntax_comment": "`print()`는 괄호 안의 값을 화면에 출력하는 내장 함수입니다.",
            "systax_code": "print(\"Hello World\")"
          },
          "task": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "미니 프로젝트: 계산 자동화",
            "content": "이번 주 배운 내용을 종합하여 간단한 계산기 스크립트를 만들어봅시다. <span class='font-bold text-yellow-300'>두 개의 숫자(10과 5)를 변수에 저장</span>하고, 이 두 숫자의 <span class='font-bold text-yellow-300'>덧셈, 뺄셈, 곱셈, 나눗셈 결과를 각각 계산</span>하여 별도의 변수에 저장해주세요. 마지막으로, 계산된 결과들을 <span class='font-bold text-yellow-300'>지정된 형식에 맞춰 화면에 출력</span>해야 합니다."
          },
          "briefing": {
            "character": "sena",
            "subtitle": "직속 선임의 팁",
            "title": "배운 것들을 조합해봐요!",
            "content": "미니 프로젝트네요! 지금까지 배운 걸 써먹을 시간이에요. `starterCode`의 빈칸들을 채워볼까요? 먼저 <span class='font-bold text-teal-300'>`num1`과 `num2`에 각각 10과 5</span>를 입력하고, 다음 빈칸들에는 <span class='font-bold text-teal-300'>`num1 + num2`, `num1 - num2`, `num1 * num2`, `num1 / num2`</span> 계산식을 넣으면 돼요. 마지막 출력 부분은 <span class='font-bold text-teal-300'>f-string</span> 기억나죠? `print(f\"덧셈 결과: {add_result}\")` 처럼 네 줄을 완성해보세요!"
          },
          "starterCode": "# TODO: '=' 오른쪽에 숫자 10을 입력하세요.\nnum1 = \n\n# TODO: '=' 오른쪽에 숫자 5를 입력하세요.\nnum2 = \n\n# TODO: '=' 오른쪽에 num1과 num2를 더하는(+) 식을 작성하세요.\nadd_result = \n\n# TODO: '=' 오른쪽에 num1에서 num2를 빼는(-) 식을 작성하세요.\nsub_result = \n\n# TODO: '=' 오른쪽에 num1과 num2를 곱하는(*) 식을 작성하세요.\nmul_result = \n\n# TODO: '=' 오른쪽에 num1을 num2로 나누는(/) 식을 작성하세요.\ndiv_result = \n\n# TODO: print() 함수와 f-string을 사용하여 결과를 아래 형식으로 출력하세요.\n# 예: print(f\"덧셈 결과: {add_result}\")\n\n\n\n\n",
          "testCode": "assert 'num1' in locals() and num1 == 10, 'num1 변수 값이 올바르지 않습니다.'; assert 'num2' in locals() and num2 == 5, 'num2 변수 값이 올바르지 않습니다.'; assert 'add_result' in locals() and add_result == 15, f'덧셈 결과가 올바르지 않습니다. 기대값: 15, 실제값: {locals().get(\"add_result\")}'; assert 'sub_result' in locals() and sub_result == 5, f'뺄셈 결과가 올바르지 않습니다. 기대값: 5, 실제값: {locals().get(\"sub_result\")}'; assert 'mul_result' in locals() and mul_result == 50, f'곱셈 결과가 올바르지 않습니다. 기대값: 50, 실제값: {locals().get(\"mul_result\")}'; assert 'div_result' in locals() and div_result == 2.0, f'나눗셈 결과가 올바르지 않습니다. 기대값: 2.0, 실제값: {locals().get(\"div_result\")}'; import io; from contextlib import redirect_stdout; f = io.StringIO(); with redirect_stdout(f): source_code = student_code; exec(source_code); output = f.getvalue().strip().split('\\n'); expected_lines = [f'덧셈 결과: {add_result}', f'뺄셈 결과: {sub_result}', f'곱셈 결과: {mul_result}', f'나눗셈 결과: {div_result}']; assert len(output) == 4, '4줄의 결과가 출력되어야 합니다.'; assert all(out == exp for out, exp in zip(output, expected_lines)), f'출력 형식이 올바르지 않습니다.\\n기대값:\\n{chr(10).join(expected_lines)}\\n실제값:\\n{chr(10).join(output)}'",
          "feedback": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "첫 미니 프로젝트 성공!",
              "content": "<span class='font-bold text-green-300'>모든 계산 결과가 정확하고 출력 형식도 완벽하군요!</span> 배운 내용들을 잘 조합해서 첫 번째 미니 프로젝트를 성공적으로 완료했습니다. 훌륭합니다. 이런 경험들이 쌓여 더 복잡한 문제도 해결할 수 있게 될 겁니다."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "디버깅 지원",
              "title": "계산식이나 출력을 확인해볼까요?",
              "content": "결과가 조금 다르네요. `num1`, `num2` 변수에 값을 제대로 입력했는지, 각 계산식(`+`, `-`, `*`, `/`)을 올바르게 작성했는지 확인해주세요. 마지막 출력 부분에서 f-string 형식이나 변수 이름에 오타가 있을 수도 있어요."
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "디버깅 지원",
              "title": "앗, 코드 실행 오류!",
              "content": "코드를 실행하는 중에 오류가 발생했어요. 변수 이름에 오타가 있거나, 정의되지 않은 변수를 사용하려고 한 건 아닐까요? print 함수 안에 f-string을 사용할 때 문법 오류가 있을 수도 있으니 꼼꼼하게 확인해보세요."
            }
          },
          "task_adv": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "미니 프로젝트: 계산기 함수 완성",
            "content": "기본적인 계산기 함수들이 준비되어 있습니다. <span class='font-bold text-yellow-300'>덧셈, 뺄셈, 곱셈, 나눗셈 함수(`add`, `subtract`, `multiply`, `divide`) 각각의 내부 로직을 완성</span>하여, 두 숫자를 입력받아 올바른 계산 결과를 반환하도록 수정해주세요. 함수들을 완성하면 전체 계산 결과가 출력될 것입니다."
          },
          "briefing_adv": {
            "character": "sena",
            "subtitle": "직속 선임의 팁",
            "title": "함수로 계산하기",
            "content": "함수 안에서 계산하는 것도 어렵지 않아요! 각 함수는 두 개의 숫자(`a`, `b`)를 받으니까, 그 숫자들을 <span class='font-bold text-teal-300'>산술 연산자(`+`, `-`, `*`, `/`)</span>로 계산해서 <span class='font-bold text-teal-300'>`return`</span> 키워드로 돌려주기만 하면 돼요. 예를 들어 `add` 함수는 `return a + b` 가 되겠죠?"
          },
          "starterCode_adv": "# 아래 4개의 함수는 각각 두 숫자를 받아 덧셈, 뺄셈, 곱셈, 나눗셈 결과를 반환합니다.\n# TODO: 각 함수의 본문을 완성하여 올바른 계산 결과를 반환하도록 수정하세요.\ndef add(a, b):\n    return 0 # 수정 필요\n\ndef subtract(a, b):\n    return 0 # 수정 필요\n\ndef multiply(a, b):\n    return 0 # 수정 필요\n\ndef divide(a, b):\n    return 0 # 수정 필요\n\n# 함수 호출 및 결과 출력 (수정 불필요)\nnum1 = 10\nnum2 = 5\nadd_result = add(num1, num2)\nsub_result = subtract(num1, num2)\nmul_result = multiply(num1, num2)\ndiv_result = divide(num1, num2)\n\nprint(f\"덧셈 결과: {add_result}\")\nprint(f\"뺄셈 결과: {sub_result}\")\nprint(f\"곱셈 결과: {mul_result}\")\nprint(f\"나눗셈 결과: {div_result}\")\n",
          "testCode_adv": "assert callable(add) and add(10, 5) == 15, 'add 함수가 올바르게 동작하지 않습니다.'; assert callable(subtract) and subtract(10, 5) == 5, 'subtract 함수가 올바르게 동작하지 않습니다.'; assert callable(multiply) and multiply(10, 5) == 50, 'multiply 함수가 올바르게 동작하지 않습니다.'; assert callable(divide) and divide(10, 5) == 2.0, 'divide 함수가 올바르게 동작하지 않습니다.'; assert 'add_result' in locals() and add_result == 15; assert 'sub_result' in locals() and sub_result == 5; assert 'mul_result' in locals() and mul_result == 50; assert 'div_result' in locals() and div_result == 2.0; import io; from contextlib import redirect_stdout; f = io.StringIO(); with redirect_stdout(f): source_code = student_code; exec(source_code); output = f.getvalue().strip().split('\\n'); expected_lines = [f'덧셈 결과: {add_result}', f'뺄셈 결과: {sub_result}', f'곱셈 결과: {mul_result}', f'나눗셈 결과: {div_result}']; assert len(output) == 4, '4줄의 결과가 출력되어야 합니다.'; assert all(out == exp for out, exp in zip(output, expected_lines)), f'출력 형식이 올바르지 않습니다.\\n기대값:\\n{chr(10).join(expected_lines)}\\n실제값:\\n{chr(10).join(output)}'",
          "feedback_adv": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "첫 미니 프로젝트 성공!",
              "content": "<span class='font-bold text-green-300'>모든 계산 결과가 정확하고 출력 형식도 완벽하군요!</span> 배운 내용들을 잘 조합해서 첫 번째 미니 프로젝트를 성공적으로 완료했습니다. 훌륭합니다. 이런 경험들이 쌓여 더 복잡한 문제도 해결할 수 있게 될 겁니다."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "디버깅 지원",
              "title": "계산식이나 출력을 확인해볼까요?",
              "content": "결과가 조금 다르네요. `num1`, `num2` 변수에 값을 제대로 입력했는지, 각 계산식(`+`, `-`, `*`, `/`)을 올바르게 작성했는지 확인해주세요. 마지막 출력 부분에서 f-string 형식이나 변수 이름에 오타가 있을 수도 있어요."
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "디버깅 지원",
              "title": "앗, 코드 실행 오류!",
              "content": "코드를 실행하는 중에 오류가 발생했어요. 변수 이름에 오타가 있거나, 정의되지 않은 변수를 사용하려고 한 건 아닐까요? print 함수 안에 f-string을 사용할 때 문법 오류가 있을 수도 있으니 꼼꼼하게 확인해보세요."
            }
          }
        }
      ]
    },
    {
      "week": 3,
      "title": "흐름 제어: 조건과 반복으로 똑똑한 코드 만들기",
      "cycles": [
        {
          "title": "조건에 따른 분기 (if-elif-else)",
          "filename": "auth.py",
          "lecture": {
            "character": "profKim",
            "title": "강의 노트: if 조건문",
            "keyTakeaway": "`if`문은 조건의 참/거짓에 따라 프로그램의 실행 경로를 결정합니다.",
            "sandboxCode": "score = 85\n\nif score >= 90:\n    print(\"A 등급\")\nelif score >= 80:\n    print(\"B 등급\")\nelse:\n    print(\"C 등급\")",
            "sections": [
              {
                "heading": "핵심 개념",
                "text": "흐름 제어란 프로그램의 실행 순서를 제어하는 것을 말합니다[cite: 1386]. `if`문은 주어진 '조건(condition)'이 참(True)인지 거짓(False)인지에 따라 코드의 실행 흐름을 나누는 가장 기본적인 조건 분기문입니다 [cite: 1388-1389].",
                "code": null
              },
              {
                "heading": "기본 문법",
                "text": "조건문 뒤에는 콜론(:)을, 실행할 코드는 들여쓰기를 해야 합니다[cite: 1434, 1438, 1443].",
                "code": "if 조건1:\n    # 조건1이 참일 때 실행할 코드\nelif 조건2:\n    # 조건1은 거짓이고, 조건2가 참일 때 실행할 코드\nelse:\n    # 위의 모든 조건이 거짓일 때 실행할 코드"
              },
              {
                "heading": "활용 사례",
                "text": "사용자가 입력한 ID/PW가 올바른지 확인, 점수에 따른 합격/불합격/재시험 결정 등 프로그램이 특정 상황을 '판단'해야 하는 모든 곳에 사용됩니다.",
                "code": null
              },
              {
                "heading": "주의점 및 팁",
                "text": "조건문 뒤에는 반드시 콜론(:)을 붙여야 하며, 각 조건에 따라 실행될 코드 블록은 반드시 '들여쓰기(indentation)'를 해야 합니다[cite: 1443]. `=`는 값을 할당하는 것이고, `==`가 값이 같은지 비교하는 것이니 헷갈리지 않도록 주의하세요[cite: 1277].",
                "code": null
              }
            ]
          },
          "syntax_key": {
            "syntax_title": "if / elif / else",
            "syntax_comment": "조건에 따라 다른 코드를 실행하게 하는 조건문입니다.",
            "systax_code": "if score >= 80:\n    print(\"Pass\")\nelse:\n    print(\"Fail\")"
          },
          "task": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "사용자 역할별 접근 제어",
            "content": "보안 강화의 첫 단계입니다. `user_role` 변수의 값에 따라 다른 환영 메시지를 보여주는 기능을 구현해야 합니다. 역할이 <span class='font-bold text-yellow-300'>'admin'이면 '관리자님 환영합니다.'</span>를, <span class='font-bold text-yellow-300'>'editor'이면 '에디터님 안녕하세요.'</span>를, 그 외의 <span class='font-bold text-yellow-300'>모든 경우에는 '환영합니다.'</span>를 출력해주세요."
          },
          "briefing": {
            "character": "sena",
            "subtitle": "직속 선임의 OJT",
            "title": "갈림길 만들기: `if`",
            "content": "`if`문은 코드에 갈림길을 만들어줘요. '만약(if) 조건이 맞으면 여기로 가고, 아니고 만약(elif) 다른 조건이 맞으면 저기로, 그것도 아니면(else) 이리로 가!' 하는 식이죠. `starterCode`의 빈칸을 채워볼까요? 첫 `if` 옆 괄호 안에는 <span class='font-bold text-teal-300'>`user_role == 'admin'`</span>을, 다음 줄 빈칸에는 <span class='font-bold text-teal-300'>`print(\"관리자님 환영합니다.\")`</span>를 넣으세요. `elif`와 `else` 부분도 비슷하게 채우면 돼요! 조건 비교에는 <span class='font-bold text-teal-300'>`==` 기호</span>를, 각 줄 끝에는 <span class='font-bold text-teal-300'>콜론(`:`)</span>을, 실행할 코드는 <span class='font-bold text-teal-300'>들여쓰기</span>가 필요하다는 것도 기억하세요!"
          },
          "starterCode": "user_role = 'editor' # 이 값을 'admin', 'user' 등으로 바꿔 테스트해보세요.\n\n# TODO: 괄호 안에 user_role이 'admin'과 같은지(==) 비교하는 식을 넣으세요.\nif ( ):\n    # TODO: \"관리자님 환영합니다.\" 를 출력하는 print() 코드를 작성하세요.\n    \n# TODO: 괄호 안에 user_role이 'editor'와 같은지(==) 비교하는 식을 넣으세요.\nelif ( ):\n    # TODO: \"에디터님 안녕하세요.\" 를 출력하는 print() 코드를 작성하세요.\n    \n# TODO: 위 두 경우가 모두 아닐 때를 의미하는 else: 를 작성하세요.\n\n    # TODO: \"환영합니다.\" 를 출력하는 print() 코드를 작성하세요.\n    \n\nprint('Done') # 이 줄은 항상 실행됩니다.\n",
          "testCode": "import io; from contextlib import redirect_stdout; output_results = {}; roles_to_test = ['admin', 'editor', 'user']; base_code_lines = student_code.split('\\n'); for role in roles_to_test: f = io.StringIO(); code_to_run = f\"user_role = '{role}'\\n\" + '\\n'.join(line for line in base_code_lines if not line.strip().startswith('user_role =')); with redirect_stdout(f): exec(code_to_run); output_results[role] = f.getvalue().strip().split('\\n')[0]; assert output_results['admin'] == '관리자님 환영합니다.', 'admin 역할에 대한 출력이 올바르지 않습니다.'; assert output_results['editor'] == '에디터님 안녕하세요.', 'editor 역할에 대한 출력이 올바르지 않습니다.'; assert output_results['user'] == '환영합니다.', '기타 역할에 대한 출력이 올바르지 않습니다.'",
          "feedback": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "접근 제어 로직 구현 완료",
              "content": "<span class='font-bold text-green-300'>훌륭합니다.</span> 사용자 역할에 따라 정확히 다른 메시지가 출력되는군요. 이 `if`문은 앞으로 만들 거의 모든 기능의 기초가 될 겁니다. 잘 익혀두었어요."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "조건식이나 출력문을 확인해볼까요?",
              "content": "테스트 결과가 조금 다르네요. 각 `if`, `elif` 옆 괄호 안에 <span class='font-bold text-teal-300'>`user_role == '...'`</span> 비교식을 정확히 넣었나요? 따옴표나 `==` 기호를 빠뜨렸을 수도 있어요. 각 `print()` 함수 안의 메시지도 오타 없이 입력했는지 확인해주세요!"
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, 문법 오류!",
              "content": "코드를 실행하다가 오류가 발생했어요. `if`나 `elif`, `else` 뒤에 콜론(`:`)을 빠뜨리진 않았나요? 아니면 들여쓰기가 잘못되었을 수도 있어요. 파이썬은 들여쓰기에 아주 민감하거든요. 다시 한번 확인해주세요!"
            }
          },
          "task_adv": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "역할 기반 환영 메시지 함수 완성",
            "content": "사용자 역할(`role`)에 따라 다른 환영 메시지를 반환하는 `get_welcome_message` 함수가 있습니다. 함수 내부의 <span class='font-bold text-yellow-300'>`if-elif-else` 조건문을 완성</span>하여, <span class='font-bold text-yellow-300'>'admin', 'editor', 그 외 역할</span>에 맞는 적절한 메시지를 반환하도록 수정해주세요."
          },
          "briefing_adv": {
            "character": "sena",
            "subtitle": "직속 선임의 팁",
            "title": "조건에 따라 다른 값 반환하기",
            "content": "함수 안에서도 조건문은 똑같이 써요. <span class='font-bold text-teal-300'>`if role == 'admin':` 다음 줄에는 `return \"관리자님 환영합니다.\"`</span> 처럼 값을 반환하면 함수가 바로 종료되죠. `elif`와 `else` 블록에도 각각 맞는 메시지를 `return` 하도록 채워주면 완성될 거예요!"
          },
          "starterCode_adv": "# 아래 함수는 사용자 역할을 받아 적절한 환영 메시지를 반환합니다.\n# TODO: 함수 본문에서 if-elif-else 문을 완성하여 역할별 메시지를 반환하도록 수정하세요.\ndef get_welcome_message(role):\n    message = \"\"\n    if role == 'admin':\n        # 여기에 관리자 메시지를 반환하는 코드를 작성하세요.\n        return \"관리자님 환영합니다.\"\n    elif role == 'editor':\n        # 여기에 에디터 메시지를 반환하는 코드를 작성하세요.\n        return \"에디터님 안녕하세요.\"\n    else:\n        # 여기에 기본 메시지를 반환하는 코드를 작성하세요.\n        return \"환영합니다.\"\n    # return message # 이 줄은 더 이상 필요 없을 수 있습니다.\n\n# 함수 호출 및 결과 확인 (수정 불필요)\nprint(get_welcome_message('admin'))\nprint(get_welcome_message('editor'))\nprint(get_welcome_message('user'))\n",
          "testCode_adv": "assert callable(get_welcome_message), 'get_welcome_message 함수가 정의되지 않았습니다.'; assert get_welcome_message('admin') == '관리자님 환영합니다.', \"admin 역할에 대한 반환값이 올바르지 않습니다.\"; assert get_welcome_message('editor') == '에디터님 안녕하세요.', \"editor 역할에 대한 반환값이 올바르지 않습니다.\"; assert get_welcome_message('user') == '환영합니다.', \"기타 역할에 대한 반환값이 올바르지 않습니다.\"; assert get_welcome_message('guest') == '환영합니다.', \"정의되지 않은 역할에 대한 반환값이 올바르지 않습니다.\"",
          "feedback_adv": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "접근 제어 로직 구현 완료",
              "content": "<span class='font-bold text-green-300'>훌륭합니다.</span> 사용자 역할에 따라 정확히 다른 메시지가 출력되는군요. 이 `if`문은 앞으로 만들 거의 모든 기능의 기초가 될 겁니다. 잘 익혀두었어요."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "조건식이나 출력문을 확인해볼까요?",
              "content": "테스트 결과가 조금 다르네요. 각 `if`, `elif` 옆 괄호 안에 <span class='font-bold text-teal-300'>`user_role == '...'`</span> 비교식을 정확히 넣었나요? 따옴표나 `==` 기호를 빠뜨렸을 수도 있어요. 각 `print()` 함수 안의 메시지도 오타 없이 입력했는지 확인해주세요!"
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, 문법 오류!",
              "content": "코드를 실행하다가 오류가 발생했어요. `if`나 `elif`, `else` 뒤에 콜론(`:`)을 빠뜨리진 않았나요? 아니면 들여쓰기가 잘못되었을 수도 있어요. 파이썬은 들여쓰기에 아주 민감하거든요. 다시 한번 확인해주세요!"
            }
          }
        },
        {
          "title": "조건 기반 반복 (while)",
          "filename": "monitor.py",
          "lecture": {
            "character": "profKim",
            "title": "강의 노트: while 반복문",
            "keyTakeaway": "`while`문은 특정 조건이 참인 동안 코드를 계속 반복합니다.",
            "sandboxCode": "count = 5\nwhile count > 0:\n    print(f\"카운트 다운: {count}\")\n    count = count - 1 # 이 줄이 없으면 무한 루프에 빠져요!\nprint(\"발사!\")",
            "sections": [
              {
                "heading": "핵심 개념",
                "text": "`while`문은 주어진 '조건(condition)'이 참(True)인 '동안(while)' 코드 블록을 계속해서 반복 실행합니다[cite: 1453, 1456]. 조건이 거짓(False)이 되면 반복을 멈추고 다음 코드로 넘어갑니다.",
                "code": null
              },
              {
                "heading": "기본 문법",
                "text": "조건문 뒤에 콜론(:)을, 반복할 코드는 들여쓰기를 해야 합니다 [cite: 1491-1493].",
                "code": "while 조건:\n    # 조건이 참인 동안 반복해서 실행할 코드"
              },
              {
                "heading": "활용 사례",
                "text": "사용자가 올바른 값을 입력할 때까지 계속 재입력 받기, 게임에서 플레이어의 체력이 0보다 클 동안 계속 게임 진행하기, 특정 횟수만큼 반복하기 등 특정 조건 하에 반복이 필요할 때 사용됩니다.",
                "code": null
              },
              {
                "heading": "주의점 및 팁",
                "text": "가장 주의할 점은 '무한 루프'입니다. `while`문의 조건이 항상 참(True)으로 유지되면 프로그램이 멈추지 않고 영원히 반복합니다[cite: 1497]. 루프 내에서 조건을 변경하는 코드(예: `count = count + 1`)가 반드시 포함되어야 합니다.",
                "code": null
              }
            ]
          },
          "syntax_key": {
            "syntax_title": "while 반복문",
            "syntax_comment": "특정 조건이 참(True)인 동안 코드 블록을 계속해서 반복합니다.",
            "systax_code": "count = 5\nwhile count > 0:\n    count -= 1"
          },
          "task": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "서버 상태 모니터링 (반복)",
            "content": "서버 상태를 확인하는 작업을 <span class='font-bold text-yellow-300'>최대 3번</span>까지만 반복하고 싶습니다. `while` 문을 사용하여 <span class='font-bold text-yellow-300'>시도 횟수(`count`)가 최대 횟수(`max_checks`)보다 작은 동안</span> \"서버 상태 확인 중... (시도: [횟수])\" 메시지를 출력하고, 1초 대기하는 스크립트를 작성해주세요."
          },
          "briefing": {
            "character": "sena",
            "subtitle": "직속 선임의 팁",
            "title": "`while`로 조건 따라 반복하기",
            "content": "`while`문은 특정 조건이 맞는 '동안' 계속 반복해요[cite: 1456]. `starterCode`를 볼까요? `while` 뒤 빈칸에는 반복할 조건 <span class='font-bold text-teal-300'>`count < max_checks`</span>를 넣으세요. 루프 안 `print()` 빈칸에는 f-string <span class='font-bold text-teal-300'>`f\"서버 상태 확인 중... (시도: {count+1})\"`</span>를, `count = ` 오른쪽 빈칸에는 <span class='font-bold text-teal-300'>`count + 1`</span>을 넣어 `count` 값을 1씩 증가시켜야 해요. 이걸 안 하면 무한 반복에 빠질 수 있으니 주의!"
          },
          "starterCode": "import time\ncount = 0\nmax_checks = 3\n\n# TODO: ':' 옆 빈칸에 count가 max_checks보다 작은 동안(<) 반복하는 조건을 넣으세요.\nwhile :\n    # 루프 안에서는:\n    # TODO: print() 안에 f-string을 사용하여 \"서버 상태 확인 중... (시도: {count+1})\" 메시지를 만드세요.\n    print()\n    \n    # TODO: '=' 오른쪽에 count 변수의 값을 1 증가시키는 식을 작성하세요. (예: count + 1)\n    count = \n    \n    time.sleep(0.1) # 1초 대기 (테스트를 위해 짧게 줄임)\n\n\nprint(\"최대 확인 횟수에 도달했습니다.\")\n",
          "testCode": "import io, time; from contextlib import redirect_stdout; f = io.StringIO(); student_locals = {}; with redirect_stdout(f): time_sleep_orig = time.sleep; time.sleep = lambda x: None; exec(student_code, student_locals); time.sleep = time_sleep_orig; output = f.getvalue().strip().split('\\n'); expected_lines = ['서버 상태 확인 중... (시도: 1)', '서버 상태 확인 중... (시도: 2)', '서버 상태 확인 중... (시도: 3)', '최대 확인 횟수에 도달했습니다.']; assert output == expected_lines, f'출력 결과가 다릅니다.\\n기대값:\\n{chr(10).join(expected_lines)}\\n실제값:\\n{chr(10).join(output)}'; assert 'count' in student_locals and student_locals['count'] == 3, f'루프 종료 후 count 변수 값은 3이어야 합니다. 실제값: {student_locals.get(\"count\")}'",
          "feedback": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "반복 제어 성공",
              "content": "좋습니다. 정확히 원하는 횟수만큼 반복하고 멈추는군요. / 함수가 올바른 조건에서 멈추는 것을 확인했습니다. <span class='font-bold text-green-300'>`while`문을 이용한 반복 제어를 잘 이해하고 있습니다.</span>"
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "반복 조건이나 내부 코드를 확인해볼까요?",
              "content": "반복 결과나 출력이 조금 이상해요. `while` 뒤에 조건 <span class='font-bold text-teal-300'>`count < max_checks`</span>를 정확히 넣었나요? 루프 안에서 `print()`의 f-string 내용이나, `count = count + 1` 부분을 제대로 작성했는지 다시 확인해주세요. `count`를 증가시키는 코드가 없으면 무한 루프에 빠질 수 있어요!"
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, 무한 루프 또는 오류!",
              "content": "코드가 끝나지 않거나 오류가 발생했어요! `while` 루프 조건을 다시 확인해보세요. 조건이 항상 참이 되거나, 루프 내부에서 사용하는 변수 이름에 오타가 있을 수 있어요."
            }
          },
          "task_adv": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "상태 확인 함수 개선",
            "content": "특정 상태가 될 때까지 기다리는 `wait_until` 함수가 있습니다. 현재 `while` 루프의 조건이 잘못 설정되어 있습니다. <span class='font-bold text-yellow-300'>확인 횟수(`checks`)가 최대 횟수(`max_checks`) 미만이고, 현재 상태(`current_status`)가 목표 상태(`target_status`)와 다른 동안</span>에만 루프가 계속 실행되도록 `while` 문의 조건을 수정해주세요."
          },
          "briefing_adv": {
            "character": "sena",
            "subtitle": "직속 선임의 팁",
            "title": "두 가지 조건을 `while`에!",
            "content": "`while` 문에는 <span class='font-bold text-teal-300'>`and`</span> 키워드를 써서 여러 조건을 동시에 만족할 때만 반복하도록 만들 수 있어요 [cite: 1288-1291]. '횟수가 최대 횟수 미만' **그리고** '현재 상태가 목표 상태와 다름' 이 두 조건을 모두 만족하는 동안에만 반복하면 되겠죠? 각 조건은 비교 연산자 (`<`, `!=`)로 만들 수 있고요."
          },
          "starterCode_adv": "import time\n\n# 아래 함수는 특정 상태가 될 때까지 최대 횟수만큼 확인을 반복합니다.\n# TODO: 함수 본문에서 while 루프를 완성하세요.\n# 조건: checks < max_checks 이고, 현재 상태(current_status)가 target_status와 다른 동안\ndef wait_until(check_func, target_status, max_checks):\n    checks = 0\n    current_status = None # 초기 상태를 None 등으로 설정\n    while checks < max_checks and current_status != target_status: # 조건 수정 완료\n        current_status = check_func() # 가상의 상태 확인 함수 호출\n        print(f\"상태 확인({checks+1}/{max_checks}): {current_status}\")\n        if current_status == target_status:\n            print(\"목표 상태 도달!\")\n            return True\n        checks += 1\n        time.sleep(0.1) # 테스트 위해 짧게 설정\n    print(\"최대 확인 횟수 초과 또는 초기 상태 오류\") # 메시지 약간 수정\n    return False\n\n# --- 테스트용 가상 상태 확인 함수 --- (수정 불필요)\nstatus_list = ['booting', 'booting', 'running']\ncall_count = 0\ndef check_server_status():\n    global call_count\n    status = status_list[min(call_count, len(status_list) - 1)]\n    call_count += 1\n    return status\n# -------------------------------------\n\n# 함수 호출 (수정 불필요)\nwait_until(check_server_status, 'running', 5)\n",
          "testCode_adv": "import io, time; from contextlib import redirect_stdout; f = io.StringIO(); global_scope = {}; local_scope = {}; with redirect_stdout(f): time_sleep_orig = time.sleep; time.sleep = lambda x: None; global_scope['call_count'] = 0; # call_count 초기화\n    global_scope['status_list'] = ['booting', 'booting', 'running']; exec(student_code, global_scope, local_scope); time.sleep = time_sleep_orig; output = f.getvalue().strip().split('\\n'); expected_lines = ['상태 확인(1/5): booting', '상태 확인(2/5): booting', '상태 확인(3/5): running', '목표 상태 도달!']; assert output == expected_lines, f'출력 결과가 다릅니다.\\n기대값:\\n{chr(10).join(expected_lines)}\\n실제값:\\n{chr(10).join(output)}'",
          "feedback_adv": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "반복 제어 성공",
              "content": "좋습니다. 정확히 원하는 횟수만큼 반복하고 멈추는군요. / 함수가 올바른 조건에서 멈추는 것을 확인했습니다. <span class='font-bold text-green-300'>`while`문을 이용한 반복 제어를 잘 이해하고 있습니다.</span>"
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "반복 조건이나 내부 코드를 확인해볼까요?",
              "content": "반복 결과나 출력이 조금 이상해요. `while` 뒤에 조건 <span class='font-bold text-teal-300'>`count < max_checks`</span>를 정확히 넣었나요? 루프 안에서 `print()`의 f-string 내용이나, `count = count + 1` 부분을 제대로 작성했는지 다시 확인해주세요. `count`를 증가시키는 코드가 없으면 무한 루프에 빠질 수 있어요!"
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, 무한 루프 또는 오류!",
              "content": "코드가 끝나지 않거나 오류가 발생했어요! `while` 루프 조건을 다시 확인해보세요. 조건이 항상 참이 되거나, 루프 내부에서 사용하는 변수 이름에 오타가 있을 수 있어요."
            }
          }
        },
        {
          "title": "순회 반복 (for)",
          "filename": "broadcast.py",
          "lecture": {
            "character": "profKim",
            "title": "강의 노트: for 반복문",
            "keyTakeaway": "`for`문은 리스트와 같은 데이터 묶음의 모든 항목을 하나씩 순회하며 반복합니다.",
            "sandboxCode": "fruits = [\"사과\", \"바나나\", \"딸기\"]\nfor fruit in fruits:\n    print(f\"{fruit} 맛있어요!\")",
            "sections": [
              {
                "heading": "핵심 개념",
                "text": "`for`문은 리스트, 튜플, 문자열과 같은 '순회 가능한(iterable)' 데이터 구조의 각 항목(item)을 처음부터 끝까지 차례대로 하나씩 꺼내어 코드 블록을 반복 실행합니다 [cite: 1502-1503].",
                "code": null
              },
              {
                "heading": "기본 문법",
                "text": "`range()` 함수와 함께 사용하면 특정 횟수만큼 반복하는 코드를 쉽게 작성할 수 있습니다 [cite: 1516-1517].",
                "code": "# 리스트의 각 항목에 대해 반복\nfor 변수 in 리스트:\n    # 반복 실행할 코드\n\n# range() 함수와 함께 사용하기\nfor i in range(5): # 0부터 4까지 5번 반복\n    print(i)"
              },
              {
                "heading": "활용 사례",
                "text": "사용자 목록 전체에 이메일 보내기, 파일의 모든 줄을 한 줄씩 읽어서 처리하기, 특정 횟수만큼 작업 반복하기 등 정해진 범위나 목록을 순회할 때 사용됩니다.",
                "code": null
              },
              {
                "heading": "주의점 및 팁",
                "text": "`while`은 조건 기반, `for`는 순회 기반이라는 차이점을 이해하는 것이 중요합니다. `for`문과 함께 자주 사용되는 `range(n)` 함수는 0부터 n-1까지의 숫자를 만들어냅니다 [cite: 1533-1534].",
                "code": null
              }
            ]
          },
          "syntax_key": {
            "syntax_title": "for ... in ...",
            "syntax_comment": "리스트 같은 데이터 묶음의 각 항목을 순서대로 하나씩 꺼내 반복합니다.",
            "systax_code": "for item in my_list:"
          },
          "task": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "전체 서버 목록 확인",
            "content": "관리 중인 <span class='font-bold text-yellow-300'>서버 목록(`server_list`)</span>에 있는 모든 서버 이름을 화면에 하나씩 출력해야 합니다. <span class='font-bold text-yellow-300'>`for` 반복문</span>을 사용하여 리스트의 모든 항목을 순서대로 출력하는 스크립트를 작성해주세요."
          },
          "briefing": {
            "character": "sena",
            "subtitle": "직속 선임의 팁",
            "title": "목록 훑어보기: `for`",
            "content": "리스트 같은 목록의 항목을 하나씩 꺼내볼 땐 <span class='font-bold text-teal-300'>`for` 반복문</span>이 정말 편해요! `starterCode`를 볼까요? <span class='font-bold text-teal-300'>`for server_name in server_list:`</span> 처럼 빈칸을 채워보세요. `server_name`은 각 항목을 담을 임시 이름표고, `server_list`는 우리가 훑어볼 목록이죠. 루프 안 `print()` 빈칸에는 임시 이름표인 <span class='font-bold text-teal-300'>`server_name`</span>을 넣으면 각 서버 이름이 순서대로 출력될 거예요!"
          },
          "starterCode": "server_list = ['server-alpha', 'server-beta', 'server-gamma']\n\n# TODO: `for` 루프를 사용하여 server_list의 각 항목을 순회하며 출력하세요.\n#       `for ??? in ???:` 빈칸에 알맞은 변수 이름과 리스트 이름을 넣으세요.\nfor  in :\n    # TODO: `print()` 괄호 안에 루프에서 사용할 변수 이름을 넣으세요.\n    print()\n",
          "testCode": "import io; from contextlib import redirect_stdout; f = io.StringIO(); with redirect_stdout(f): exec(student_code); output = f.getvalue().strip().split('\\n'); expected = ['server-alpha', 'server-beta', 'server-gamma']; assert output == expected, f'출력 결과가 다릅니다.\\n기대값:\\n{chr(10).join(expected)}\\n실제값:\\n{chr(10).join(output)}'",
          "feedback": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "목록 처리 완료",
              "content": "완벽합니다. 리스트에 있는 모든 서버 이름이 정확히 출력되었네요. / 함수가 모든 서버 이름을 올바르게 출력했습니다. <span class='font-bold text-green-300'>`for`문을 이용한 순회 방법을 잘 이해했습니다.</span> 반복적인 작업을 효율적으로 처리하는 중요한 기술입니다."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "for문 구문이나 변수 이름을 확인해볼까요?",
              "content": "출력 결과가 조금 다르네요. <span class='font-bold text-teal-300'>`for server_name in server_list:`</span> 처럼 `for`, `in`, `:`을 정확히 사용했나요? 루프 안에서 `print()` 괄호 안에 <span class='font-bold text-teal-300'>`server_name`</span> 변수 이름을 올바르게 넣었는지도 확인해주세요!"
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, for문 문법 오류!",
              "content": "코드를 실행하다가 오류가 발생했어요. `for ... in ...:` 구문은 정확하게 작성하셨나요? `in`을 빠뜨리거나, 맨 끝에 콜론(`:`)을 잊어버리는 실수를 자주 하곤 해요. 들여쓰기도 다시 한번 확인해보세요!"
            }
          },
          "task_adv": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "알림 발송 함수 완성",
            "content": "서버 목록을 받아 알림을 보내는 `send_notifications` 함수가 있습니다. 함수 내부의 <span class='font-bold text-yellow-300'>`for` 루프 부분을 완성</span>하여, 입력받은 `servers` 리스트의 <span class='font-bold text-yellow-300'>각 서버 이름을 순서대로 출력</span>하도록 수정해주세요."
          },
          "briefing_adv": {
            "character": "sena",
            "subtitle": "직속 선임의 팁",
            "title": "함수 안에서도 `for`문!",
            "content": "함수 안에서도 <span class='font-bold text-teal-300'>`for` 반복문</span>을 똑같이 쓸 수 있어요! 함수가 매개변수로 받은 `servers` 리스트를 `for server_name in servers:` 처럼 순회하면서, 루프 안에서 `server_name` 변수를 출력해주면 각 서버 이름이 순서대로 나올 거예요."
          },
          "starterCode_adv": "# 아래 함수는 서버 목록을 받아 각 서버에 알림 메시지를 보내는 시뮬레이션입니다.\n# TODO: 함수 본문에서 for 루프를 완성하여 목록의 각 서버 이름을 출력하도록 수정하세요.\ndef send_notifications(servers):\n    print(\"알림 발송 시작...\")\n    # 여기에 for 루프를 작성하여 servers 리스트의 각 항목(server_name)을 순회하며 출력하세요.\n    for server_name in servers:\n        print(server_name)\n    print(\"...알림 발송 완료\")\n\n# 함수 호출 (수정 불필요)\nserver_list = ['server-alpha', 'server-beta', 'server-gamma']\nsend_notifications(server_list)\n",
          "testCode_adv": "import io; from contextlib import redirect_stdout; assert callable(send_notifications), 'send_notifications 함수가 정의되지 않았습니다.'; f = io.StringIO(); server_list = ['server-alpha', 'server-beta', 'server-gamma']; with redirect_stdout(f): send_notifications(server_list); output = f.getvalue().strip().split('\\n'); expected = ['알림 발송 시작...', 'server-alpha', 'server-beta', 'server-gamma', '...알림 발송 완료']; assert output == expected, f'출력 결과가 다릅니다.\\n기대값:\\n{chr(10).join(expected)}\\n실제값:\\n{chr(10).join(output)}'",
          "feedback_adv": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "목록 처리 완료",
              "content": "완벽합니다. 리스트에 있는 모든 서버 이름이 정확히 출력되었네요. / 함수가 모든 서버 이름을 올바르게 출력했습니다. <span class='font-bold text-green-300'>`for`문을 이용한 순회 방법을 잘 이해했습니다.</span> 반복적인 작업을 효율적으로 처리하는 중요한 기술입니다."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "for문 구문이나 변수 이름을 확인해볼까요?",
              "content": "출력 결과가 조금 다르네요. <span class='font-bold text-teal-300'>`for server_name in server_list:`</span> 처럼 `for`, `in`, `:`을 정확히 사용했나요? 루프 안에서 `print()` 괄호 안에 <span class='font-bold text-teal-300'>`server_name`</span> 변수 이름을 올바르게 넣었는지도 확인해주세요!"
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, for문 문법 오류!",
              "content": "코드를 실행하다가 오류가 발생했어요. `for ... in ...:` 구문은 정확하게 작성하셨나요? `in`을 빠뜨리거나, 맨 끝에 콜론(`:`)을 잊어버리는 실수를 자주 하곤 해요. 들여쓰기도 다시 한번 확인해보세요!"
            }
          }
        }
      ]
    },
    {
      "week": 4,
      "title": "코드 재사용의 시작: 함수 정의와 활용",
      "cycles": [
        {
          "title": "함수의 정의와 호출 (def)",
          "filename": "utils.py",
          "lecture": {
            "character": "profKim",
            "title": "강의 노트: 함수 (Function)",
            "keyTakeaway": "함수는 `def`로 정의하고, 이름()으로 호출하는 재사용 가능한 코드 블록입니다.",
            "sandboxCode": "def show_my_name():\n    name = \"김신입\"\n    print(f\"제 이름은 {name}입니다.\")\n\n# 아래에 함수를 호출해서 이름을 출력해보세요.\nshow_my_name()",
            "sections": [
              {
                "heading": "핵심 개념",
                "text": "함수(Function)는 특정 작업을 수행하는 코드 덩어리에 이름을 붙인 것입니다[cite: 1614]. 프로그램을 논리적인 단위로 나눌 수 있게 해주며, 코드의 재사용성을 극대화합니다[cite: 1614]. 잘 정의된 함수는 '무엇을 하는지'는 알려주지만 '어떻게 하는지'는 숨겨주는 '추상화'의 첫걸음입니다.",
                "code": null
              },
              {
                "heading": "기본 문법",
                "text": "함수를 정의하는 것을 '선언'이라 하고, 사용하는 것을 '호출'이라고 합니다 [cite: 1618-1620, 1626].",
                "code": "# 함수 정의하기(선언)\ndef 함수이름():\n    # 이 블록 안에 재사용할 코드를 작성\n    print(\"Hello Function!\")\n\n# 함수 호출하기(사용)\n함수이름()"
              },
              {
                "heading": "활용 사례",
                "text": "프로그램의 시작 부분에 환영 메시지 출력하기, 복잡한 계산 수행하기, 파일 내용 읽어오기 등 반복적으로 사용될 가능성이 있는 모든 코드 묶음에 활용됩니다.",
                "code": null
              },
              {
                "heading": "주의점 및 팁",
                "text": "함수 이름은 소문자와 밑줄(_)을 사용하여 만드는 것이 일반적입니다(예: `send_email`). 함수를 정의(`def`)만 하고 호출하지 않으면 코드는 실행되지 않습니다[cite: 1626]. 반드시 이름으로 호출해야 합니다.",
                "code": null
              }
            ]
          },
          "syntax_key": {
            "syntax_title": "print()",
            "syntax_comment": "`print()`는 괄호 안의 값을 화면에 출력하는 내장 함수입니다.",
            "systax_code": "print(\"Hello World\")"
          },
          "task": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "반복 작업 개선하기",
            "content": "여러 곳에서 사용될 환영 메시지를 매번 복사 붙여넣기 하는 대신, <span class='font-bold text-yellow-300'>재사용 가능한 코드 덩어리</span>로 만들려고 합니다. \"Welcome to LogiCore Tech!\"를 출력하는 <span class='font-bold text-yellow-300'>`show_welcome_message` 함수를 정의하고, 이 함수를 호출</span>해주세요."
          },
          "briefing": {
            "character": "sena",
            "subtitle": "직속 선임의 OJT",
            "title": "나만의 명령어 만들기: 함수",
            "content": "함수는 자주 쓰는 코드 묶음에 이름을 붙여 재사용하는 거예요[cite: 1614]. `starterCode`를 볼까요? <span class='font-bold text-teal-300'>`def`</span>는 함수를 정의하겠다는 뜻이에요. 첫 빈칸에 함수 이름 <span class='font-bold text-teal-300'>`show_welcome_message`</span>를 넣으세요. 다음 빈칸에는 1주차에서 배운 <span class='font-bold text-teal-300'>`print(\"Welcome to LogiCore Tech!\")`</span> 코드를 넣으면 돼요. 마지막 빈칸에는 이 함수를 실행하라는 명령어 <span class='font-bold text-teal-300'>`show_welcome_message()`</span>를 넣으면 끝! 함수 이름 뒤에 괄호`()`를 붙여 호출하는 거죠[cite: 1618, 1626]."
          },
          "starterCode": "# TODO: 1. 아래 빈칸에 함수 이름 'show_welcome_message'를 넣으세요.\ndef (): # 괄호 안은 비워두세요.\n    # TODO: 2. 아래 빈칸에 \"Welcome to LogiCore Tech!\" 를 출력하는 print() 코드를 작성하세요.\n    \n\n# TODO: 3. 아래 빈칸에 위에서 정의한 함수를 호출하는 코드를 작성하세요.\n# 형식: 함수이름()\n\n",
          "testCode": "import io; from contextlib import redirect_stdout; student_globals = {}; f = io.StringIO(); with redirect_stdout(f): exec(student_code, student_globals); output = f.getvalue().strip(); expected = 'Welcome to LogiCore Tech!'; assert 'show_welcome_message' in student_globals and callable(student_globals['show_welcome_message']), \"'show_welcome_message' 함수가 정의되지 않았습니다.\"; assert output == expected, f\"함수 호출 시 출력된 메시지가 요청과 다릅니다. 기대값: '{expected}', 실제 출력값: '{output}'\"",
          "feedback": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "함수 정의 및 호출 완료",
              "content": "좋습니다. <span class='font-bold text-green-300'>함수를 올바르게 정의하고 호출</span>하여 원하는 메시지를 출력했군요. / <span class='font-bold text-green-300'>함수 이름과 내용을 성공적으로 변경</span>했습니다. 이렇게 코드를 재사용하고 수정하는 것이 유지보수의 기본입니다."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "함수 이름이나 호출 부분을 확인해볼까요?",
              "content": "함수가 제대로 정의되지 않았거나 호출되지 않은 것 같아요. 함수 이름(`show_welcome_message`)에 오타는 없는지, 함수 정의 시 `def`와 `:` 사이에 이름과 `()`를 넣었는지 확인해보세요. 마지막 호출 부분에도 함수 이름 뒤에 괄호 `()`를 붙였는지 확인해주세요!"
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, 함수 정의 또는 호출 오류!",
              "content": "함수를 정의하거나 호출하는 부분에서 오류가 발생했어요. 함수를 정의할 때 `def 함수이름():` 형식을 정확하게 지키셨나요? 이름 뒤에 콜론(`:`)이나 들여쓰기를 확인해보세요. 호출할 때는 이름 뒤에 괄호`()`를 붙였는지도요!"
            }
          },
          "task_adv": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "함수 이름 및 내용 변경 (리팩토링)",
            "content": "기존에 작성된 `print_message` 함수의 이름과 기능을 변경해야 합니다. 함수 이름을 <span class='font-bold text-yellow-300'>`display_status`로 변경</span>하고, 함수 내부에서는 <span class='font-bold text-yellow-300'>\"Server is running.\"</span> 메시지를 출력하도록 수정해주세요. 마지막으로, <span class='font-bold text-yellow-300'>변경된 이름으로 함수를 호출</span>해야 합니다."
          },
          "briefing_adv": {
            "character": "sena",
            "subtitle": "직속 선임의 팁",
            "title": "코드 수정하기",
            "content": "기존 코드를 고치는 작업이네요! <span class='font-bold text-teal-300'>함수 정의 부분(`def ... :`)의 이름</span>을 바꾸고, <span class='font-bold text-teal-300'>함수 내부의 `print()` 문 안의 문자열</span>을 수정하면 돼요. 아참, 함수 이름이 바뀌었으니 <span class='font-bold text-teal-300'>함수를 호출하는 부분의 이름</span>도 똑같이 바꿔주는 걸 잊지 마세요!"
          },
          "starterCode_adv": "# 아래 코드는 특정 메시지를 출력하는 함수를 정의하고 호출하는 예시입니다.\n# TODO: 함수 이름을 'display_status'로 변경하고, 출력 메시지를 \"Server is running.\"으로 변경하세요.\n\ndef print_message(): # 함수 이름 변경 필요\n    print(\"Initial message.\") # 출력 내용 변경 필요\n\n# TODO: 변경된 이름의 함수를 호출하세요.\nprint_message() # 함수 호출 이름 변경 필요\n",
          "testCode_adv": "import io; from contextlib import redirect_stdout; student_globals = {}; f = io.StringIO(); with redirect_stdout(f): exec(student_code, student_globals); output = f.getvalue().strip(); expected = 'Server is running.'; assert 'display_status' in student_globals and callable(student_globals['display_status']), \"'display_status' 함수가 정의되지 않았거나 이름이 잘못되었습니다.\"; assert output == expected, f\"변경된 함수 호출 시 출력된 메시지가 요청과 다릅니다. 기대값: '{expected}', 실제 출력값: '{output}'\"; assert 'print_message' not in student_globals, '기존 함수 이름(print_message)은 더 이상 사용되지 않아야 합니다.'",
          "feedback_adv": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "함수 정의 및 호출 완료",
              "content": "좋습니다. <span class='font-bold text-green-300'>함수를 올바르게 정의하고 호출</span>하여 원하는 메시지를 출력했군요. / <span class='font-bold text-green-300'>함수 이름과 내용을 성공적으로 변경</span>했습니다. 이렇게 코드를 재사용하고 수정하는 것이 유지보수의 기본입니다."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "함수 이름이나 호출 부분을 확인해볼까요?",
              "content": "함수가 제대로 정의되지 않았거나 호출되지 않은 것 같아요. 함수 이름(`show_welcome_message`)에 오타는 없는지, 함수 정의 시 `def`와 `:` 사이에 이름과 `()`를 넣었는지 확인해보세요. 마지막 호출 부분에도 함수 이름 뒤에 괄호 `()`를 붙였는지 확인해주세요!"
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, 함수 정의 또는 호출 오류!",
              "content": "함수를 정의하거나 호출하는 부분에서 오류가 발생했어요. 함수를 정의할 때 `def 함수이름():` 형식을 정확하게 지키셨나요? 이름 뒤에 콜론(`:`)이나 들여쓰기를 확인해보세요. 호출할 때는 이름 뒤에 괄호`()`를 붙였는지도요!"
            }
          }
        },
        {
          "title": "값의 전달과 반환 (매개변수와 return)",
          "filename": "hr_system.py",
          "lecture": {
            "character": "profKim",
            "title": "강의 노트: 매개변수와 Return",
            "keyTakeaway": "매개변수로 데이터를 받고, `return`으로 결과를 돌려주어 함수를 유연하게 활용할 수 있습니다.",
            "sandboxCode": "def get_greeting(name):\n    return f\"{name}님, 안녕하세요!\"\n\nmessage = get_greeting(\"김선임\")\nprint(message)",
            "sections": [
              {
                "heading": "핵심 개념",
                "text": "매개변수(Parameter)는 함수가 작업을 수행하는 데 필요한 외부 데이터를 받아들이는 '입력' 통로입니다 [cite: 1630-1631]. `return`문은 함수의 작업 결과를 호출한 곳으로 되돌려주는 '출력' 통로입니다 [cite: 1776-1777].",
                "code": null
              },
              {
                "heading": "기본 문법",
                "text": "함수 정의 시 소괄호 안에 매개변수 이름을, 함수 코드 블록 안에 `return`을 사용합니다.",
                "code": "# 매개변수가 있는 함수 정의\ndef add(a, b):\n    result = a + b\n    return result\n\n# 함수 호출 및 결과 저장\nsum_value = add(10, 5)\nprint(sum_value) # 15 출력"
              },
              {
                "heading": "활용 사례",
                "text": "사용자 이름을 받아 환영 메시지를 꾸미거나, 두 숫자를 받아 계산 결과를 얻는 등 함수의 동작을 외부 값에 따라 유연하게 바꾸고 싶을 때 사용됩니다.",
                "code": null
              },
              {
                "heading": "주의점 및 팁",
                "text": "함수를 호출할 때 넘겨주는 값(인자, argument)의 순서는 매개변수의 순서와 일치해야 합니다. `return`문이 실행되면 함수는 즉시 종료됩니다. `return` 아래에 있는 코드는 실행되지 않습니다.",
                "code": null
              }
            ]
          },
          "syntax_key": {
            "syntax_title": "print()",
            "syntax_comment": "`print()`는 괄호 안의 값을 화면에 출력하는 내장 함수입니다.",
            "systax_code": "print(\"Hello World\")"
          },
          "task": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "함수 동적으로 만들기",
            "content": "함수에 값을 전달하고 결과를 받는 방법을 익혀봅시다. <span class='font-bold text-yellow-300'>사용자 이름(username)을 받아</span> 개인화된 환영 메시지를 반환하는 `get_personalized_greeting` 함수와, <span class='font-bold text-yellow-300'>성과 점수(score)를 받아</span> 보너스를 계산하여 반환하는 `calculate_bonus` 함수를 각각 정의해주세요."
          },
          "briefing": {
            "character": "sena",
            "subtitle": "직속 선임의 팁",
            "title": "함수의 입구(매개변수)와 출구(return)",
            "content": "함수에 데이터를 넣는 입구가 <span class='font-bold text-teal-300'>매개변수</span>이고, 결과를 내보내는 출구가 <span class='font-bold text-teal-300'>`return`</span>이에요 [cite: 1630, 1776-1777]. `starterCode`를 봅시다. 첫 번째 함수 괄호 안 빈칸에 <span class='font-bold text-teal-300'>`username`</span>을 넣고, `return` 뒤에는 f-string <span class='font-bold text-teal-300'>`f\"Welcome, {username}!\"`</span>를 넣으세요. 두 번째 함수 괄호 안에는 <span class='font-bold text-teal-300'>`score`</span>를, `return` 뒤에는 계산식 <span class='font-bold text-teal-300'>`score * 0.1`</span>을 넣으면 완성!"
          },
          "starterCode": "# TODO: 1. 아래 함수 정의 괄호 안에 'username' 매개변수 이름을 넣으세요.\ndef get_personalized_greeting():\n    # TODO: 2. 아래 return 뒤 빈칸에 f-string을 사용하여 \"Welcome, {username}!\" 형식의 문자열을 만드세요.\n    return \n\n# TODO: 3. 아래 함수 정의 괄호 안에 'score' 매개변수 이름을 넣으세요.\ndef calculate_bonus():\n    # TODO: 4. 아래 return 뒤 빈칸에 score의 10%를 계산하는 식을 작성하세요. (score * 0.1)\n    return \n\n# 아래는 테스트용 코드입니다. 수정하지 마세요.\nprint(get_personalized_greeting(\"Alex\"))\nprint(calculate_bonus(1000))\n",
          "testCode": "assert callable(get_personalized_greeting), 'get_personalized_greeting 함수가 정의되지 않았습니다.'; result_greeting = get_personalized_greeting('Alex'); assert result_greeting == 'Welcome, Alex!', f\"get_personalized_greeting 반환값이 올바르지 않습니다. 기대값: 'Welcome, Alex!', 실제값: '{result_greeting}'\"; assert callable(calculate_bonus), 'calculate_bonus 함수가 정의되지 않았습니다.'; result_bonus_1000 = calculate_bonus(1000); assert result_bonus_1000 == 100, f\"calculate_bonus(1000)의 반환값이 100이어야 합니다. 실제값: {result_bonus_1000}\"; result_bonus_500 = calculate_bonus(500); assert result_bonus_500 == 50, f\"calculate_bonus(500)의 반환값이 50이어야 합니다. 실제값: {result_bonus_500}\"",
          "feedback": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "훌륭한 함수 설계",
              "content": "완벽합니다. 함수가 <span class='font-bold text-green-300'>입력값을 받아 처리하고 정확한 결과를 반환</span>하는군요. / 함수가 <span class='font-bold text-green-300'>기본값과 입력값을 잘 처리하여 정확한 급여를 계산</span>했습니다. 함수 설계의 핵심을 잘 이해했습니다."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "매개변수나 return 값을 확인해볼까요?",
              "content": "함수가 반환한 값이 예상과 조금 다르네요. 함수 정의 괄호 안에 매개변수 이름(`username`, `score`)을 정확히 넣었나요? `return` 뒤에 f-string이나 계산식을 올바르게 작성했는지도 확인해주세요!"
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, 매개변수 또는 반환 오류!",
              "content": "함수를 정의하거나 호출하는 부분에서 오류가 발생했어요. 함수를 정의할 때 `def 함수이름(매개변수):` 형식으로 괄호 안에 매개변수 이름을 잘 넣어주셨나요? 혹은 함수 안에서 `return` 키워드를 빠뜨리거나 잘못 사용한 건 아닐까요?"
            }
          },
          "task_adv": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "급여 계산 함수 완성",
            "content": "사용자 정보와 보너스 비율을 받아 최종 급여를 계산하는 `calculate_final_salary` 함수를 완성해야 합니다. 먼저, <span class='font-bold text-yellow-300'>`bonus_rate` 매개변수에 기본값 10%(0.1)</span>를 설정해주세요. 그리고 함수 내부에서 <span class='font-bold text-yellow-300'>사용자의 'score'를 이용하여 보너스를 계산</span>하고, 기본 급여에 더하여 최종 급여를 반환하도록 로직을 완성하세요."
          },
          "briefing_adv": {
            "character": "sena",
            "subtitle": "직속 선임의 팁",
            "title": "기본값과 딕셔너리 활용",
            "content": "함수를 정의할 때 <span class='font-bold text-teal-300'>`매개변수=기본값` 형태로 쓰면 기본 인수값</span>을 줄 수 있어요 [cite: 1707-1709]. 호출할 때 값을 안 넘기면 이 기본값이 사용되죠. 그리고 함수 안에서는 매개변수로 받은 <span class='font-bold text-teal-300'>딕셔너리(`user_info`)에서 필요한 값(`['score']`)을 꺼내서</span> 계산에 활용하고, 최종 결과를 <span class='font-bold text-teal-300'>`return`</span>으로 돌려주면 됩니다!"
          },
          "starterCode_adv": "# 아래 함수는 사용자 정보(딕셔너리)와 보너스 비율을 받아 최종 급여를 계산합니다.\n# TODO: 1. 함수 정의 시 'bonus_rate' 매개변수의 기본값을 0.1 (10%)로 설정하세요.\n# TODO: 2. 함수 본문에서 user_info 딕셔너리의 'score' 값을 사용하여 보너스를 계산하고,\n#       기본 급여(1000으로 가정)에 보너스를 더한 최종 급여를 반환하세요.\ndef calculate_final_salary(user_info, bonus_rate=0.1):\n    base_salary = 1000\n    # 여기에 보너스 계산 및 최종 급여 계산 로직을 작성하세요.\n    score = user_info.get('score', 0) # score 키가 없을 경우 0 사용\n    bonus = score * bonus_rate\n    final_salary = base_salary + bonus\n    return final_salary\n\n# 함수 호출 및 결과 확인 (수정 불필요)\nuser = {'name': 'Sena', 'score': 1200}\nsalary1 = calculate_final_salary(user)\nsalary2 = calculate_final_salary(user, 0.15)\nprint(f\"{user['name']}님의 기본 급여(보너스 10%): {salary1}\")\nprint(f\"{user['name']}님의 특별 급여(보너스 15%): {salary2}\")\n",
          "testCode_adv": "import inspect; sig = inspect.signature(calculate_final_salary); assert 'bonus_rate' in sig.parameters and sig.parameters['bonus_rate'].default == 0.1, 'bonus_rate 매개변수의 기본값이 0.1로 설정되어야 합니다.'; user1 = {'name': 'Sena', 'score': 1200}; salary1 = calculate_final_salary(user1); assert salary1 == 1120, f'기본 보너스율(10%) 적용 시 급여 계산이 올바르지 않습니다. 기대값: 1120, 실제값: {salary1}'; salary2 = calculate_final_salary(user1, 0.15); assert salary2 == 1180, f'지정된 보너스율(15%) 적용 시 급여 계산이 올바르지 않습니다. 기대값: 1180, 실제값: {salary2}'",
          "feedback_adv": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "훌륭한 함수 설계",
              "content": "완벽합니다. 함수가 <span class='font-bold text-green-300'>입력값을 받아 처리하고 정확한 결과를 반환</span>하는군요. / 함수가 <span class='font-bold text-green-300'>기본값과 입력값을 잘 처리하여 정확한 급여를 계산</span>했습니다. 함수 설계의 핵심을 잘 이해했습니다."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "매개변수나 return 값을 확인해볼까요?",
              "content": "함수가 반환한 값이 예상과 조금 다르네요. 함수 정의 괄호 안에 매개변수 이름(`username`, `score`)을 정확히 넣었나요? `return` 뒤에 f-string이나 계산식을 올바르게 작성했는지도 확인해주세요!"
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, 매개변수 또는 반환 오류!",
              "content": "함수를 정의하거나 호출하는 부분에서 오류가 발생했어요. 함수를 정의할 때 `def 함수이름(매개변수):` 형식으로 괄호 안에 매개변수 이름을 잘 넣어주셨나요? 혹은 함수 안에서 `return` 키워드를 빠뜨리거나 잘못 사용한 건 아닐까요?"
            }
          }
        },
        {
          "title": "변수의 유효 범위 (Scope)",
          "filename": "task_manager.py",
          "lecture": {
            "character": "profKim",
            "title": "강의 노트: 변수의 범위 (Scope)",
            "keyTakeaway": "함수 안에서 바깥의 전역 변수 값을 바꾸려면 `global` 키워드가 필요합니다.",
            "sandboxCode": "message = \"바깥 메시지\"\n\ndef change_message():\n    # 이 함수 안에서 message 변수의 값을\n    # \"안쪽 메시지\"로 바꿔보세요.\n    global message\n    message = \"안쪽 메시지\"\n\nchange_message()\nprint(message)",
            "sections": [
              {
                "heading": "핵심 개념",
                "text": "변수가 유효한 범위를 스코프(Scope)라고 합니다. 함수 안에서 만들어진 변수는 '지역 변수(Local Variable)'라 하며, 함수 안에서만 사용할 수 있고 함수가 끝나면 사라집니다 [cite: 1660-1662]. 함수 바깥 최상단에서 만들어진 변수는 '전역 변수(Global Variable)'라 하며, 프로그램 어디서든 접근할 수 있습니다[cite: 1676].",
                "code": null
              },
              {
                "heading": "기본 문법",
                "text": "함수 안에서 전역 변수의 값을 '변경'하려면 `global` 키워드를 사용해야 합니다 [cite: 1681, 1684-1685].",
                "code": "count = 0 # 전역 변수\n\ndef increment():\n    global count # 전역 변수 count를 수정하겠다고 선언\n    count = count + 1"
              },
              {
                "heading": "활용 사례",
                "text": "프로그램의 전체 설정값이나 상태를 저장하는 전역 변수를 여러 함수에서 읽거나, 값을 변경해야 할 때 사용됩니다.",
                "code": null
              },
              {
                "heading": "주의점 및 팁",
                "text": "전역 변수를 너무 많이 사용하면 코드의 흐름을 파악하기 어려워집니다. 함수 안에서 전역 변수를 '읽는 것'은 `global` 선언 없이도 가능하지만, '값을 변경(할당)'하려면 반드시 `global` 선언이 필요합니다[cite: 1685, 1686].",
                "code": null
              }
            ]
          },
          "syntax_key": {
            "syntax_title": "변수 (Variable)",
            "syntax_comment": "데이터를 저장하기 위해 이름표를 붙인 공간입니다. `=` 기호로 값을 할당합니다.",
            "systax_code": "my_variable = 100"
          },
          "task": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "전역 상태 관리",
            "content": "우리 애플리케이션 전체에서 공유되는 <span class='font-bold text-yellow-300'>'총 작업 횟수(total_task_count)' 변수</span>가 있습니다. 사용자가 특정 작업을 완료할 때마다 호출되는 함수 `complete_task()`를 만들고, 이 함수 안에서 <span class='font-bold text-yellow-300'>바깥에 있는 `total_task_count`의 값을 1 증가</span>시키도록 구현해주세요."
          },
          "briefing": {
            "character": "sena",
            "subtitle": "직속 선임의 팁",
            "title": "함수 안에서 바깥 변수 바꾸기: `global`",
            "content": "함수 안에서 바깥 세상(전역)에 있는 변수를 바꾸려면 특별한 선언이 필요해요. `starterCode`의 첫 번째 빈칸에 <span class='font-bold text-teal-300'>`global total_task_count`</span> 라고 입력해서 '이 변수는 바깥 거예요!'라고 알려줘야 해요[cite: 1681, 1684]. 그 다음 빈칸에는 <span class='font-bold text-teal-300'>`total_task_count + 1`</span>을 넣어 값을 1 증가시키면 됩니다. `global` 선언을 잊으면 함수 안에서만 값이 바뀌고 바깥 변수는 그대로 남아있게 돼요!"
          },
          "starterCode": "total_task_count = 0 # 전역 변수\n\ndef complete_task():\n    # TODO: 1. 아래 빈칸에 'global' 키워드와 전역 변수 이름 'total_task_count'를 넣으세요.\n     total_task_count\n    \n    # TODO: 2. '=' 오른쪽에 total_task_count 변수의 값을 1 증가시키는 식을 작성하세요.\n    total_task_count = \n\n# 아래는 테스트용 코드입니다. 수정하지 마세요.\nprint(f\"호출 전: {total_task_count}\")\ncomplete_task()\nprint(f\"1회 호출 후: {total_task_count}\")\ncomplete_task()\nprint(f\"2회 호출 후: {total_task_count}\")\n",
          "testCode": "student_globals = {'total_task_count': 0}; exec(student_code, student_globals); complete_task_func = student_globals.get('complete_task'); assert callable(complete_task_func), \"complete_task 함수가 정의되지 않았습니다.\"; complete_task_func(); assert student_globals['total_task_count'] == 1, 'complete_task() 1회 호출 후 total_task_count는 1이어야 합니다.'; complete_task_func(); complete_task_func(); assert student_globals['total_task_count'] == 3, 'complete_task() 3회 호출 후 total_task_count는 3이어야 합니다.'",
          "feedback": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "변수 범위 마스터",
              "content": "<span class='font-bold text-green-300'>전역 카운터가 정상적으로 증가하는 것을 확인했습니다.</span> / <span class='font-bold text-green-300'>클래스 변수가 올바르게 증가하는 것을 확인했습니다.</span> 변수의 유효 범위를 이해하는 것은 복잡한 프로그램을 만들 때 매우 중요합니다. 핵심 개념을 잘 습득했네요. 수고했습니다."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "global 선언을 확인해보세요!",
              "content": "함수를 호출했는데도 바깥의 `total_task_count` 값이 바뀌지 않았어요. 함수 안 첫 줄에 <span class='font-bold text-teal-300'>`global total_task_count`</span> 라고 정확히 선언했는지 확인해주세요. 이 선언이 없으면 함수 안에서 값을 바꿔도 바깥 변수에는 영향을 주지 않아요."
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, UnboundLocalError 또는 NameError!",
              "content": "오류 메시지에 `UnboundLocalError` 또는 `NameError`가 나오네요. 함수 안에서 바깥 범위의 변수를 수정하려고 할 때 필요한 `global` 선언을 빠뜨리면 이런 오류가 자주 발생해요 [cite: 1684-1685]. 코드를 다시 확인해주세요!"
            }
          },
          "task_adv": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "클래스 기반 카운터 완성",
            "content": "완료된 작업 수를 관리하는 `TaskCounter` 클래스가 있습니다. `complete_task` 메소드가 호출될 때마다, 모든 작업 객체들이 공유하는 <span class='font-bold text-yellow-300'>클래스 변수 `total_completed_tasks`의 값을 1 증가</span>시키도록 메소드 내부 로직을 완성해주세요."
          },
          "briefing_adv": {
            "character": "sena",
            "subtitle": "직속 선임의 팁",
            "title": "클래스 변수 사용하기",
            "content": "클래스 변수는 그 클래스로 만든 모든 객체가 공유하는 값이에요 [cite: 2548-2549]. 메소드 안에서 이 클래스 변수에 접근하려면 <span class='font-bold text-teal-300'>`클래스이름.변수이름`</span> 형태로 접근해야 해요[cite: 2562]. 여기서는 `TaskCounter.total_completed_tasks`가 되겠죠? 이 값을 1 증가시키면 됩니다! (`+= 1` 연산자를 써도 좋아요.)"
          },
          "starterCode_adv": "# 아래 코드는 완료된 작업 수를 관리하는 카운터 클래스입니다.\n# TODO: complete_task 메소드 내에서 클래스 변수 total_completed_tasks의 값을 1 증가시키세요.\nclass TaskCounter:\n    total_completed_tasks = 0 # 클래스 변수\n\n    def __init__(self, task_name):\n        self.task_name = task_name\n\n    def complete_task(self):\n        print(f\"작업 '{self.task_name}' 완료!\")\n        # 여기에 클래스 변수를 증가시키는 코드를 작성하세요.\n        TaskCounter.total_completed_tasks += 1\n\n# 카운터 사용 예시 (수정 불필요)\nprint(f\"시작 전 총 완료 작업 수: {TaskCounter.total_completed_tasks}\")\ntask1 = TaskCounter(\"보고서 작성\")\ntask1.complete_task()\nprint(f\"Task1 완료 후: {TaskCounter.total_completed_tasks}\")\ntask2 = TaskCounter(\"코드 리뷰\")\ntask2.complete_task()\nprint(f\"Task2 완료 후: {TaskCounter.total_completed_tasks}\")\n",
          "testCode_adv": "student_globals = {'TaskCounter': None}; exec(student_code, student_globals); TaskCounterClass = student_globals['TaskCounter']; TaskCounterClass.total_completed_tasks = 0; assert hasattr(TaskCounterClass, 'total_completed_tasks'), 'TaskCounter 클래스에 total_completed_tasks 변수가 없습니다.'; task1 = TaskCounterClass('Test1'); task1.complete_task(); assert TaskCounterClass.total_completed_tasks == 1, '첫 번째 작업 완료 후 클래스 변수가 1이어야 합니다.'; task2 = TaskCounterClass('Test2'); task2.complete_task(); task2.complete_task(); assert TaskCounterClass.total_completed_tasks == 3, '총 세 번의 작업 완료 후 클래스 변수가 3이어야 합니다.'",
          "feedback_adv": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "변수 범위 마스터",
              "content": "<span class='font-bold text-green-300'>전역 카운터가 정상적으로 증가하는 것을 확인했습니다.</span> / <span class='font-bold text-green-300'>클래스 변수가 올바르게 증가하는 것을 확인했습니다.</span> 변수의 유효 범위를 이해하는 것은 복잡한 프로그램을 만들 때 매우 중요합니다. 핵심 개념을 잘 습득했네요. 수고했습니다."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "global 선언을 확인해보세요!",
              "content": "함수를 호출했는데도 바깥의 `total_task_count` 값이 바뀌지 않았어요. 함수 안 첫 줄에 <span class='font-bold text-teal-300'>`global total_task_count`</span> 라고 정확히 선언했는지 확인해주세요. 이 선언이 없으면 함수 안에서 값을 바꿔도 바깥 변수에는 영향을 주지 않아요."
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, UnboundLocalError 또는 NameError!",
              "content": "오류 메시지에 `UnboundLocalError` 또는 `NameError`가 나오네요. 함수 안에서 바깥 범위의 변수를 수정하려고 할 때 필요한 `global` 선언을 빠뜨리면 이런 오류가 자주 발생해요 [cite: 1684-1685]. 코드를 다시 확인해주세요!"
            }
          }
        }
      ]
    },
    {
      "week": 5,
      "title": "자료구조 (1): 순서가 있는 데이터 묶음, 리스트와 튜플",
      "cycles": [
        {
          "title": "리스트 생성 및 기본 조작",
          "filename": "task_list.py",
          "lecture": {
            "character": "profKim",
            "title": "강의 노트: 리스트 (List)",
            "keyTakeaway": "리스트는 `[]`로 만들며, `.append()`로 항목을 추가하고 `del`로 삭제하는 '변경 가능한' 데이터 묶음입니다.",
            "sandboxCode": "todo_list = []\ntodo_list.append(\"파이썬 공부\")\ntodo_list.append(\"저녁 식사\")\nprint(todo_list)",
            "sections": [
              {
                "heading": "핵심 개념",
                "text": "리스트(List)는 여러 데이터를 순서대로 담을 수 있는 자료구조입니다[cite: 2053]. 리스트의 가장 큰 특징은 생성된 후에도 값을 추가, 삭제, 변경할 수 있다는 점(비정적, mutable)입니다[cite: 2057].",
                "code": null
              },
              {
                "heading": "기본 문법",
                "text": "대괄호 `[]`를 사용해 만들고, `.append()` 메소드로 항목을 추가합니다 [cite: 2055, 2065-2066].",
                "code": "# 빈 리스트 생성\nmy_list = []\n\n# 항목 추가하기\nmy_list.append(\"사과\")\nmy_list.append(100)\n\n# 항목 삭제하기 (첫 번째 항목)\ndel my_list[0]"
              },
              {
                "heading": "활용 사례",
                "text": "사용자 목록, 할 일 목록, 점수 목록 등 순서가 있고 내용이 계속 바뀔 수 있는 데이터를 관리할 때 매우 유용하게 사용됩니다.",
                "code": null
              },
              {
                "heading": "주의점 및 팁",
                "text": "리스트의 첫 번째 항목의 위치(인덱스)는 1이 아닌 0입니다[cite: 2116]. `.append()`는 항상 리스트의 맨 마지막에 항목을 추가합니다.",
                "code": null
              }
            ]
          },
          "syntax_key": {
            "syntax_title": "리스트 (List)",
            "syntax_comment": "여러 항목을 순서대로 저장하는 변경 가능한 자료 구조입니다.",
            "systax_code": "servers = [\"sv1\", \"sv2\"]"
          },
          "task": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "스프린트 업무 목록 관리",
            "content": "다음 스프린트에서 진행할 업무 목록을 관리해야 합니다. 먼저 <span class='font-bold text-yellow-300'>`sprint_tasks` 라는 이름의 비어있는 리스트</span>를 하나 만들어주세요. 그 다음, 목록에 <span class='font-bold text-yellow-300'>'사용자 로그인 기능 개발'</span>과 <span class='font-bold text-yellow-300'>'게시판 UI 개선'</span>이라는 두 가지 업무를 추가해주세요."
          },
          "briefing": {
            "character": "sena",
            "subtitle": "직속 선임의 OJT",
            "title": "여러 개를 담는 리스트",
            "content": "리스트는 여러 항목을 순서대로 담는 보관함이에요[cite: 2053]. `starterCode`를 봅시다! 첫 빈칸에는 비어있는 리스트 기호 <span class='font-bold text-teal-300'>`[]`</span>를 넣으세요[cite: 2055]. 다음 빈칸에는 <span class='font-bold text-teal-300'>`sprint_tasks.append('사용자 로그인 기능 개발')`</span> 코드를 넣어 리스트에 항목을 추가해요. <span class='font-bold text-teal-300'>`.append()`</span>는 리스트 끝에 항목을 추가하는 명령어죠 [cite: 2065-2066]. 마지막 빈칸도 같은 방식으로 '게시판 UI 개선' 항목을 추가하면 완성!"
          },
          "starterCode": "# TODO: 1. '=' 오른쪽에 비어있는 리스트([])를 만드세요.\nsprint_tasks = \n\n# TODO: 2. 아래 빈칸에 sprint_tasks 리스트에 '사용자 로그인 기능 개발'을 추가하는 코드를 작성하세요.\n# 형식: 리스트이름.append(추가할 항목)\n.append()\n\n# TODO: 3. 위와 같은 방식으로 '게시판 UI 개선'을 sprint_tasks 리스트에 추가하세요.\n.append()\n\n# 아래는 테스트용 코드입니다. 수정하지 마세요.\nprint(sprint_tasks)\n",
          "testCode": "student_globals = {'sprint_tasks': None}; exec(student_code, student_globals); final_sprint_tasks = student_globals['sprint_tasks']; assert isinstance(final_sprint_tasks, list), \"'sprint_tasks' 변수는 리스트(list)여야 합니다.\"; expected = ['사용자 로그인 기능 개발', '게시판 UI 개선']; assert final_sprint_tasks == expected, f\"리스트의 내용이 기대와 다릅니다. 기대값: {expected}, 실제값: {final_sprint_tasks}\"",
          "feedback": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "업무 목록 생성 완료",
              "content": "<span class='font-bold text-green-300'>정확하게 리스트를 만들고 항목들을 추가했군요.</span> / <span class='font-bold text-green-300'>함수가 새 업무들을 리스트에 올바르게 추가했습니다.</span> 좋습니다. 이제 이 리스트를 바탕으로 프로젝트를 관리할 수 있겠네요."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "리스트 생성이나 append 사용법을 확인해볼까요?",
              "content": "리스트 내용이 요청과 조금 다르네요. 첫 줄 빈칸에 비어있는 리스트 기호 <span class='font-bold text-teal-300'>`[]`</span>를 넣었는지, 그리고 `.append()` 메소드를 사용할 때 <span class='font-bold text-teal-300'>`sprint_tasks.append('...')`</span> 형태로 리스트 이름과 괄호 안 항목을 정확히 입력했는지 확인해주세요. 문자열은 따옴표로 감싸야 해요!"
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, 문법 오류!",
              "content": "코드를 실행하다가 오류가 발생했어요. 비어있는 리스트를 만들 때 `[]` 처럼 대괄호를 사용하셨나요? `.append()` 메소드를 사용할 때 괄호 안에 추가할 항목을 잘 넣었는지도 확인해주세요."
            }
          },
          "task_adv": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "업무 추가 함수 완성",
            "content": "기존 업무 목록에 새로운 업무들을 추가하는 `add_new_tasks` 함수를 완성해야 합니다. 함수 내부 로직을 구현하여, <span class='font-bold text-yellow-300'>`initial_tasks` 리스트에 `new_tasks` 리스트의 모든 항목을 순서대로 추가</span>하고 최종 목록을 반환하도록 만들어주세요."
          },
          "briefing_adv": {
            "character": "sena",
            "subtitle": "직속 선임의 팁",
            "title": "리스트에 여러 항목 추가하기",
            "content": "함수가 `new_tasks`라는 리스트를 받았네요. 이 리스트에 있는 항목들을 하나씩 `initial_tasks`에 추가해야 해요. 이럴 땐 <span class='font-bold text-teal-300'>`for` 루프</span>로 `new_tasks`를 순회하면서 각 항목을 <span class='font-bold text-teal-300'>`.append()` 메소드</span>로 `initial_tasks`에 추가해주면 되겠죠?"
          },
          "starterCode_adv": "# 아래 함수는 초기 업무 목록에 새로운 업무들을 추가하는 함수입니다.\n# TODO: 함수 본문에서 for 루프와 append 메소드를 사용하여\n#       'initial_tasks' 리스트에 'new_tasks' 리스트의 각 항목을 추가하세요.\ndef add_new_tasks(initial_tasks, new_tasks):\n    # 여기에 코드를 작성하세요.\n    for task in new_tasks:\n        initial_tasks.append(task)\n    return initial_tasks\n\n# 함수 호출 및 결과 확인 (수정 불필요)\ncurrent_sprint = ['기획 회의']\nnext_tasks = ['사용자 로그인 기능 개발', '게시판 UI 개선']\nsprint_tasks = add_new_tasks(current_sprint, next_tasks)\nprint(sprint_tasks)\n",
          "testCode_adv": "assert callable(add_new_tasks), 'add_new_tasks 함수가 정의되지 않았습니다.'; initial = ['기획 회의']; new = ['로그인 개발', 'UI 개선']; result = add_new_tasks(initial[:], new); expected = ['기획 회의', '로그인 개발', 'UI 개선']; assert result == expected, f'함수 반환값이 올바르지 않습니다. 기대값: {expected}, 실제값: {result}'; student_globals = {'add_new_tasks': add_new_tasks, 'current_sprint': ['기획 회의'], 'next_tasks': ['사용자 로그인 기능 개발', '게시판 UI 개선'], 'sprint_tasks': None}; exec(\"sprint_tasks = add_new_tasks(current_sprint, next_tasks)\\nprint(sprint_tasks)\", student_globals); final_global_sprint_tasks = student_globals['sprint_tasks']; expected_global = ['기획 회의', '사용자 로그인 기능 개발', '게시판 UI 개선']; assert final_global_sprint_tasks == expected_global, f'최종 sprint_tasks 변수 값이 올바르지 않습니다. 기대값: {expected_global}, 실제값: {final_global_sprint_tasks}'",
          "feedback_adv": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "업무 목록 생성 완료",
              "content": "<span class='font-bold text-green-300'>정확하게 리스트를 만들고 항목들을 추가했군요.</span> / <span class='font-bold text-green-300'>함수가 새 업무들을 리스트에 올바르게 추가했습니다.</span> 좋습니다. 이제 이 리스트를 바탕으로 프로젝트를 관리할 수 있겠네요."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "리스트 생성이나 append 사용법을 확인해볼까요?",
              "content": "리스트 내용이 요청과 조금 다르네요. 첫 줄 빈칸에 비어있는 리스트 기호 <span class='font-bold text-teal-300'>`[]`</span>를 넣었는지, 그리고 `.append()` 메소드를 사용할 때 <span class='font-bold text-teal-300'>`sprint_tasks.append('...')`</span> 형태로 리스트 이름과 괄호 안 항목을 정확히 입력했는지 확인해주세요. 문자열은 따옴표로 감싸야 해요!"
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, 문법 오류!",
              "content": "코드를 실행하다가 오류가 발생했어요. 비어있는 리스트를 만들 때 `[]` 처럼 대괄호를 사용하셨나요? `.append()` 메소드를 사용할 때 괄호 안에 추가할 항목을 잘 넣었는지도 확인해주세요."
            }
          }
        },
        {
          "title": "리스트 고급 활용 (인덱싱, 슬라이싱, 정렬)",
          "filename": "report_generator.py",
          "lecture": {
            "character": "profKim",
            "title": "강의 노트: 인덱싱, 슬라이싱, 정렬",
            "keyTakeaway": "인덱싱 `[i]`으로 하나를, 슬라이싱 `[i:j]`으로 여러 개를 꺼내고, `.sort()`로 정렬할 수 있습니다.",
            "sandboxCode": "scores = [90, 75, 100, 80]\nscores.sort()\n\n# 정렬된 리스트에서 가장 높은 점수(맨 마지막 항목)를 출력해보세요.\nprint(scores[-1])",
            "sections": [
              {
                "heading": "핵심 개념",
                "text": "리스트는 순서가 있기 때문에, 각 항목의 위치(인덱스)를 통해 특정 값에 접근하거나(인덱싱), 특정 범위의 값들을 잘라낼 수 있습니다(슬라이싱) [cite: 2219-2220]. 또한, 내장된 기능을 통해 손쉽게 정렬할 수 있습니다.",
                "code": null
              },
              {
                "heading": "기본 문법",
                "text": "대괄호 `[]`와 콜론 `:`을 사용해 데이터에 접근하고 잘라냅니다.",
                "code": "my_list = ['b', 'c', 'a']\n\n# 인덱싱 (0번째 항목 접근)\nfirst_item = my_list[0]  # 'b'\n\n# 슬라이싱 (1번째부터 3번째 앞까지 - 1, 2번 인덱스)\nslice_items = my_list[1:3] # ['c', 'a']\n\n# 정렬 (리스트 자체를 변경)\nmy_list.sort() # my_list는 이제 ['a', 'b', 'c']"
              },
              {
                "heading": "활용 사례",
                "text": "가장 높은 점수나 가장 낮은 점수 찾기, 특정 기간의 데이터만 추출하기, 이름을 가나다순으로 정렬하여 보여주기 등 데이터의 순서나 특정 위치가 중요할 때 사용됩니다.",
                "code": null
              },
              {
                "heading": "주의점 및 팁",
                "text": "인덱스는 0부터 시작하며, 없는 인덱스에 접근하면 오류가 발생합니다 [cite: 2262-2263]. 슬라이싱 `[a:b]`는 a부터 b-1까지의 항목을 포함합니다 [cite: 2271-2272]. `.sort()`는 리스트 자체를 바꾸므로 원본을 유지하고 싶다면 복사본을 만들어 사용해야 합니다 (예: `new_list = old_list[:]`).",
                "code": null
              }
            ]
          },
          "syntax_key": {
            "syntax_title": "리스트 (List)",
            "syntax_comment": "여러 항목을 순서대로 저장하는 변경 가능한 자료 구조입니다.",
            "systax_code": "servers = [\"sv1\", \"sv2\"]"
          },
          "task": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "업무 보고서 작성",
            "content": "기획팀에 보고할 자료입니다. `sprint_tasks` 리스트에서 <span class='font-bold text-yellow-300'>가장 첫 번째 업무가 무엇인지</span> 알려주세요. 그리고 회의 자료에 쓸 수 있도록, 전체 업무 목록을 <span class='font-bold text-yellow-300'>알파벳 순으로 정렬</span>해서 보여주세요. (원본 리스트 자체를 정렬해야 합니다). 마지막으로, 정렬된 목록에서 <span class='font-bold text-yellow-300'>처음 두 개의 업무만</span> 따로 뽑아서 보고해주세요."
          },
          "briefing": {
            "character": "sena",
            "subtitle": "직속 선임의 팁",
            "title": "리스트에서 원하는 부분만!",
            "content": "리스트에서 특정 항목을 꺼낼 땐 위치 번호, <span class='font-bold text-teal-300'>인덱스</span>를 써요. 첫 번째는 `[0]`이죠! `first_task` 빈칸에 <span class='font-bold text-teal-300'>`sprint_tasks[0]`</span>을 넣으세요. 리스트 정렬은 <span class='font-bold text-teal-300'>`.sort()`</span> 메소드를 쓰면 돼요. 두 번째 빈칸에 <span class='font-bold text-teal-300'>`sprint_tasks.sort()`</span>를 넣으세요. 여러 개를 잘라낼 땐 <span class='font-bold text-teal-300'>슬라이싱</span> `[:]`을 써요. `main_tasks` 빈칸에는 처음 두 개를 의미하는 <span class='font-bold text-teal-300'>`sprint_tasks[:2]`</span>를 넣으면 됩니다! 시작 인덱스를 생략하면 처음부터라는 뜻이에요 [cite: 2268-2269]."
          },
          "starterCode": "sprint_tasks = ['사용자 로그인 기능 개발', '게시판 UI 개선', '결제 시스템 연동']\n\n# TODO: 1. '=' 오른쪽에 sprint_tasks 리스트의 첫 번째 항목을 가져오는 코드를 작성하세요.\n# 형식: 리스트이름[인덱스] (첫 번째는 인덱스 0)\nfirst_task = \n\n# TODO: 2. 아래 빈칸에 sprint_tasks 리스트를 정렬하는 코드를 작성하세요.\n# 형식: 리스트이름.sort()\n\n\n# TODO: 3. '=' 오른쪽에 정렬된 sprint_tasks 리스트에서 처음 두 개 항목을 가져오는 코드를 작성하세요.\n# 형식: 리스트이름[시작인덱스:끝인덱스+1] (처음부터는 시작 생략 가능)\nmain_tasks = \n\n# 아래는 테스트용 코드입니다. 수정하지 마세요.\nprint(f\"첫 번째 업무: {first_task}\")\nprint(f\"정렬된 전체 업무: {sprint_tasks}\")\nprint(f\"핵심 업무: {main_tasks}\")\n",
          "testCode": "original_list = ['사용자 로그인 기능 개발', '게시판 UI 개선', '결제 시스템 연동']; first_task_expected = original_list[0]; student_globals = {'sprint_tasks': original_list[:], 'first_task': None, 'main_tasks': None}; exec(student_code, student_globals); final_first_task = student_globals.get('first_task'); final_sprint_tasks = student_globals.get('sprint_tasks'); final_main_tasks = student_globals.get('main_tasks'); assert final_first_task == first_task_expected, f\"first_task의 값이 다릅니다. 기대값: '{first_task_expected}', 실제값: '{final_first_task}'\"; sorted_tasks_expected = sorted(original_list); assert final_sprint_tasks == sorted_tasks_expected, f\"리스트가 올바르게 정렬되지 않았습니다. 기대값: {sorted_tasks_expected}, 실제값: {final_sprint_tasks}\"; main_tasks_expected = sorted_tasks_expected[:2]; assert final_main_tasks == main_tasks_expected, f\"main_tasks의 값이 다릅니다. 기대값: {main_tasks_expected}, 실제값: {final_main_tasks}\"",
          "feedback": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "보고 완료",
              "content": "<span class='font-bold text-green-300'>요청한 데이터를 정확하게 추출하고 정렬했네요.</span> / <span class='font-bold text-green-300'>함수가 리스트를 올바르게 처리하고 결과를 반환했습니다.</span> 리스트를 다루는 실력이 빠르게 늘고 있군요. 이런 데이터 가공 능력은 분석 업무의 기본입니다."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "인덱스나 슬라이스 범위를 확인해볼까요?",
              "content": "추출하거나 정렬한 결과가 요청과 조금 다르네요. 첫 번째 항목 인덱스는 <span class='font-bold text-teal-300'>`[0]`</span>이 맞는지, `.sort()` 메소드를 호출했는지, 처음 두 항목 슬라이싱은 <span class='font-bold text-teal-300'>`[:2]`</span>가 맞는지 확인해주세요. 슬라이싱 끝 번호는 포함되지 않는다는 점 잊지 마세요!"
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, 인덱스 또는 슬라이싱 오류!",
              "content": "리스트를 다루다가 오류가 발생했어요. `IndexError`는 리스트 범위를 벗어난 인덱스를 사용할 때 발생해요. 슬라이싱 문법(`[start:end]`)에 오타가 있거나, `.sort()` 같은 메소드 이름이 틀렸을 수도 있으니 확인해보세요!"
            }
          },
          "task_adv": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "업무 목록 처리 함수 완성",
            "content": "업무 목록을 처리하는 `process_task_list` 함수를 완성해야 합니다. 함수 내부에서, 입력받은 리스트(`task_list`)를 이용하여 다음 작업들을 수행하고 결과를 반환해주세요: <span class='font-bold text-yellow-300'>첫 번째 업무 추출</span>, <span class='font-bold text-yellow-300'>리스트 복사 및 정렬</span>, <span class='font-bold text-yellow-300'>정렬된 리스트에서 상위 두 개 항목 추출</span>. 원본 리스트는 변경하지 않아야 합니다."
          },
          "briefing_adv": {
            "character": "sena",
            "subtitle": "직속 선임의 팁",
            "title": "복사하고 처리하기",
            "content": "함수 안에서 받은 리스트를 직접 수정하면 안 될 때가 있어요. 그럴 땐 <span class='font-bold text-teal-300'>전체 슬라이싱 `[:]`</span>으로 리스트를 복사해서 사용하면 원본은 안전하게 지킬 수 있죠[cite: 2343]. 복사한 리스트에 <span class='font-bold text-teal-300'>`.sort()`</span> 메소드를 쓰고, <span class='font-bold text-teal-300'>인덱싱 `[0]`</span>과 <span class='font-bold text-teal-300'>슬라이싱 `[:2]`</span>을 활용해서 필요한 값들을 추출한 다음, 마지막에 `return`으로 여러 값을 튜플로 묶어서 돌려주면 되겠네요!"
          },
          "starterCode_adv": "# 아래 함수는 업무 목록을 받아 처리하고 결과를 반환합니다.\n# TODO: 함수 본문에서 아래 작업을 순서대로 수행하세요.\n# 1. 인덱싱을 사용하여 task_list의 첫 번째 항목을 first 변수에 저장하세요.\n# 2. task_list를 복사하여 sorted_list를 만드세요. (힌트: 슬라이싱)\n# 3. sorted_list를 알파벳 순으로 정렬하세요.\n# 4. 정렬된 sorted_list에서 처음 두 항목을 슬라이싱하여 top_two 변수에 저장하세요.\n# 5. first, sorted_list, top_two 세 변수를 튜플 형태로 반환하세요.\ndef process_task_list(task_list):\n    first = \"\"\n    sorted_list = []\n    top_two = []\n    \n    # 여기에 코드 작성\n    if task_list: # 리스트가 비어있지 않은 경우에만 처리\n        first = task_list[0]\n        sorted_list = task_list[:] # 전체 슬라이싱으로 복사\n        sorted_list.sort()\n        top_two = sorted_list[:2]\n\n    return first, sorted_list, top_two\n\n# 함수 호출 및 결과 확인 (수정 불필요)\nsprint_tasks = ['사용자 로그인 기능 개발', '게시판 UI 개선', '결제 시스템 연동']\nfirst_task, sorted_tasks, main_tasks = process_task_list(sprint_tasks)\nprint(f\"첫 번째 업무: {first_task}\")\nprint(f\"정렬된 전체 업무: {sorted_tasks}\")\nprint(f\"핵심 업무: {main_tasks}\")\n",
          "testCode_adv": "assert callable(process_task_list), 'process_task_list 함수가 정의되지 않았습니다.'; input_list = ['Login Feature', 'UI Improvement', 'Payment Integration']; first_expected = 'Login Feature'; sorted_expected = ['Login Feature', 'Payment Integration', 'UI Improvement']; top_two_expected = ['Login Feature', 'Payment Integration']; first, sorted_list, top_two = process_task_list(input_list[:]); assert first == first_expected, f'첫 번째 항목 추출이 잘못되었습니다. 기대값: {first_expected}, 실제값: {first}'; assert sorted_list == sorted_expected, f'리스트 정렬이 잘못되었습니다. 기대값: {sorted_expected}, 실제값: {sorted_list}'; assert top_two == top_two_expected, f'상위 두 항목 슬라이싱이 잘못되었습니다. 기대값: {top_two_expected}, 실제값: {top_two}'",
          "feedback_adv": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "보고 완료",
              "content": "<span class='font-bold text-green-300'>요청한 데이터를 정확하게 추출하고 정렬했네요.</span> / <span class='font-bold text-green-300'>함수가 리스트를 올바르게 처리하고 결과를 반환했습니다.</span> 리스트를 다루는 실력이 빠르게 늘고 있군요. 이런 데이터 가공 능력은 분석 업무의 기본입니다."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "인덱스나 슬라이스 범위를 확인해볼까요?",
              "content": "추출하거나 정렬한 결과가 요청과 조금 다르네요. 첫 번째 항목 인덱스는 <span class='font-bold text-teal-300'>`[0]`</span>이 맞는지, `.sort()` 메소드를 호출했는지, 처음 두 항목 슬라이싱은 <span class='font-bold text-teal-300'>`[:2]`</span>가 맞는지 확인해주세요. 슬라이싱 끝 번호는 포함되지 않는다는 점 잊지 마세요!"
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, 인덱스 또는 슬라이싱 오류!",
              "content": "리스트를 다루다가 오류가 발생했어요. `IndexError`는 리스트 범위를 벗어난 인덱스를 사용할 때 발생해요. 슬라이싱 문법(`[start:end]`)에 오타가 있거나, `.sort()` 같은 메소드 이름이 틀렸을 수도 있으니 확인해보세요!"
            }
          }
        },
        {
          "title": "수정 불가능한 튜플의 이해",
          "filename": "config.py",
          "lecture": {
            "character": "profKim",
            "title": "강의 노트: 튜플 (Tuple)",
            "keyTakeaway": "튜플은 `()`로 만들며, 한번 만들면 내용을 바꿀 수 없는 '안전한' 데이터 묶음입니다.",
            "sandboxCode": "# x, y 좌표를 튜플로 저장하고 y좌표를 출력해보세요.\npoint = (10, 20)\nprint(point[1])",
            "sections": [
              {
                "heading": "핵심 개념",
                "text": "튜플(Tuple)은 리스트처럼 순서가 있는 데이터 묶음이지만, 생성된 후에는 항목을 추가, 삭제, 변경할 수 없는 '변경 불가능(immutable)'한 자료구조입니다 [cite: 2119-2120]. 이 불변성 덕분에 데이터의 무결성을 보장해야 할 때 유용합니다.",
                "code": null
              },
              {
                "heading": "기본 문법",
                "text": "소괄호 `()`를 사용하여 생성합니다. 접근은 리스트와 같이 인덱싱을 사용합니다[cite: 2121, 2151].",
                "code": "# 튜플 생성\nmy_tuple = (1, 2, 'c')\n\n# 인덱싱으로 접근 가능\nfirst_item = my_tuple[0] # 1\n\n# 변경 시도 시 오류 발생!\n# my_tuple[0] = 5  # TypeError 발생"
              },
              {
                "heading": "활용 사례",
                "text": "함수에서 여러 개의 값을 반환할 때, 좌표(x, y)값처럼 변하면 안 되는 순서쌍을 저장할 때, 딕셔너리의 키(Key)로 사용할 때 등 데이터의 일관성과 안정성이 중요할 때 사용됩니다.",
                "code": null
              },
              {
                "heading": "주의점 및 팁",
                "text": "항목이 하나인 튜플을 만들 때는 반드시 항목 뒤에 쉼표를 붙여야 합니다. 예: `(5,)`. 쉼표가 없으면 `(5)`는 그냥 숫자 5로 인식됩니다 [cite: 2156-2158].",
                "code": null
              }
            ]
          },
          "syntax_key": {
            "syntax_title": "리스트 (List)",
            "syntax_comment": "여러 항목을 순서대로 저장하는 변경 가능한 자료 구조입니다.",
            "systax_code": "servers = [\"sv1\", \"sv2\"]"
          },
          "task": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "고정 데이터 관리",
            "content": "서비스의 <span class='font-bold text-yellow-300'>핵심 설정값</span>을 저장해야 합니다. 예를 들어, 서버 접속 정보(IP 주소, 포트 번호)처럼 프로그램 실행 중에 <span class='font-bold text-yellow-300'>절대로 바뀌어서는 안 되는 고정된 값</span>들이죠. 이런 데이터는 실수로 변경되는 것을 막기 위해 리스트가 아닌 **'튜플(Tuple)'**을 사용해 저장해주세요."
          },
          "briefing": {
            "character": "sena",
            "subtitle": "직속 선임의 팁",
            "title": "수정 불가! 안전한 튜플",
            "content": "튜플은 리스트와 비슷하지만, 한 번 만들면 내용을 바꿀 수 없어요. 그래서 중요한 설정값처럼 변하면 안 되는 데이터를 저장할 때 좋아요 [cite: 2119-2120]. `starterCode` 빈칸에 <span class='font-bold text-teal-300'>소괄호 `()`</span>를 쓰고, 그 안에 <span class='font-bold text-teal-300'>`'192.168.1.1'`</span>과 <span class='font-bold text-teal-300'>`8080`</span>을 <span class='font-bold text-teal-300'>쉼표(`,`)</span>로 구분해서 넣어보세요. <span class='font-bold text-teal-300'>`('192.168.1.1', 8080)`</span> 처럼요! 문자열은 따옴표, 숫자는 그냥 쓰는 거 잊지 마세요."
          },
          "starterCode": "# TODO: '=' 오른쪽에 소괄호()를 사용하여 튜플을 만들고, 그 안에 '192.168.1.1'과 8080을 쉼표(,)로 구분하여 넣으세요.\nserver_config = \n\n# 아래는 테스트용 코드입니다. 수정하지 마세요.\nprint(f\"서버 IP: {server_config[0]}\")\nprint(f\"서버 포트: {server_config[1]}\")\n",
          "testCode": "assert 'server_config' in locals(), \"'server_config' 변수가 존재하지 않습니다.\"; assert isinstance(server_config, tuple), \"'server_config' 변수는 튜플(tuple)이어야 합니다.\"; expected = ('192.168.1.1', 8080); assert server_config == expected, f\"튜플의 내용이 기대와 다릅니다. 기대값: {expected}, 실제값: {server_config}\"",
          "feedback": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "안정적인 데이터 관리",
              "content": "<span class='font-bold text-green-300'>튜플을 적재적소에 잘 사용했네요.</span> / <span class='font-bold text-green-300'>함수가 올바른 설정값을 튜플로 반환했습니다.</span> 이제 이 설정값은 실수로 변경될 염려가 없겠습니다. 리스트와 튜플의 차이를 이해하는 것은 중요한 역량입니다."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "튜플 내용이나 형식을 확인해볼까요?",
              "content": "튜플에 저장된 값이 요청과 조금 다르네요. 소괄호 `()` 안에 <span class='font-bold text-teal-300'>`'192.168.1.1'`</span> (따옴표 필수!) 와 숫자 <span class='font-bold text-teal-300'>`8080`</span>을 <span class='font-bold text-teal-300'>쉼표(`,`)</span>로 구분해서 정확히 넣었는지 확인해주세요!"
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, 튜플 생성 오류!",
              "content": "튜플을 만들 때 오류가 발생했어요. 튜플은 `()` 소괄호로 만드는 거 기억하시죠? 그리고 각 항목은 쉼표(`,`)로 구분해야 해요. `('192.168.1.1', 8080)` 이런 식으로요."
            }
          },
          "task_adv": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "기본 설정 반환 함수 완성",
            "content": "기본 서버 설정을 반환하는 `get_default_server_config` 함수가 있습니다. 함수 내부 로직을 완성하여, <span class='font-bold text-yellow-300'>IP 주소('192.168.1.1')와 포트 번호(8080)를 순서대로 포함하는 튜플</span>을 생성하고 이를 반환하도록 만들어주세요."
          },
          "briefing_adv": {
            "character": "sena",
            "subtitle": "직속 선임의 팁",
            "title": "튜플 만들어서 반환하기",
            "content": "튜플 만드는 건 간단해요! <span class='font-bold text-teal-300'>소괄호 `()` 안에 원하는 값들을 쉼표(`,`)로 구분</span>해서 넣어주면 돼요. 문자열은 따옴표로 감싸는 거 잊지 마시고요. 이렇게 만든 튜플을 <span class='font-bold text-teal-300'>`return` 키워드</span> 뒤에 써주면 함수가 그 튜플을 반환해 줄 거예요."
          },
          "starterCode_adv": "# 아래 함수는 기본 서버 설정을 튜플 형태로 반환합니다.\n# TODO: 함수 본문에서 IP 주소('192.168.1.1')와 포트 번호(8080)를\n#       순서대로 포함하는 튜플을 생성하여 반환하세요.\ndef get_default_server_config():\n    # 여기에 튜플을 생성하고 반환하는 코드를 작성하세요.\n    return ('192.168.1.1', 8080)\n\n# 함수 호출 및 결과 확인 (수정 불필요)\nserver_config = get_default_server_config()\nprint(f\"서버 IP: {server_config[0]}\")\nprint(f\"서버 포트: {server_config[1]}\")\n",
          "testCode_adv": "assert callable(get_default_server_config), 'get_default_server_config 함수가 정의되지 않았습니다.'; result = get_default_server_config(); assert isinstance(result, tuple), '함수는 튜플을 반환해야 합니다.'; expected = ('192.168.1.1', 8080); assert result == expected, f'함수가 반환한 튜플의 내용이 기대와 다릅니다. 기대값: {expected}, 실제값: {result}'; assert 'server_config' in locals() and server_config == expected, '전역 변수 server_config 값이 올바르지 않습니다.'",
          "feedback_adv": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "안정적인 데이터 관리",
              "content": "<span class='font-bold text-green-300'>튜플을 적재적소에 잘 사용했네요.</span> / <span class='font-bold text-green-300'>함수가 올바른 설정값을 튜플로 반환했습니다.</span> 이제 이 설정값은 실수로 변경될 염려가 없겠습니다. 리스트와 튜플의 차이를 이해하는 것은 중요한 역량입니다."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "튜플 내용이나 형식을 확인해볼까요?",
              "content": "튜플에 저장된 값이 요청과 조금 다르네요. 소괄호 `()` 안에 <span class='font-bold text-teal-300'>`'192.168.1.1'`</span> (따옴표 필수!) 와 숫자 <span class='font-bold text-teal-300'>`8080`</span>을 <span class='font-bold text-teal-300'>쉼표(`,`)</span>로 구분해서 정확히 넣었는지 확인해주세요!"
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, 튜플 생성 오류!",
              "content": "튜플을 만들 때 오류가 발생했어요. 튜플은 `()` 소괄호로 만드는 거 기억하시죠? 그리고 각 항목은 쉼표(`,`)로 구분해야 해요. `('192.168.1.1', 8080)` 이런 식으로요."
            }
          }
        }
      ]
    },
    {
      "week": 6,
      "title": "자료구조 (2): Key-Value 데이터, 딕셔너리와 집합",
      "cycles": [
        {
          "title": "Key-Value 쌍, 딕셔너리 기초",
          "filename": "profile.py",
          "lecture": {
            "character": "profKim",
            "title": "강의 노트: 딕셔너리 (Dictionary)",
            "keyTakeaway": "딕셔너리는 `{Key: Value}` 형태로, 순서가 아닌 이름(Key)으로 데이터를 관리하는 자료구조입니다.",
            "sandboxCode": "my_pet = {\n    \"name\": \"Happy\",\n    \"animal_type\": \"Dog\"\n}\n\n# 펫의 이름을 출력해보세요.\nprint(my_pet[\"name\"])",
            "sections": [
              {
                "heading": "핵심 개념",
                "text": "딕셔너리(Dictionary)는 순서 대신 '키(Key)'를 사용하여 각 값(Value)에 접근하는 자료구조입니다. 모든 키는 고유해야 하며, 이 키-값(Key-Value) 쌍들의 묶음으로 데이터를 관리합니다 [cite: 2115-2117]. 마치 사전에서 단어(Key)를 찾아 뜻(Value)을 찾는 것과 같습니다.",
                "code": null
              },
              {
                "heading": "기본 문법",
                "text": "중괄호 `{}`를 사용하며, `키: 값` 형식으로 각 항목을 정의하고 쉼표로 구분합니다 [cite: 2120-2121].",
                "code": "# 딕셔너리 생성\nmy_profile = {\n    \"username\": \"rookie\",\n    \"level\": 5,\n    \"is_active\": True\n}\n\n# 값에 접근하기 (키 사용)\nprint(my_profile[\"username\"]) # 'rookie' 출력"
              },
              {
                "heading": "활용 사례",
                "text": "사용자 정보, 게임 캐릭터의 능력치, JSON 형식의 API 응답 데이터 등 명확한 이름(Key)으로 각 데이터를 구분해야 할 때 광범위하게 사용됩니다.",
                "code": null
              },
              {
                "heading": "주의점 및 팁",
                "text": "딕셔너리의 키(Key)는 고유해야 하며, 중복될 수 없습니다. 또한, 키는 문자열이나 숫자처럼 '변경 불가능(immutable)'한 값만 사용할 수 있습니다[cite: 2118]. 없는 키로 값에 접근하려고 하면 오류가 발생합니다.",
                "code": null
              }
            ]
          },
          "syntax_key": {
            "syntax_title": "리스트 (List)",
            "syntax_comment": "여러 항목을 순서대로 저장하는 변경 가능한 자료 구조입니다.",
            "systax_code": "servers = [\"sv1\", \"sv2\"]"
          },
          "task": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "사용자 프로필 데이터 구조화",
            "content": "지금까지 사용자 정보를 개별 변수로 관리했는데, 한계가 명확하네요. <span class='font-bold text-yellow-300'>한 명의 사용자 프로필 정보</span>('username': 'rookie', 'level': 1, 'team': '솔루션개발팀')를 하나의 묶음으로 관리해야 합니다. **'딕셔너리(Dictionary)'**를 사용하여 이 정보를 담은 `user_profile` 변수를 만들어주세요."
          },
          "briefing": {
            "character": "sena",
            "subtitle": "직속 선임의 OJT",
            "title": "이름표(Key)로 값(Value) 찾기",
            "content": "딕셔너리는 이름표(Key)를 붙여 데이터를 관리해요 [cite: 2115-2116]. `starterCode`의 <span class='font-bold text-teal-300'>중괄호 `{}` 안</span>에 이름표와 값을 짝지어 넣어볼까요? 첫 번째 빈칸에는 <span class='font-bold text-teal-300'>`'username': 'rookie',`</span> 를 입력하세요. 이름표('username')와 값('rookie') 사이에 <span class='font-bold text-teal-300'>콜론(`:`)</span>, 각 항목 끝에는 <span class='font-bold text-teal-300'>쉼표(`,`)</span>가 필요해요. 나머지 두 항목도 같은 방식으로 채워보세요! 숫자(1)는 따옴표 없이 그냥 쓰면 돼요 [cite: 2120-2121]."
          },
          "starterCode": "# TODO: 아래 중괄호 {} 안에 키-값 쌍을 추가하여 딕셔너리를 완성하세요.\n# 형식: '키': 값 (키는 따옴표로 감싸고, 키와 값 사이엔 콜론(:), 각 항목 사이엔 쉼표(,) 사용)\nuser_profile = {\n    # 1. 'username' 키에 'rookie' 값을 할당 (예: 'username': 'rookie')\n    :\n    # 2. 'level' 키에 숫자 1 값을 할당 (숫자는 따옴표 없음)\n    :\n    # 3. 'team' 키에 '솔루션개발팀' 값을 할당\n    :\n}\n\n# 아래는 테스트용 코드입니다. 수정하지 마세요.\nprint(user_profile)\n",
          "testCode": "assert 'user_profile' in locals() and isinstance(user_profile, dict), \"user_profile 변수는 딕셔너리여야 합니다.\"; expected = {'username': 'rookie', 'level': 1, 'team': '솔루션개발팀'}; assert user_profile == expected, f\"딕셔너리의 내용이 기대와 다릅니다. 기대값: {expected}, 실제값: {user_profile}\"",
          "feedback": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "데이터 구조화 완료",
              "content": "<span class='font-bold text-green-300'>사용자 정보가 딕셔너리 형태로 잘 정리되었군요.</span> / <span class='font-bold text-green-300'>함수가 올바른 프로필 딕셔너리를 생성했습니다.</span> 이제 데이터가 훨씬 명확하고 관리하기 쉬워졌습니다. 앞으로 자주 사용하게 될 구조입니다."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "딕셔너리 형식을 확인해볼까요?",
              "content": "생성된 딕셔너리의 내용이 요청과 조금 다르네요. 각 항목을 <span class='font-bold text-teal-300'>`'키': 값,`</span> 형태로 정확히 작성했는지 확인해주세요. 키 이름('username', 'level', 'team')과 값('rookie', 1, '솔루션개발팀')이 맞는지, <span class='font-bold text-teal-300'>콜론(:)</span>과 <span class='font-bold text-teal-300'>쉼표(,)</span>를 빠뜨리지 않았는지도요!"
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, 딕셔너리 생성 오류!",
              "content": "딕셔너리를 만들 때 오류가 발생했어요. 딕셔너리는 `{}` 중괄호를 사용하고, 각 항목은 `'키': 값` 형태로 콜론(:)을 사용해야 해요. 각 항목 사이에는 쉼표(,)를 쓰는 것도 잊지 마세요!"
            }
          },
          "task_adv": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "프로필 생성 함수 완성",
            "content": "사용자 프로필 딕셔너리를 생성하는 `create_user_profile` 함수를 완성해야 합니다. 함수 내부 로직을 구현하여, <span class='font-bold text-yellow-300'>입력받은 이름, 레벨, 팀 정보를 각각 'username', 'level', 'team' 키에 저장</span>한 딕셔너리를 생성하고 반환하도록 만들어주세요."
          },
          "briefing_adv": {
            "character": "sena",
            "subtitle": "직속 선임의 팁",
            "title": "딕셔너리 만들기",
            "content": "함수 안에서도 딕셔너리 만드는 건 똑같아요! <span class='font-bold text-teal-300'>`{}` 중괄호</span> 안에, <span class='font-bold text-teal-300'>`'username': name`</span> 처럼 키(문자열)와 값(매개변수 변수)을 콜론(`:`)으로 연결하고, 각 항목을 쉼표(`,`)로 구분해주면 돼요. 이렇게 만든 딕셔너리를 `profile` 변수에 저장하고 `return` 해주면 되겠네요."
          },
          "starterCode_adv": "# 아래 함수는 사용자 이름, 레벨, 팀 정보를 받아 프로필 딕셔너리를 생성하여 반환합니다.\n# TODO: 함수 본문에서 매개변수들을 사용하여 요구사항에 맞는 딕셔너리를 만들고 반환하세요.\n# 요구사항:\n# - 'username' 키에는 name 매개변수 값\n# - 'level' 키에는 level 매개변수 값\n# - 'team' 키에는 team 매개변수 값\ndef create_user_profile(name, level, team):\n    profile = {}\n    # 여기에 딕셔너리를 완성하는 코드를 작성하세요.\n    profile['username'] = name\n    profile['level'] = level\n    profile['team'] = team\n    return profile\n\n# 함수 호출 및 결과 확인 (수정 불필요)\nuser_profile = create_user_profile('rookie', 1, '솔루션개발팀')\nprint(user_profile)\n",
          "testCode_adv": "assert callable(create_user_profile), 'create_user_profile 함수가 정의되지 않았습니다.'; result = create_user_profile('rookie', 1, '솔루션개발팀'); expected = {'username': 'rookie', 'level': 1, 'team': '솔루션개발팀'}; assert isinstance(result, dict) and result == expected, f'함수가 반환한 딕셔너리의 내용이 기대와 다릅니다. 기대값: {expected}, 실제값: {result}'; assert 'user_profile' in locals() and user_profile == expected, '전역 변수 user_profile 값이 올바르지 않습니다.'",
          "feedback_adv": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "데이터 구조화 완료",
              "content": "<span class='font-bold text-green-300'>사용자 정보가 딕셔너리 형태로 잘 정리되었군요.</span> / <span class='font-bold text-green-300'>함수가 올바른 프로필 딕셔너리를 생성했습니다.</span> 이제 데이터가 훨씬 명확하고 관리하기 쉬워졌습니다. 앞으로 자주 사용하게 될 구조입니다."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "딕셔너리 형식을 확인해볼까요?",
              "content": "생성된 딕셔너리의 내용이 요청과 조금 다르네요. 각 항목을 <span class='font-bold text-teal-300'>`'키': 값,`</span> 형태로 정확히 작성했는지 확인해주세요. 키 이름('username', 'level', 'team')과 값('rookie', 1, '솔루션개발팀')이 맞는지, <span class='font-bold text-teal-300'>콜론(:)</span>과 <span class='font-bold text-teal-300'>쉼표(,)</span>를 빠뜨리지 않았는지도요!"
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, 딕셔너리 생성 오류!",
              "content": "딕셔너리를 만들 때 오류가 발생했어요. 딕셔너리는 `{}` 중괄호를 사용하고, 각 항목은 `'키': 값` 형태로 콜론(:)을 사용해야 해요. 각 항목 사이에는 쉼표(,)를 쓰는 것도 잊지 마세요!"
            }
          }
        },
        {
          "title": "딕셔너리 활용 및 데이터 순회",
          "filename": "profile_update.py",
          "lecture": {
            "character": "profKim",
            "title": "강의 노트: 딕셔너리 활용",
            "keyTakeaway": "딕셔너리는 `my_dict[key] = value`로 데이터를 추가/수정하고, `.items()`와 `for`문으로 모든 데이터를 순회할 수 있습니다.",
            "sandboxCode": "scores = {\"math\": 90, \"english\": 85}\n\n# science 점수 100점을 추가해보세요.\nscores[\"science\"] = 100\nprint(scores)",
            "sections": [
              {
                "heading": "핵심 개념",
                "text": "딕셔너리는 키를 통해 값을 추가, 수정, 삭제할 수 있는 '변경 가능(mutable)'한 자료구조입니다. 또한, 반복문과 함께 사용하여 내부에 저장된 모든 데이터를 효율적으로 처리할 수 있습니다.",
                "code": null
              },
              {
                "heading": "기본 문법",
                "text": "새로운 키에 값을 할당하면 항목이 추가되고, 기존 키에 할당하면 값이 수정됩니다.",
                "code": "my_dict = {\"a\": 1}\n\n# 값 추가 및 수정\nmy_dict[\"b\"] = 2\nmy_dict[\"a\"] = 100\n\n# 값 삭제\ndel my_dict[\"b\"]\n\n# 모든 키-값 쌍 순회\nfor key, value in my_dict.items():\n    print(f\"{key}의 값은 {value}입니다.\")"
              },
              {
                "heading": "활용 사례",
                "text": "사용자의 프로필 정보를 업데이트하거나, 설정 파일의 특정 옵션 값을 변경하고, 저장된 모든 데이터를 화면에 목록 형태로 보여줄 때 사용됩니다.",
                "code": null
              },
              {
                "heading": "주의점 및 팁",
                "text": "`.items()`는 키와 값을 모두 가져옵니다[cite: 2156]. 키만 필요할 때는 `.keys()`, 값만 필요할 때는 `.values()` 메소드를 사용할 수 있습니다. `in` 연산자를 사용하면 특정 키가 딕셔너리에 있는지 확인할 수 있습니다. (예: `if 'username' in my_profile:`) [cite: 2159]",
                "code": null
              }
            ]
          },
          "syntax_key": {
            "syntax_title": "리스트 (List)",
            "syntax_comment": "여러 항목을 순서대로 저장하는 변경 가능한 자료 구조입니다.",
            "systax_code": "servers = [\"sv1\", \"sv2\"]"
          },
          "task": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "프로필 정보 업데이트 및 출력",
            "content": "방금 만든 프로필 딕셔너리에 <span class='font-bold text-yellow-300'>새로운 정보('status': 'online')를 추가</span>해주세요. 그리고, 프로필에 담긴 <span class='font-bold text-yellow-300'>모든 키와 값을 하나씩 출력</span>해서 전체 프로필 정보를 보고서 형태로 보여주는 코드를 작성해주세요."
          },
          "briefing": {
            "character": "sena",
            "subtitle": "직속 선임의 팁",
            "title": "딕셔너리 다루기",
            "content": "딕셔너리에 새 항목 추가는 쉬워요! 첫 번째 `TODO` 빈칸에 <span class='font-bold text-teal-300'>`user_profile['status'] = 'online'`</span> 이라고 입력하면 'status' 이름표에 'online' 값이 저장돼요. 두 번째 `TODO`는 딕셔너리 전체를 출력하는 건데, <span class='font-bold text-teal-300'>`.items()`</span> 메소드를 쓰면 돼요. `for` 루프 빈칸에는 <span class='font-bold text-teal-300'>`user_profile`</span>을, `print()` 빈칸에는 f-string <span class='font-bold text-teal-300'>`f\"{key}: {value}\"`</span>를 넣어서 키와 값을 예쁘게 출력해보세요!"
          },
          "starterCode": "user_profile = {\n    'username': 'rookie',\n    'level': 1,\n    'team': '솔루션개발팀'\n}\n\n# TODO: 1. 아래 빈칸에 'status' 키와 'online' 값을 추가하는 코드를 작성하세요.\n# 형식: 딕셔너리이름['새 키'] = '새 값'\n[''] = ''\n\n# TODO: 2. for 문과 .items() 메소드를 사용하여 딕셔너리의 모든 키와 값을 출력하세요.\n# for ???, ??? in ???.items():\nfor key, value in .items():\n    # TODO: print() 안에 f-string을 사용하여 \"key: value\" 형식으로 출력하세요.\n    print()\n",
          "testCode": "expected_dict = {'username': 'rookie', 'level': 1, 'team': '솔루션개발팀', 'status': 'online'}; exec_globals = {'user_profile': user_profile}; exec(student_code, exec_globals); final_user_profile = exec_globals['user_profile']; assert final_user_profile == expected_dict, f\"'status' 키-값 쌍이 올바르게 추가되지 않았거나 딕셔너리의 내용이 다릅니다. 기대값: {expected_dict}, 실제값: {final_user_profile}\"; import io; from contextlib import redirect_stdout; f = io.StringIO(); with redirect_stdout(f): exec(student_code, exec_globals); output_lines = set(line for line in f.getvalue().strip().split('\\n') if ':' in line); expected_lines = set(['username: rookie', 'level: 1', 'team: 솔루션개발팀', 'status: online']); assert output_lines == expected_lines, f'출력된 내용이 기대와 다릅니다. 기대값(순서 무관): {expected_lines}, 실제값: {output_lines}'",
          "feedback": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "데이터 처리 완료",
              "content": "<span class='font-bold text-green-300'>정보 추가와 전체 목록 출력이 완벽하게 동작하네요.</span> / <span class='font-bold text-green-300'>함수가 프로필을 올바르게 업데이트하고 출력했습니다.</span> 딕셔너리를 자유자재로 다룰 수 있게 된 것 같습니다. 이 능력은 앞으로 데이터를 다루는 모든 업무의 기초가 될 겁니다."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "코드 내용을 확인해볼까요?",
              "content": "딕셔너리 내용이나 출력 결과가 요청과 조금 다르네요. 항목 추가 시 <span class='font-bold text-teal-300'>`user_profile['status'] = 'online'`</span> 형식을 정확히 사용했나요? `for`문에서는 <span class='font-bold text-teal-300'>`user_profile.items()`</span>를 호출하고, `print()` 안에서 f-string <span class='font-bold text-teal-300'>`f\"{key}: {value}\"`</span> 형식을 올바르게 사용했는지 확인해주세요."
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, 딕셔너리 또는 루프 오류!",
              "content": "코드를 실행하다가 오류가 발생했어요. 딕셔너리에 항목을 추가할 때 `my_dict['key'] = value` 형식을 사용했나요? `for`문 구문인 `for key, value in my_dict.items():` 에서 오타가 난 건 아닐까요? `.items()` 메소드를 호출할 때 괄호`()`를 빠뜨리는 실수도 자주 하니 확인해보세요!"
            }
          },
          "task_adv": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "프로필 업데이트 및 출력 함수 완성",
            "content": "프로필 정보를 업데이트하고 출력하는 `update_and_print_profile` 함수를 완성해야 합니다. 함수 내부 로직을 구현하여, <span class='font-bold text-yellow-300'>입력받은 딕셔너리에 상태 정보(`status_value`)를 추가</span>하고, <span class='font-bold text-yellow-300'>업데이트된 딕셔너리의 모든 키-값 쌍을 지정된 형식으로 출력</span>하도록 만들어주세요."
          },
          "briefing_adv": {
            "character": "sena",
            "subtitle": "직속 선임의 팁",
            "title": "딕셔너리 수정하고 순회하기",
            "content": "함수가 받은 딕셔너리(`profile_dict`)에 새 항목을 추가하는 건 <span class='font-bold text-teal-300'>`profile_dict['status'] = status_value`</span> 처럼 하면 돼요. 그리고 나서 딕셔너리의 모든 내용을 출력하려면, <span class='font-bold text-teal-300'>`for key, value in profile_dict.items():`</span> 루프 안에서 `print(f\"{key}: {value}\")`를 사용하면 되겠죠?"
          },
          "starterCode_adv": "# 아래 함수는 프로필 딕셔너리를 받아 상태 정보를 추가하고 전체 정보를 출력합니다.\n# TODO: 1. 함수 본문에서 profile_dict에 'status' 키와 status_value 값을 추가하세요.\n# TODO: 2. for 루프와 .items()를 사용하여 업데이트된 profile_dict의 모든 키와 값을 출력하세요.\ndef update_and_print_profile(profile_dict, status_value):\n    # 여기에 상태 정보 추가 코드 작성\n    profile_dict['status'] = status_value\n\n    print(\"--- User Profile ---\")\n    # 여기에 for 루프를 사용하여 전체 정보 출력 코드 작성\n    for key, value in profile_dict.items():\n        print(f\"{key}: {value}\")\n    print(\"--------------------\")\n\n# 함수 호출 (수정 불필요)\nuser_profile = {'username': 'rookie', 'level': 1, 'team': '솔루션개발팀'}\nupdate_and_print_profile(user_profile, 'online')\n",
          "testCode_adv": "import io; from contextlib import redirect_stdout; assert callable(update_and_print_profile), 'update_and_print_profile 함수가 정의되지 않았습니다.'; f = io.StringIO(); user_profile_copy = {'username': 'rookie', 'level': 1, 'team': '솔루션개발팀'}; with redirect_stdout(f): update_and_print_profile(user_profile_copy, 'online'); output = f.getvalue().strip().split('\\n'); expected_dict_after = {'username': 'rookie', 'level': 1, 'team': '솔루션개발팀', 'status': 'online'}; assert user_profile_copy == expected_dict_after, '함수 호출 후 딕셔너리에 status 정보가 올바르게 추가되지 않았습니다.'; output_lines_filtered = [line for line in output if ':' in line]; expected_output_lines = ['username: rookie', 'level: 1', 'team: 솔루션개발팀', 'status: online']; assert output_lines_filtered == expected_output_lines, f'출력 결과 중 키-값 쌍 부분이 기대와 다릅니다.\\n기대값:\\n{chr(10).join(expected_output_lines)}\\n실제값:\\n{chr(10).join(output_lines_filtered)}'",
          "feedback_adv": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "데이터 처리 완료",
              "content": "<span class='font-bold text-green-300'>정보 추가와 전체 목록 출력이 완벽하게 동작하네요.</span> / <span class='font-bold text-green-300'>함수가 프로필을 올바르게 업데이트하고 출력했습니다.</span> 딕셔너리를 자유자재로 다룰 수 있게 된 것 같습니다. 이 능력은 앞으로 데이터를 다루는 모든 업무의 기초가 될 겁니다."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "코드 내용을 확인해볼까요?",
              "content": "딕셔너리 내용이나 출력 결과가 요청과 조금 다르네요. 항목 추가 시 <span class='font-bold text-teal-300'>`user_profile['status'] = 'online'`</span> 형식을 정확히 사용했나요? `for`문에서는 <span class='font-bold text-teal-300'>`user_profile.items()`</span>를 호출하고, `print()` 안에서 f-string <span class='font-bold text-teal-300'>`f\"{key}: {value}\"`</span> 형식을 올바르게 사용했는지 확인해주세요."
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, 딕셔너리 또는 루프 오류!",
              "content": "코드를 실행하다가 오류가 발생했어요. 딕셔너리에 항목을 추가할 때 `my_dict['key'] = value` 형식을 사용했나요? `for`문 구문인 `for key, value in my_dict.items():` 에서 오타가 난 건 아닐까요? `.items()` 메소드를 호출할 때 괄호`()`를 빠뜨리는 실수도 자주 하니 확인해보세요!"
            }
          }
        },
        {
          "title": "중복 없는 데이터, 집합(Set)",
          "filename": "event_manager.py",
          "lecture": {
            "character": "profKim",
            "title": "강의 노트: 집합 (Set)",
            "keyTakeaway": "집합(Set)은 `set()`으로 만들며, 데이터의 중복을 자동으로 제거하고 순서가 없는 자료구조입니다.",
            "sandboxCode": "numbers = [10, 20, 30, 20, 10]\n\n# numbers 리스트의 중복을 제거한 결과를 출력해보세요.\nunique_numbers = set(numbers)\nprint(unique_numbers)",
            "sections": [
              {
                "heading": "핵심 개념",
                "text": "집합(Set)은 두 가지 중요한 특징을 가진 자료구조입니다. 첫째, **순서가 없고**, 둘째, **중복된 값을 허용하지 않습니다.** [cite: 2242] 이 특징 덕분에 데이터의 중복을 제거하거나, 두 데이터 묶음 간의 관계(합집합, 교집합 등)를 계산할 때 매우 유용합니다.",
                "code": null
              },
              {
                "heading": "기본 문법",
                "text": "`set()` 함수를 이용해 다른 자료구조(리스트 등)로부터 집합을 만들 수 있습니다[cite: 2244].",
                "code": "# 리스트를 집합으로 변환하여 중복 제거\ndup_list = [1, 2, 2, 3, 3, 3]\nunique_set = set(dup_list) # {1, 2, 3}\n\n# 두 집합의 합집합\nset_a = {1, 2, 3}\nset_b = {3, 4, 5}\nunion_set = set_a | set_b # {1, 2, 3, 4, 5}"
              },
              {
                "heading": "활용 사례",
                "text": "로그 데이터에서 순수한 방문자(IP 주소) 수 계산, 설문조사 응답 항목의 종류 파악, 두 사용자 그룹의 공통 관심사 찾기 등 데이터의 유일성(uniqueness)이 중요할 때 사용됩니다.",
                "code": null
              },
              {
                "heading": "주의점 및 팁",
                "text": "집합은 순서가 없으므로, 인덱싱(`my_set[0]`)으로 항목에 접근할 수 없습니다. 빈 집합을 만들 때는 `my_set = set()`을 사용해야 합니다. `{}`는 빈 딕셔너리를 의미합니다.",
                "code": null
              }
            ]
          },
          "syntax_key": {
            "syntax_title": "리스트 (List)",
            "syntax_comment": "여러 항목을 순서대로 저장하는 변경 가능한 자료 구조입니다.",
            "systax_code": "servers = [\"sv1\", \"sv2\"]"
          },
          "task": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "중복 참여자 제거",
            "content": "마케팅팀에서 이벤트 참여자 명단을 두 개(`event_A`, `event_B`) 전달했는데, 중복 인원이 많습니다. <span class='font-bold text-yellow-300'>두 명단을 합친 후, 중복된 사람을 제거</span>하여 <span class='font-bold text-yellow-300'>'순수한 전체 참여자' 명단(집합)</span>을 만들어주세요."
          },
          "briefing": {
            "character": "sena",
            "subtitle": "직속 선임의 팁",
            "title": "중복 제거 마법, 집합(Set)!",
            "content": "리스트에서 중복을 없애고 싶을 때 <span class='font-bold text-teal-300'>집합(Set)</span>을 쓰면 정말 편해요! 집합은 알아서 중복을 제거해주거든요[cite: 2242]. `starterCode`의 첫 번째 빈칸에는 <span class='font-bold text-teal-300'>`event_A + event_B`</span>를 넣어 두 리스트를 하나로 합치세요. 그 다음 빈칸에는 합쳐진 리스트(`combined_list`)를 <span class='font-bold text-teal-300'>`set()` 함수</span>로 감싸 <span class='font-bold text-teal-300'>`set(combined_list)`</span>처럼 입력하면, 중복이 사라진 마법 같은 결과가 나올 거예요!"
          },
          "starterCode": "event_A = ['alex', 'sena', 'kim', 'alex']\nevent_B = ['alex', 'chris', 'sena', 'david']\n\n# TODO: 1. '=' 오른쪽에 event_A와 event_B 리스트를 더하는(+) 식을 작성하세요.\ncombined_list = \n\n# TODO: 2. '=' 오른쪽에 set() 함수를 사용하여 combined_list를 집합으로 변환하는 코드를 작성하세요.\nunique_participants = \n\n# 아래는 테스트용 코드입니다. 수정하지 마세요.\n# 결과를 보기 쉽게 리스트로 변환 후 정렬하여 출력합니다.\nif unique_participants:\n    print(sorted(list(unique_participants)))\n",
          "testCode": "assert 'unique_participants' in locals(), \"'unique_participants' 변수가 정의되지 않았습니다.\"; expected = {'alex', 'sena', 'kim', 'chris', 'david'}; assert isinstance(unique_participants, set) and unique_participants == expected, f\"중복 제거된 참여자 명단(집합)이 기대와 다릅니다. 기대값: {expected}, 실제값: {unique_participants}\"",
          "feedback": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "데이터 정제 완료",
              "content": "<span class='font-bold text-green-300'>중복 참여자가 완벽하게 제거되었네요.</span> / <span class='font-bold text-green-300'>함수가 고유 참여자 집합을 정확히 반환했습니다.</span> 집합을 사용하니 코드가 정말 간결해졌죠? 상황에 맞는 자료구조를 선택하는 것이 실력 있는 개발자의 모습입니다."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "순서를 확인해볼까요?",
              "content": "최종 참여자 명단(집합)이 예상과 다르네요. 먼저 두 리스트를 `+` 연산자로 하나로 합치고 (`combined_list = event_A + event_B`), 그 다음에 `set()` 함수를 사용해서 집합으로 변환(`unique_participants = set(combined_list)`)했는지 순서를 확인해주세요."
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, 집합 변환 오류!",
              "content": "코드를 실행하다가 오류가 발생했어요. 리스트를 집합으로 바꿀 때는 `set(리스트이름)`처럼 `set()` 함수를 사용해야 해요. 혹시 괄호를 빠뜨리거나 잘못 사용한 건 아닌지 확인해볼까요?"
            }
          },
          "task_adv": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "고유 참여자 확인 함수 완성",
            "content": "두 개의 참여자 목록을 받아 고유 참여자 집합을 반환하는 `get_unique_attendees` 함수를 완성해야 합니다. 함수 내부 로직을 구현하여, <span class='font-bold text-yellow-300'>두 리스트를 하나로 합치고, `set()`을 사용하여 중복을 제거</span>한 후 최종 집합을 반환하도록 만들어주세요."
          },
          "briefing_adv": {
            "character": "sena",
            "subtitle": "직속 선임의 팁",
            "title": "합치고 변환하기!",
            "content": "함수 안에서 두 리스트(`list1`, `list2`)를 받으면, 먼저 <span class='font-bold text-teal-300'>`+` 연산자</span>를 써서 하나의 리스트(`combined`)로 합치세요. 그 다음, 이 합쳐진 리스트를 <span class='font-bold text-teal-300'>`set()` 함수</span>에 넣어주면 중복이 제거된 집합(`unique_set`)이 만들어져요[cite: 2244]. 이 집합을 `return` 해주면 됩니다!"
          },
          "starterCode_adv": "# 아래 함수는 두 개의 참여자 목록을 받아 중복을 제거한 전체 참여자 집합을 반환합니다.\n# TODO: 함수 본문에서 list1과 list2를 합친 후, 집합(set)으로 변환하여 중복을 제거하고 반환하세요.\ndef get_unique_attendees(list1, list2):\n    # 여기에 코드 작성\n    combined = list1 + list2\n    unique_set = set(combined)\n    return unique_set\n\n# 함수 호출 및 결과 확인 (수정 불필요)\nevent_A = ['alex', 'sena', 'kim', 'alex']\nevent_B = ['alex', 'chris', 'sena', 'david']\nunique_participants = get_unique_attendees(event_A, event_B)\nprint(sorted(list(unique_participants)))\n",
          "testCode_adv": "assert callable(get_unique_attendees), 'get_unique_attendees 함수가 정의되지 않았습니다.'; list1 = ['a', 'b', 'a']; list2 = ['b', 'c']; result = get_unique_attendees(list1, list2); expected = {'a', 'b', 'c'}; assert isinstance(result, set) and result == expected, f'함수가 반환한 집합의 내용이 기대와 다릅니다. 기대값: {expected}, 실제값: {result}'; event_A = ['alex', 'sena', 'kim', 'alex']; event_B = ['alex', 'chris', 'sena', 'david']; expected_global = {'alex', 'sena', 'kim', 'chris', 'david'}; assert 'unique_participants' in locals() and unique_participants == expected_global, '전역 변수 unique_participants 값이 올바르지 않습니다.'",
          "feedback_adv": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "데이터 정제 완료",
              "content": "<span class='font-bold text-green-300'>중복 참여자가 완벽하게 제거되었네요.</span> / <span class='font-bold text-green-300'>함수가 고유 참여자 집합을 정확히 반환했습니다.</span> 집합을 사용하니 코드가 정말 간결해졌죠? 상황에 맞는 자료구조를 선택하는 것이 실력 있는 개발자의 모습입니다."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "순서를 확인해볼까요?",
              "content": "최종 참여자 명단(집합)이 예상과 다르네요. 먼저 두 리스트를 `+` 연산자로 하나로 합치고 (`combined_list = event_A + event_B`), 그 다음에 `set()` 함수를 사용해서 집합으로 변환(`unique_participants = set(combined_list)`)했는지 순서를 확인해주세요."
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, 집합 변환 오류!",
              "content": "코드를 실행하다가 오류가 발생했어요. 리스트를 집합으로 바꿀 때는 `set(리스트이름)`처럼 `set()` 함수를 사용해야 해요. 혹시 괄호를 빠뜨리거나 잘못 사용한 건 아닌지 확인해볼까요?"
            }
          }
        }
      ]
    },
    {
      "week": 7,
      "title": "모듈화 및 중간 점검: 나만의 유틸리티 모듈 만들기",
      "cycles": [
        {
          "title": "코드 분리의 시작, 모듈(Module)",
          "filename": "main.py",
          "lecture": {
            "character": "profKim",
            "title": "강의 노트: 모듈 (Module)",
            "keyTakeaway": "모듈은 함수 등을 모아놓은 `.py` 파일이며, `import` 키워드로 불러와 재사용할 수 있습니다.",
            "sandboxCode": "# 아래는 가상의 my_utils.py 모듈입니다.\ndef say_hello(name):\n    print(f\"{name}님, 안녕하세요!\")\n\n# my_utils 모듈의 say_hello 함수를 호출해보세요.\nsay_hello(\"신입사원\")",
            "sections": [
              {
                "heading": "핵심 개념",
                "text": "모듈(Module)이란 함수, 변수, 클래스를 모아놓은 파이썬 파일(`.py`)입니다[cite: 1799, 1887]. 모듈화는 코드를 기능별로 분리하여 관리할 수 있게 해주므로, 코드의 재사용성과 유지보수성을 크게 향상시킵니다.",
                "code": null
              },
              {
                "heading": "기본 문법",
                "text": "다른 파일(모듈)에 있는 기능을 사용하려면 `import` 문을 사용해야 합니다.",
                "code": "# my_module.py 파일의 함수를 가져올 때\n\n# 방법 1: 모듈 전체를 가져오기\nimport my_module\nmy_module.my_function()\n\n# 방법 2: 모듈에서 특정 함수만 가져오기\nfrom my_module import my_function\nmy_function()"
              },
              {
                "heading": "활용 사례",
                "text": "사용자 인증 관련 함수들을 `auth.py`로, 데이터베이스 처리 함수들을 `database.py`로 분리하여 프로젝트 구조를 체계적으로 관리하는 등 모든 실제 프로젝트에서 필수적으로 사용됩니다.",
                "code": null
              },
              {
                "heading": "주의점 및 팁",
                "text": "다른 사람이 만든 유용한 모듈(라이브러리)도 `import`하여 사용할 수 있습니다. `from 모듈 import *` 방식은 이름 충돌 가능성이 있어 권장하지 않습니다. `if __name__ == '__main__':` 구문을 사용하면 모듈로 사용될 때와 직접 실행될 때를 구분할 수 있습니다 [cite: 1870-1871].",
                "code": null
              }
            ]
          },
          "syntax_key": {
            "syntax_title": "print()",
            "syntax_comment": "`print()`는 괄호 안의 값을 화면에 출력하는 내장 함수입니다.",
            "systax_code": "print(\"Hello World\")"
          },
          "task": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "코드 정리 및 모듈화",
            "content": "다른 파일(`string_utils.py`)에 문자열을 뒤집는 `reverse_string` 함수가 정의되어 있다고 가정합니다. 현재 파일에서 <span class='font-bold text-yellow-300'>`string_utils` 모듈을 불러오고(import)</span>, 이 모듈의 <span class='font-bold text-yellow-300'>`reverse_string` 함수를 호출</span>하여 \"Hello\" 문자열을 뒤집은 결과를 `reversed_text` 변수에 저장해주세요."
          },
          "briefing": {
            "character": "sena",
            "subtitle": "직속 선임의 OJT",
            "title": "다른 파일 코드 빌려오기: `import`",
            "content": "다른 파이썬 파일에 있는 함수를 쓰려면 먼저 <span class='font-bold text-teal-300'>`import`</span> 라는 명령어로 불러와야 해요. `starterCode`의 첫 번째 빈칸에 <span class='font-bold text-teal-300'>`import string_utils`</span> 라고 입력해보세요. 그럼 이제 `string_utils` 파일 안의 기능을 쓸 수 있어요! 두 번째 빈칸에는 <span class='font-bold text-teal-300'>`string_utils.reverse_string(\"Hello\")`</span> 라고 입력해서 함수를 호출하면 됩니다. <span class='font-bold text-teal-300'>`모듈이름.함수이름()`</span> 형태로 쓰는 거죠!"
          },
          "starterCode": "# --- string_utils.py (별도 파일이라고 가정) ---\n# def reverse_string(s):\n#     return s[::-1]\n# -------------------------------------\n\n# TODO: 1. 아래 빈칸에 'string_utils' 모듈을 불러오는(import) 코드를 작성하세요.\n\n\n# TODO: 2. '=' 오른쪽에 string_utils 모듈의 reverse_string 함수를 호출하여 \"Hello\"를 뒤집는 코드를 작성하세요.\n# 형식: 모듈이름.함수이름(인자)\nreversed_text = \n\n# 아래는 테스트용 코드입니다. 수정하지 마세요.\nprint(reversed_text)\n",
          "testCode": "import builtins; from unittest.mock import MagicMock; string_utils_mock = MagicMock(); string_utils_mock.reverse_string.return_value = 'olleH'; original_import = builtins.__import__; imported_modules = {}; def import_mock(name, *args, **kwargs): if name == 'string_utils': imported_modules['string_utils'] = True; return string_utils_mock; else: return original_import(name, *args, **kwargs); builtins.__import__ = import_mock; student_globals = {'__builtins__': builtins}; exec(student_code, student_globals); builtins.__import__ = original_import; assert imported_modules.get('string_utils'), \"'string_utils' 모듈을 import 하지 않았습니다.\"; assert 'reversed_text' in student_globals, 'reversed_text 변수가 없습니다.'; assert student_globals['reversed_text'] == 'olleH', f'문자열 뒤집기 결과가 다릅니다. 기대값: olleH, 실제값: {student_globals[\"reversed_text\"]}'; string_utils_mock.reverse_string.assert_called_with('Hello'), 'string_utils.reverse_string 함수가 올바른 인자(\"Hello\")로 호출되지 않았습니다.'",
          "feedback": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "모듈 활용 성공",
              "content": "<span class='font-bold text-green-300'>모듈을 성공적으로 불러와서 함수/상수를 사용했군요.</span> 좋습니다. 이렇게 코드를 기능별로 분리하고 재사용하는 것은 협업과 유지보수에 매우 중요합니다."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "import나 함수 호출을 확인해보세요",
              "content": "모듈을 불러오지 못했거나 함수 호출 결과가 다른 것 같아요. 첫 번째 빈칸에 <span class='font-bold text-teal-300'>`import string_utils`</span>를 정확히 입력했나요? 두 번째 빈칸에는 <span class='font-bold text-teal-300'>`string_utils.reverse_string(\"Hello\")`</span> 처럼 모듈 이름, 점(.), 함수 이름, 괄호와 인자까지 올바르게 입력했는지 확인해주세요."
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, Import 또는 Name Error!",
              "content": "모듈을 가져오지 못했거나(`ImportError`), 모듈의 함수/변수 이름을 잘못 사용한 것 같아요(`NameError`). `import 모듈이름` 구문에 오타는 없는지, 함수나 변수 이름 앞에 `모듈이름.`을 붙여서 사용했는지 확인해주세요."
            }
          },
          "task_adv": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "외부 모듈 활용 계산",
            "content": "별도의 `math_utils.py` 파일에 원주율 상수 `PI`와 원의 넓이를 구하는 `circle_area` 함수가 정의되어 있다고 가정합니다. 현재 파일에서 <span class='font-bold text-yellow-300'>`math_utils` 모듈을 불러오고</span>, 이 모듈의 <span class='font-bold text-yellow-300'>`PI` 상수와 `circle_area` 함수</span>를 사용하여 반지름이 5인 원의 넓이를 계산하고 결과를 `area` 변수에 저장해주세요."
          },
          "briefing_adv": {
            "character": "sena",
            "subtitle": "직속 선임의 팁",
            "title": "모듈의 변수와 함수 활용",
            "content": "다른 파일에 있는 변수(상수)나 함수를 사용하려면 먼저 <span class='font-bold text-teal-300'>`import 모듈이름`</span>으로 불러와야 해요. 그 다음엔 <span class='font-bold text-teal-300'>`모듈이름.변수이름`</span>이나 <span class='font-bold text-teal-300'>`모듈이름.함수이름(인자)`</span> 형태로 사용하면 됩니다. `circle_area` 함수는 반지름 값을 인자로 받으니, `radius` 변수를 넘겨주면 되겠네요!"
          },
          "starterCode_adv": "# --- math_utils.py (별도 파일이라고 가정) ---\n# PI = 3.14159\n# def circle_area(radius):\n#     return PI * radius * radius\n# -------------------------------------\n\n# TODO: 1. 위 가상 모듈 파일에 있는 math_utils 모듈을 import 하세요.\nimport math_utils\n\n# TODO: 2. math_utils 모듈의 PI 상수와 circle_area 함수를 사용하여\n#         반지름(radius)이 5인 원의 넓이를 계산하고 'area' 변수에 저장하세요.\n\nradius = 5\n# 여기에 area 계산 코드 작성 (예: area = math_utils.PI * ...) -> 아래 수정됨\narea = math_utils.circle_area(radius)\n\n# 아래는 테스트용 코드입니다. 수정하지 마세요.\nprint(f\"반지름 {radius}인 원의 넓이: {area}\")\n",
          "testCode_adv": "import builtins; from unittest.mock import MagicMock; math_utils_mock = MagicMock(); math_utils_mock.PI = 3.14159; math_utils_mock.circle_area.return_value = 78.53975; original_import = builtins.__import__; imported_modules = {}; def import_mock(name, *args, **kwargs): if name == 'math_utils': imported_modules['math_utils'] = True; return math_utils_mock; else: return original_import(name, *args, **kwargs); builtins.__import__ = import_mock; student_globals = {'__builtins__': builtins}; exec(student_code, student_globals); builtins.__import__ = original_import; assert imported_modules.get('math_utils'), \"'math_utils' 모듈을 import 하지 않았습니다.\"; assert 'area' in student_globals, 'area 변수가 없습니다.'; assert abs(student_globals['area'] - 78.53975) < 0.001, f'원의 넓이 계산 결과가 다릅니다. 기대값: 78.53975, 실제값: {student_globals[\"area\"]}'; math_utils_mock.circle_area.assert_called_with(5), 'math_utils.circle_area 함수가 올바른 인자(5)로 호출되지 않았습니다.'",
          "feedback_adv": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "모듈 활용 성공",
              "content": "<span class='font-bold text-green-300'>모듈을 성공적으로 불러와서 함수/상수를 사용했군요.</span> 좋습니다. 이렇게 코드를 기능별로 분리하고 재사용하는 것은 협업과 유지보수에 매우 중요합니다."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "import나 함수 호출을 확인해보세요",
              "content": "모듈을 불러오지 못했거나 함수 호출 결과가 다른 것 같아요. 첫 번째 빈칸에 <span class='font-bold text-teal-300'>`import string_utils`</span>를 정확히 입력했나요? 두 번째 빈칸에는 <span class='font-bold text-teal-300'>`string_utils.reverse_string(\"Hello\")`</span> 처럼 모듈 이름, 점(.), 함수 이름, 괄호와 인자까지 올바르게 입력했는지 확인해주세요."
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, Import 또는 Name Error!",
              "content": "모듈을 가져오지 못했거나(`ImportError`), 모듈의 함수/변수 이름을 잘못 사용한 것 같아요(`NameError`). `import 모듈이름` 구문에 오타는 없는지, 함수나 변수 이름 앞에 `모듈이름.`을 붙여서 사용했는지 확인해주세요."
            }
          }
        },
        {
          "title": "미니 프로젝트 설계 (파일 백업 스크립트)",
          "filename": "design_document.txt",
          "lecture": {
            "character": "profKim",
            "title": "강의 노트: 소프트웨어 개발 단계",
            "keyTakeaway": "문제를 해결하기 전에, 먼저 필요한 기능들을 단계별로 나누어 '설계'하는 습관이 중요합니다.",
            "sandboxCode": "import time\n\n# 현재 시간을 '년월일시분초' 형태의 문자열로 출력해보세요.\n# 예: 20251001113059\nprint(time.strftime('%Y%m%d%H%M%S'))",
            "sections": [
              {
                "heading": "핵심 개념",
                "text": "훌륭한 프로그램은 무작정 코드를 짜는 것이 아니라, 체계적인 단계를 거쳐 만들어집니다. '무엇을 만들까(분석)' → '어떻게 만들까(설계)' → '코드로 구현' → '오류 수정(테스트/디버깅)'의 과정을 거치는 것이 중요합니다 [cite: 2431-2433].",
                "code": null
              },
              {
                "heading": "유용한 도구 (모듈)",
                "text": "파일 경로를 다루거나 시스템 명령어를 실행할 때는 `os` 모듈, 시간 정보를 다룰 때는 `time` 모듈이 필수적입니다.",
                "code": "# 운영체제(Operating System) 기능 사용\nimport os\n# 폴더 존재 확인: os.path.exists('folder')\n# 폴더 생성: os.mkdir('new_folder')\n# 경로 구분자: os.sep\n# 시스템 명령어 실행: os.system('zip ...')\n\n# 시간 관련 기능 사용\nimport time\n# 현재 시간을 형식에 맞춰 문자열로: time.strftime('%Y%m%d%H%M%S')"
              },
              {
                "heading": "활용 사례",
                "text": "지금 만들려는 '파일 백업 스크립트' 자체가 모든 개념을 종합적으로 활용하는 훌륭한 사례입니다.",
                "code": null
              },
              {
                "heading": "주의점 및 팁",
                "text": "운영체제마다 파일 경로 구분자가 다를 수 있습니다 (`os.sep` 사용 권장) [cite: 2352-2353]. 사용자 입력을 받을 때는 어떤 종류의 입력이 들어올지 고려해야 합니다.",
                "code": null
              }
            ]
          },
          "syntax_key": {
            "syntax_title": "print()",
            "syntax_comment": "`print()`는 괄호 안의 값을 화면에 출력하는 내장 함수입니다.",
            "systax_code": "print(\"Hello World\")"
          },
          "task": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "자동 백업 스크립트 개발 프로젝트 (설계)",
            "content": "미니 프로젝트 시간입니다! <span class='font-bold text-yellow-300'>중요 파일을 지정된 폴더에 ZIP 파일로 압축 백업</span>하는 스크립트를 만들려고 합니다. 이번 단계에서는 코딩 대신, <span class='font-bold text-yellow-300'>스크립트가 어떻게 동작해야 할지 구체적인 계획(설계)</span>을 세워주세요. 어떤 파일들을, 어디에, 어떤 이름 규칙으로 백업할지, 어떤 도구(모듈/함수)를 사용할지 등을 정리해야 합니다."
          },
          "briefing": {
            "character": "sena",
            "subtitle": "직속 선임의 팁",
            "title": "코딩 전에 계획부터!",
            "content": "백업 스크립트! 아주 유용하겠네요. 코딩 전에 계획부터 세우면 좋아요. `starterCode`에 있는 질문들에 답하면서 계획을 구체화해보세요. <span class='font-bold text-teal-300'>`os` 모듈</span>로는 폴더를 만들거나 명령어를 실행할 수 있고, <span class='font-bold text-teal-300'>`time` 모듈</span>로는 현재 날짜와 시간으로 파일 이름을 만들 수 있을 거예요. 어떤 파일/폴더를 백업할지, 어디에 저장할지 등을 자유롭게 적어보세요!"
          },
          "starterCode": "# 이 파일에 백업 스크립트의 설계도를 자유롭게 작성해주세요.\n# 아래 질문에 답하는 형식으로 계획을 세워보면 좋습니다.\n\n# 1. 백업 대상: 어떤 파일이나 폴더를 백업할 건가요?\n#   (예: '/Users/내이름/문서' 폴더)\n#\n\n# 2. 백업 저장 위치: 백업 파일을 어디에 저장할 건가요?\n#   (예: '/Users/내이름/백업' 폴더)\n#\n\n# 3. 백업 파일 이름 규칙: 백업 파일 이름은 어떻게 만들까요?\n#   (예: 오늘 날짜와 시간 사용 - '20251025160000.zip')\n#\n\n# 4. 구현 단계: 어떤 순서로 코드를 만들면 좋을까요?\n#    - 필요한 모듈 가져오기 (os, time)\n#    - 백업 대상, 저장 위치 변수에 저장하기\n#    - 백업 파일 이름 만들기\n#    - 백업 명령어 만들기 (zip 명령어 사용)\n#    - 백업 실행하고 결과 출력하기\n\n# 5. 사용할 모듈/함수: 어떤 도구들을 사용할 계획인가요?\n#    - os 모듈: 경로 다루기(os.sep), 폴더 확인/생성(os.path.exists, os.mkdir), 명령어 실행(os.system)\n#    - time 모듈: 현재 날짜/시간 가져오기(time.strftime)\n",
          "testCode": "assert True, \"설계 단계는 개념적인 과제입니다.\"",
          "feedback": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "프로젝트 설계 승인",
              "content": "<span class='font-bold text-green-300'>훌륭한 설계입니다.</span> 문제 해결에 필요한 절차와 사용할 도구를 정확히 파악했군요. / <span class='font-bold text-green-300'>개선 요구사항이 설계에 잘 반영되었습니다.</span> 이 설계안대로라면 충분히 좋은 결과물이 나올 것 같습니다. 이제 계획에 따라 구현을 시작해주세요."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "설계 검토",
              "title": "조금만 더 구체적으로!",
              "content": "좋은 시작이에요! 하지만 몇몇 부분이 조금 막연하네요. 예를 들어 '파일 이름 만들기' 부분에 구체적으로 어떤 모듈의 어떤 함수를 사용할지 (`time.strftime` 등) 명시해주면 설계가 더 명확해질 거예요. 어떤 오류가 발생할 수 있을지 미리 생각해보는 것도 좋아요!"
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "설계 검토",
              "title": "여기는 계획 단계!",
              "content": "이 단계는 코딩이 아니라 설계 문서를 작성하는 단계예요. 오류가 발생할 리 없는데... 혹시 코드 대신 설계 계획을 잘 작성해주셨는지 다시 확인해볼까요? `starterCode`에 있는 질문들에 답하는 형식으로 자유롭게 적어주시면 됩니다."
            }
          },
          "task_adv": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "백업 스크립트 개선 설계",
            "content": "기존 백업 스크립트 설계를 개선하려고 합니다. <span class='font-bold text-yellow-300'>날짜별 하위 폴더</span>에 백업 파일을 저장하고, 파일 이름에는 <span class='font-bold text-yellow-300'>시간 정보와 함께 사용자가 입력한 코멘트</span>를 포함시키고 싶습니다. 이 요구사항을 반영하여 <span class='font-bold text-yellow-300'>기존 설계를 어떻게 수정하고 확장</span>할지 구체적인 계획을 세워주세요."
          },
          "briefing_adv": {
            "character": "sena",
            "subtitle": "직속 선임의 팁",
            "title": "개선점 반영하기",
            "content": "기존 설계에 살을 붙이는 작업이네요! 날짜별 폴더는 <span class='font-bold text-teal-300'>`time.strftime('%Y%m%d')`</span> 같은 걸로 만들고, <span class='font-bold text-teal-300'>`os.path.exists()`와 `os.mkdir()`</span>로 폴더가 있는지 확인하고 없으면 만들면 되겠죠 [cite: 2389-2390]. 사용자 코멘트는 <span class='font-bold text-teal-300'>`raw_input()` (Python 2) 또는 `input()` (Python 3)</span> 함수로 받고, 파일 이름 만들 때 이 코멘트를 포함시키면 되겠네요. 공백 처리(<span class='font-bold text-teal-300'>replace()</span>)도 신경 써야 하고요!"
          },
          "starterCode_adv": "# 이 파일에 개선된 백업 스크립트의 설계도를 작성해주세요.\n\n# 1. 백업 대상 (변경 없음):\n# /Users/swa/notes (예시)\n\n# 2. 백업 저장 위치 (날짜별 하위 폴더 구조 고려):\n# 기본 위치: /Users/swa/backup\n# 최종 위치: /Users/swa/backup/YYYYMMDD/\n\n# 3. 백업 파일 형식 및 이름 규칙 (시간 + 사용자 입력 코멘트 포함):\n# 형식: HHMMSS_코멘트.zip (코멘트 없으면 HHMMSS.zip)\n# 코멘트 내 공백은 밑줄(_)로 변경\n\n# 4. 사용자 입력 처리 (코멘트 입력 및 처리 방법):\n# raw_input() 또는 input()으로 코멘트 입력 받기\n# 입력된 코멘트 문자열에서 공백을 밑줄로 바꾸기 (replace 메소드)\n\n# 5. 구현 단계 (변경된 저장 구조 및 사용자 입력 처리 포함):\n#    - 필요한 모듈 import (os, time)\n#    - 백업 대상/기본 저장 위치 설정\n#    - 오늘 날짜로 하위 폴더 경로 만들기 (time.strftime)\n#    - 하위 폴더 없으면 생성 (os.path.exists, os.mkdir)\n#    - 사용자 코멘트 입력 받기 (raw_input/input)\n#    - 현재 시간과 코멘트로 최종 백업 파일 경로 만들기 (time.strftime, replace)\n#    - zip 명령어 만들기 (format 메소드)\n#    - 백업 실행 및 결과 출력 (os.system)\n\n# 6. 사용할 주요 모듈 및 함수 (기존 + 추가):\n#    - os 모듈: os.sep, os.path.exists, os.mkdir, os.system, (문자열 처리용 os.path.basename 등 고려 가능)\n#    - time 모듈: time.strftime\n#    - (압축 관련): 외부 zip 명령어\n#    - (사용자 입력): raw_input() 또는 input(), 문자열 replace() 메소드\n",
          "testCode_adv": "assert True, \"설계 단계는 개념적인 과제입니다.\"",
          "feedback_adv": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "프로젝트 설계 승인",
              "content": "<span class='font-bold text-green-300'>훌륭한 설계입니다.</span> 문제 해결에 필요한 절차와 사용할 도구를 정확히 파악했군요. / <span class='font-bold text-green-300'>개선 요구사항이 설계에 잘 반영되었습니다.</span> 이 설계안대로라면 충분히 좋은 결과물이 나올 것 같습니다. 이제 계획에 따라 구현을 시작해주세요."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "설계 검토",
              "title": "조금만 더 구체적으로!",
              "content": "좋은 시작이에요! 하지만 몇몇 부분이 조금 막연하네요. 예를 들어 '파일 이름 만들기' 부분에 구체적으로 어떤 모듈의 어떤 함수를 사용할지 (`time.strftime` 등) 명시해주면 설계가 더 명확해질 거예요. 어떤 오류가 발생할 수 있을지 미리 생각해보는 것도 좋아요!"
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "설계 검토",
              "title": "여기는 계획 단계!",
              "content": "이 단계는 코딩이 아니라 설계 문서를 작성하는 단계예요. 오류가 발생할 리 없는데... 혹시 코드 대신 설계 계획을 잘 작성해주셨는지 다시 확인해볼까요? `starterCode`에 있는 질문들에 답하는 형식으로 자유롭게 적어주시면 됩니다."
            }
          }
        },
        {
          "title": "미니 프로젝트 구현 (종합 실습)",
          "filename": "backup.py",
          "lecture": {
            "character": "profKim",
            "title": "교수님의 조언: 통합적 사고",
            "keyTakeaway": "훌륭한 개발자는 많은 것을 아는 사람이 아니라, 아는 것을 잘 연결하여 문제를 해결하는 사람입니다.",
            "sandboxCode": null,
            "sections": [
              {
                "heading": "핵심 조언",
                "text": "이번 사이클은 새로운 지식을 배우기보다, 이미 배운 여러 지식(변수, 리스트, 문자열 포맷팅, `os`/`time` 모듈 사용 등)을 '연결'하고 '조합'하는 능력을 기르는 데 중점을 둡니다. 막힐 때마다 이전 강의 노트나 참고 자료를 적극적으로 활용하여 필요한 도구를 찾아내고, 그것들을 어떻게 엮어야 문제를 해결할 수 있을지 고민해보세요. 이 과정 자체가 훌륭한 학습입니다.",
                "code": null
              }
            ]
          },
          "syntax_key": {
            "syntax_title": "print()",
            "syntax_comment": "`print()`는 괄호 안의 값을 화면에 출력하는 내장 함수입니다.",
            "systax_code": "print(\"Hello World\")"
          },
          "task": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "백업 스크립트 구현 (os.system)",
            "content": "이전 단계에서 승인된 설계안에 따라, <span class='font-bold text-yellow-300'>실제로 동작하는 백업 스크립트</span>를 완성해주세요. 이번 버전에서는 <span class='font-bold text-yellow-300'>`os.system()` 함수</span>를 사용하여 외부 `zip` 명령어를 실행하는 방식으로 구현합니다. 설계 단계에서 정의한 변수와 로직을 코드로 옮겨보세요."
          },
          "briefing": {
            "character": "sena",
            "subtitle": "직속 선임의 팁",
            "title": "설계를 코드로 옮기기!",
            "content": "이제 진짜 코딩 시간! `starterCode`를 보세요. 먼저 1번, 2번 `TODO` 주석에 있는 경로를 실제 백업하고 싶은 폴더 경로로 바꾸세요 (윈도우에서는 경로 구분자 `\\`를 두 번 써야 해요!). 5번 `TODO`가 핵심인데, zip 명령어를 만드는 거예요. 빈칸에 이렇게 입력해보세요: <span class='font-bold text-teal-300'>`f\"zip -r {target} {' '.join(source)}\"`</span>. `f-string`과 `{}` 안에 변수 이름을 넣고, 리스트 `source`를 문자열로 바꾸는 `' '.join()`을 사용했어요. 나머지는 그대로 두면 <span class='font-bold text-teal-300'>`os.system()`</span>이 이 명령어를 실행해 줄 거예요!"
          },
          "starterCode": "import os\nimport time\n\n# 1. 백업 대상 설정 (TODO 부분을 실제 경로로 바꾸세요)\nsource = ['/Users/swa/notes'] # 예: ['C:\\\\Users\\\\내이름\\\\Documents']\n\n# 2. 백업 저장 위치 설정 (TODO 부분을 실제 경로로 바꾸세요)\ntarget_dir = '/Users/swa/backup' # 예: 'D:\\\\Backup'\n\n# 3. 백업 파일 이름 생성 (아래 코드는 수정할 필요 없음)\ntarget = target_dir + os.sep + time.strftime('%Y%m%d%H%M%S') + '.zip'\n\n# 4. 백업 디렉토리 생성 (없으면) (아래 코드는 수정할 필요 없음)\nif not os.path.exists(target_dir):\n    os.mkdir(target_dir)\n\n# 5. zip 명령어 생성\n# TODO: '=' 오른쪽에 zip 명령어를 만드는 f-string을 작성하세요.\n#       형식: f\"zip -r {target 파일 경로} {백업 대상 경로들(공백으로 구분)}\"\n#       (힌트: ' '.join(source) 를 사용하면 리스트를 공백으로 구분된 문자열로 만들 수 있어요)\nzip_command = \n\n# 6. 백업 실행 (아래 코드는 수정할 필요 없음)\nprint(f\"Executing: {zip_command}\")\nif os.system(zip_command) == 0:\n    print('백업 성공!')\nelse:\n    print('백업 실패.')\n",
          "testCode": "import os, time; student_globals = {'os': os, 'time': time}; exec(student_code, student_globals); source = student_globals['source']; target = student_globals['target']; zip_command = student_globals['zip_command']; source_str = ' '.join(source); expected_command_part = f\"zip -r {target} {source_str}\"; assert zip_command == expected_command_part, f\"zip_command 문자열이 올바르지 않습니다.\\n기대값: {expected_command_part}\\n실제값: {zip_command}\"; assert target.startswith(student_globals['target_dir']), \"target 파일 경로가 target_dir로 시작해야 합니다.\"; assert target.endswith('.zip'), \"target 파일명이 .zip으로 끝나야 합니다.\"",
          "feedback": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "첫 프로젝트 성공!",
              "content": "정말 대단합니다. 스크립트가 <span class='font-bold text-green-300'>정상적으로 동작하여 백업 파일을 성공적으로 생성</span>했네요. <span class='font-bold text-green-300'>지난 몇 주간 배운 개념들을 통합하여 실제 문제를 해결</span>해냈습니다. 이것은 ${userName}님의 성장에 있어 매우 중요한 이정표입니다. 진심으로 축하합니다."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "디버깅 지원",
              "title": "zip 명령어 부분을 확인해볼까요?",
              "content": "백업 실행에 실패했네요. 5번 `TODO` 부분에서 zip 명령어를 만드는 f-string을 정확하게 작성했는지 확인해주세요. <span class='font-bold text-teal-300'>`f\"zip -r {target} {' '.join(source)}\"`</span> 형태가 맞는지, 변수 이름(`target`, `source`)에 오타는 없는지, 중괄호 `{}`나 따옴표 `\"` 사용이 올바른지 다시 한번 살펴보세요."
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "디버깅 지원",
              "title": "앗, 코드 실행 오류!",
              "content": "백업을 실행하기도 전에 코드에서 오류가 발생했어요. `time.strftime`, `os.path.exists`, `os.mkdir`, `os.system` 등을 호출할 때 오타가 있진 않았나요? 아니면 문자열을 합치거나 f-string을 사용할 때 문법 오류가 있을 수도 있고요. 오류 메시지를 자세히 읽어보면 힌트를 얻을 수 있을 거예요."
            }
          },
          "task_adv": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "백업 스크립트 구현 (zipfile)",
            "content": "설계에 따라 백업 스크립트를 구현합니다. 이번에는 외부 명령어 대신 파이썬의 <span class='font-bold text-yellow-300'>`zipfile` 표준 라이브러리</span>를 사용하여 ZIP 파일을 직접 생성하도록 구현해주세요. 제공된 코드 템플릿의 <span class='font-bold text-yellow-300'>TODO 부분을 완성</span>하여 파일 및 폴더를 압축하는 로직을 구현해야 합니다."
          },
          "briefing_adv": {
            "character": "sena",
            "subtitle": "직속 선임의 팁",
            "title": "`zipfile` 모듈 활용하기",
            "content": "`zipfile` 모듈을 쓰면 파이썬 코드만으로 압축 파일을 만들 수 있어요! <span class='font-bold text-teal-300'>`zipfile.ZipFile(파일명, 'w')`</span>로 파일을 열고, `zipf.write(원본파일경로, 압축파일내경로)` 형태로 파일을 추가하면 돼요. 폴더 전체를 추가하려면 <span class='font-bold text-teal-300'>`os.walk`</span>를 써서 폴더 안의 모든 파일을 찾아서 하나씩 `write` 해줘야 하는 점이 조금 복잡할 수 있어요. `os.path.basename`으로 파일 이름만 추출하는 것도 필요하고요!"
          },
          "starterCode_adv": "import os\nimport time\nimport zipfile # zipfile 모듈 사용\n\n# 1. 백업 대상 설정\nsource = ['/Users/swa/notes'] # TODO: 실제 백업할 폴더 경로로 변경하세요.\n\n# 2. 백업 저장 위치 설정\ntarget_dir = '/Users/swa/backup' # TODO: 백업 파일을 저장할 폴더 경로로 변경하세요.\n\n# 3. 백업 파일 이름 생성 (날짜와 시간 사용)\ntarget = target_dir + os.sep + time.strftime('%Y%m%d%H%M%S') + '.zip'\n\n# 4. 백업 디렉토리 생성 (없으면)\nif not os.path.exists(target_dir):\n    os.mkdir(target_dir)\n\n# 5. zipfile 모듈을 사용하여 백업 실행\nprint(f\"Creating zip archive: {target}\")\ntry:\n    # TODO: zipfile.ZipFile을 사용하여 target 파일을 쓰기 모드('w')로 여세요 (별명: zipf).\n    with zipfile.ZipFile(target, 'w') as zipf:\n        for item in source:\n            if os.path.exists(item):\n                if os.path.isdir(item):\n                    # TODO: 폴더인 경우, 내부 모든 파일을 zipf.write()를 사용하여 추가하세요.\n                    # (힌트: os.walk 사용)\n                    for foldername, subfolders, filenames in os.walk(item):\n                        for filename in filenames:\n                            filepath = os.path.join(foldername, filename)\n                            # item 경로를 기준으로 상대 경로를 만들어 압축 파일 내 경로로 사용\n                            arcname = os.path.relpath(filepath, os.path.dirname(item))\n                            zipf.write(filepath, arcname)\n                else:\n                    # TODO: 파일인 경우, zipf.write()를 사용하여 파일 이름(basename)으로 압축 파일에 추가하세요.\n                    zipf.write(item, os.path.basename(item))\n            else:\n                print(f\"경고: {item} 을(를) 찾을 수 없습니다.\")\n    print('백업 성공!')\nexcept Exception as e:\n    print(f'백업 실패: {e}')\n",
          "testCode_adv": "import os, zipfile, time; student_globals = {'os': os, 'time': time, 'zipfile': zipfile}; test_source_dir = 'test_backup_source'; os.makedirs(os.path.join(test_source_dir, 'subdir'), exist_ok=True); with open(os.path.join(test_source_dir, 'file1.txt'), 'w') as f: f.write('test1'); with open(os.path.join(test_source_dir, 'subdir', 'file2.txt'), 'w') as f: f.write('test2'); student_globals['source'] = [test_source_dir]; student_globals['target_dir'] = '.'; exec(student_code, student_globals); target_zip = student_globals['target']; assert os.path.exists(target_zip), '백업 zip 파일이 생성되지 않았습니다.'; zf = None; files_in_zip = []; try: zf = zipfile.ZipFile(target_zip, 'r'); files_in_zip = zf.namelist(); assert os.path.join(os.path.basename(test_source_dir), 'file1.txt') in files_in_zip, '루트 폴더의 파일이 zip에 포함되지 않았습니다.'; assert os.path.join(os.path.basename(test_source_dir), 'subdir', 'file2.txt') in files_in_zip, '하위 폴더의 파일이 zip에 포함되지 않았습니다.' except Exception as e: assert False, f'zip 파일 검증 중 오류 발생: {e}' finally: \n    if zf: zf.close()\n    import shutil; shutil.rmtree(test_source_dir, ignore_errors=True)\n    if os.path.exists(target_zip): os.remove(target_zip)",
          "feedback_adv": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "첫 프로젝트 성공!",
              "content": "정말 대단합니다. 스크립트가 <span class='font-bold text-green-300'>정상적으로 동작하여 백업 파일을 성공적으로 생성</span>했네요. <span class='font-bold text-green-300'>지난 몇 주간 배운 개념들을 통합하여 실제 문제를 해결</span>해냈습니다. 이것은 ${userName}님의 성장에 있어 매우 중요한 이정표입니다. 진심으로 축하합니다."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "디버깅 지원",
              "title": "zip 명령어 부분을 확인해볼까요?",
              "content": "백업 실행에 실패했네요. 5번 `TODO` 부분에서 zip 명령어를 만드는 f-string을 정확하게 작성했는지 확인해주세요. <span class='font-bold text-teal-300'>`f\"zip -r {target} {' '.join(source)}\"`</span> 형태가 맞는지, 변수 이름(`target`, `source`)에 오타는 없는지, 중괄호 `{}`나 따옴표 `\"` 사용이 올바른지 다시 한번 살펴보세요."
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "디버깅 지원",
              "title": "앗, 코드 실행 오류!",
              "content": "백업을 실행하기도 전에 코드에서 오류가 발생했어요. `time.strftime`, `os.path.exists`, `os.mkdir`, `os.system` 등을 호출할 때 오타가 있진 않았나요? 아니면 문자열을 합치거나 f-string을 사용할 때 문법 오류가 있을 수도 있고요. 오류 메시지를 자세히 읽어보면 힌트를 얻을 수 있을 거예요."
            }
          }
        }
      ]
    },
    {
      "week": 8,
      "title": "객체 지향 프로그래밍 (1): 클래스와 객체의 이해",
      "cycles": [
        {
          "title": "왜 객체 지향인가? (클래스와 객체 개념)",
          "filename": "user_model.py",
          "lecture": {
            "character": "profKim",
            "title": "강의 노트: 클래스와 객체",
            "keyTakeaway": "클래스는 '설계도', 객체는 그 설계도로 만든 '실제 제품'입니다.",
            "sandboxCode": "class Car:\n    pass\n\n# Car 클래스로부터 my_car 라는 객체를 만들어보세요.\nmy_car = Car()\nprint(my_car)",
            "sections": [
              {
                "heading": "핵심 개념",
                "text": "객체 지향 프로그래밍(OOP)은 연관 있는 데이터(속성)와 그 데이터를 처리하는 기능(메소드)을 하나로 묶어 '객체' 단위로 관리하는 기법입니다 [cite: 2442-2443]. '클래스(Class)'는 객체를 만들기 위한 설계도이며, '객체(Object)'는 그 설계도를 바탕으로 실제로 만들어진 실체(인스턴스)입니다.",
                "code": null
              },
              {
                "heading": "기본 문법",
                "text": "`class` 키워드로 클래스를 정의하고, 클래스 이름에 괄호`()`를 붙여 객체를 생성합니다.",
                "code": "# Person 이라는 이름의 클래스(설계도) 정의\nclass Person:\n    pass\n\n# Person 클래스로부터 p1 이라는 객체(실체) 생성\np1 = Person()"
              },
              {
                "heading": "활용 사례",
                "text": "'사용자', '게시물', '자동차' 등 현실 세계의 대상을 모델링하거나, 데이터와 기능이 밀접하게 연관된 복잡한 시스템을 논리적인 단위로 나누어 관리할 때 사용됩니다.",
                "code": null
              },
              {
                "heading": "주의점 및 팁",
                "text": "클래스는 설계도일 뿐이며, 실제로 메모리 공간을 차지하고 데이터를 담는 것은 객체입니다. 하나의 클래스로부터 수많은 객체를 만들어낼 수 있습니다.",
                "code": null
              }
            ]
          },
          "syntax_key": {
            "syntax_title": "print()",
            "syntax_comment": "`print()`는 괄호 안의 값을 화면에 출력하는 내장 함수입니다.",
            "systax_code": "print(\"Hello World\")"
          },
          "task": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "데이터 관리 방식 개선",
            "content": "사용자 데이터를 보다 체계적으로 관리하기 위해 <span class='font-bold text-yellow-300'>'객체 지향 프로그래밍'</span> 개념을 도입하려고 합니다. 먼저, 사용자를 나타내는 설계도인 <span class='font-bold text-yellow-300'>`User` 클래스를 정의</span>하고, 이 설계도를 바탕으로 실제 사용자 객체 <span class='font-bold text-yellow-300'>`user1`을 생성</span>해주세요. 지금은 빈 껍데기만 만들어도 됩니다."
          },
          "briefing": {
            "character": "sena",
            "subtitle": "직속 선임의 OJT",
            "title": "설계도(클래스)와 제품(객체)",
            "content": "객체 지향에서는 먼저 <span class='font-bold text-teal-300'>설계도인 '클래스(Class)'</span>를 만들어요. `starterCode`의 첫 번째 빈칸에 <span class='font-bold text-teal-300'>`class User:`</span> 라고 쓰고, 다음 줄에 <span class='font-bold text-teal-300'>들여쓰기 후 `pass`</span>를 입력하면 돼요. 두 번째 빈칸에는 이 설계도로 <span class='font-bold text-teal-300'>실제 제품인 '객체(Object)'</span>를 만드는 코드 <span class='font-bold text-teal-300'>`User()`</span>를 입력하면 됩니다! 클래스 이름 뒤에 괄호`()`를 붙이는 거죠."
          },
          "starterCode": "# TODO: 1. 아래 빈칸에 'User' 라는 이름의 클래스를 정의하는 코드를 작성하세요.\n# 형식: class 이름:\n#       pass (내용이 없다는 뜻)\n\n\n# TODO: 2. '=' 오른쪽에 User 클래스로부터 객체를 생성하는 코드를 작성하세요.\n# 형식: 클래스이름()\nuser1 = \n\n# 아래는 테스트용 코드입니다.\nprint(user1)\n",
          "testCode": "assert 'User' in locals() and isinstance(User, type), \"'User' 클래스가 정의되지 않았습니다.\"; assert 'user1' in locals(), \"'user1' 변수가 존재하지 않았습니다.\"; assert isinstance(user1, User), \"'user1' 변수는 User 클래스의 객체여야 합니다.\"",
          "feedback": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "클래스와 객체 생성 완료",
              "content": "<span class='font-bold text-green-300'>좋습니다. 클래스를 정의하고 객체를 성공적으로 생성</span>했군요. 이것이 객체 지향 프로그래밍의 가장 기본적인 첫걸음입니다. 이제 이 설계도에 내용을 채워봅시다."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "클래스 정의나 객체 생성을 확인해볼까요?",
              "content": "음, 클래스나 객체가 제대로 만들어지지 않은 것 같아요. 첫 번째 빈칸에는 <span class='font-bold text-teal-300'>`class User:`</span> 와 다음 줄 <span class='font-bold text-teal-300'>`pass`</span>를 정확히 입력했나요? 두 번째 빈칸에는 <span class='font-bold text-teal-300'>`User()`</span> 코드를 통해 객체를 생성해서 `user1` 변수에 저장했는지 확인해주세요."
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, 클래스 정의 오류!",
              "content": "클래스를 만들 때 문법 오류가 발생했어요. 클래스는 `class 이름:` 형식으로 만들어야 해요. `class` 키워드를 빠뜨리거나 이름 뒤에 콜론(`:`)을 잊으신 건 아닐까요? 내용이 없을 땐 다음 줄에 들여쓰기 후 `pass`를 써야 하고요."
            }
          },
          "task_adv": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "로그 항목 클래스 정의",
            "content": "시스템 로그의 각 항목을 객체로 표현하려고 합니다. 로그 항목의 설계도 역할을 할 <span class='font-bold text-yellow-300'>`LogEntry` 클래스를 빈 내용으로 정의</span>해주세요. 그리고 이 클래스를 사용하여 <span class='font-bold text-yellow-300'>두 개의 서로 다른 로그 객체(`log1`, `log2`)를 생성</span>하여 변수에 저장하세요."
          },
          "briefing_adv": {
            "character": "sena",
            "subtitle": "직속 선임의 팁",
            "title": "클래스 만들고 객체 생성하기",
            "content": "클래스를 만드는 건 쉬워요. <span class='font-bold text-teal-300'>`class LogEntry:`</span> 라고 쓰고 다음 줄에 `pass`만 적어주면 빈 클래스가 만들어지죠. 객체를 만드는 건 <span class='font-bold text-teal-300'>`log1 = LogEntry()`</span> 처럼 클래스 이름에 괄호를 붙여서 변수에 할당하면 돼요. 두 개의 다른 객체를 만들라고 했으니 이 과정을 두 번 반복하면 되겠네요!"
          },
          "starterCode_adv": "# 아래 코드는 간단한 로그 메시지를 나타내는 클래스를 정의하는 것을 목표로 합니다.\n# TODO: 1. 'LogEntry'라는 이름의 비어있는 클래스를 정의하세요.\nclass LogEntry:\n    pass\n\n# TODO: 2. 'LogEntry' 클래스의 인스턴스를 두 개 만들어 각각 'log1', 'log2' 변수에 저장하세요.\nlog1 = LogEntry()\nlog2 = LogEntry()\n\n# 아래는 테스트용 코드입니다.\nprint(log1)\nprint(log2)\n",
          "testCode_adv": "assert 'LogEntry' in locals() and isinstance(LogEntry, type), \"'LogEntry' 클래스가 정의되지 않았습니다.\"; assert 'log1' in locals() and isinstance(log1, LogEntry), \"'log1' 변수가 LogEntry 객체가 아닙니다.\"; assert 'log2' in locals() and isinstance(log2, LogEntry), \"'log2' 변수가 LogEntry 객체가 아닙니다.\"; assert log1 is not log2, \"log1과 log2는 서로 다른 객체여야 합니다.\"",
          "feedback_adv": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "클래스와 객체 생성 완료",
              "content": "<span class='font-bold text-green-300'>좋습니다. 클래스를 정의하고 객체를 성공적으로 생성</span>했군요. 이것이 객체 지향 프로그래밍의 가장 기본적인 첫걸음입니다. 이제 이 설계도에 내용을 채워봅시다."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "클래스 정의나 객체 생성을 확인해볼까요?",
              "content": "음, 클래스나 객체가 제대로 만들어지지 않은 것 같아요. 첫 번째 빈칸에는 <span class='font-bold text-teal-300'>`class User:`</span> 와 다음 줄 <span class='font-bold text-teal-300'>`pass`</span>를 정확히 입력했나요? 두 번째 빈칸에는 <span class='font-bold text-teal-300'>`User()`</span> 코드를 통해 객체를 생성해서 `user1` 변수에 저장했는지 확인해주세요."
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, 클래스 정의 오류!",
              "content": "클래스를 만들 때 문법 오류가 발생했어요. 클래스는 `class 이름:` 형식으로 만들어야 해요. `class` 키워드를 빠뜨리거나 이름 뒤에 콜론(`:`)을 잊으신 건 아닐까요? 내용이 없을 땐 다음 줄에 들여쓰기 후 `pass`를 써야 하고요."
            }
          }
        },
        {
          "title": "객체의 설계도, 클래스 정의하기 (`__init__`)",
          "filename": "user_model.py",
          "lecture": {
            "character": "profKim",
            "title": "강의 노트: __init__ 메소드와 self",
            "keyTakeaway": "`__init__`은 객체 생성 시 호출되는 초기 설정 함수이며, `self`를 통해 객체에 데이터를 저장합니다.",
            "sandboxCode": "class Book:\n    def __init__(self, title, author):\n        self.title = title\n        self.author = author\n\n# 'A Byte of Python'이라는 제목의 책 객체를 만들어보세요.\nmy_book = Book(\"A Byte of Python\", \"Swaroop CH\")\nprint(my_book.title)",
            "sections": [
              {
                "heading": "핵심 개념",
                "text": "`__init__` 메소드는 클래스로부터 객체가 생성(인스턴스화)될 때 자동으로 호출되는 초기화(initializer) 메소드입니다 [cite: 2483-2485]. `self`는 생성되는 객체 자기 자신을 가리키는 특별한 매개변수이며, `self.변수명 = 값` 형태로 객체에 데이터를 저장할 수 있습니다. 이렇게 저장된 변수를 '속성(attribute)'이라고 합니다.",
                "code": null
              },
              {
                "heading": "기본 문법",
                "text": "메소드 이름 앞뒤로 밑줄 두 개(`__`)를 사용하며, 첫 매개변수는 항상 `self`여야 합니다.",
                "code": "class User:\n    # 객체가 생성될 때 username을 받아 self.name에 저장\n    def __init__(self, username):\n        self.name = username\n\n# 객체 생성 시, __init__ 메소드에 인자 전달\nuser1 = User(\"Alex\")"
              },
              {
                "heading": "활용 사례",
                "text": "객체가 생성될 때 반드시 필요한 초기 데이터(예: 사용자의 ID, 캐릭터의 체력)를 설정하여, 데이터 누락 없이 안정적인 객체를 만들 수 있습니다.",
                "code": null
              },
              {
                "heading": "주의점 및 팁",
                "text": "메소드 이름은 밑줄 두 개(`__`)로 시작하고 끝나야 합니다. `self`는 모든 메소드의 첫 번째 매개변수로 항상 포함되어야 하며, 파이썬이 자동으로 값을 전달해줍니다.",
                "code": null
              }
            ]
          },
          "syntax_key": {
            "syntax_title": "print()",
            "syntax_comment": "`print()`는 괄호 안의 값을 화면에 출력하는 내장 함수입니다.",
            "systax_code": "print(\"Hello World\")"
          },
          "task": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "User 클래스 구체화",
            "content": "`User` 클래스에 객체가 생성될 때 필수 정보를 설정하는 기능을 추가해야 합니다. <span class='font-bold text-yellow-300'>`__init__` 초기화 메소드</span>를 정의하여, 객체가 만들어질 때 <span class='font-bold text-yellow-300'>`username`과 `email`을 받아</span> 각각 객체의 속성으로 저장하도록 구현해주세요."
          },
          "briefing": {
            "character": "sena",
            "subtitle": "직속 선임의 팁",
            "title": "객체 초기 설정: `__init__`",
            "content": "객체가 처음 만들어질 때 특별히 실행되는 <span class='font-bold text-teal-300'>`__init__` 메소드</span>를 만들어봐요 [cite: 2483-2484]. `starterCode`의 빈칸을 채워볼까요? 첫 줄 빈칸에는 <span class='font-bold text-teal-300'>`__init__`</span> (밑줄 두 개씩!)을 넣으세요. 다음 줄 `self.` 뒤에는 <span class='font-bold text-teal-300'>`username`</span>, `=` 오른쪽에는 <span class='font-bold text-teal-300'>`username`</span>을 넣어서 `self.username = username` 형태로 만들어요. 그 다음 줄도 <span class='font-bold text-teal-300'>`self.email = email`</span> 로 완성하면 됩니다! <span class='font-bold text-teal-300'>`self`</span>는 '객체 자기 자신'을 뜻하고, 이렇게 `self.이름`으로 객체에 데이터를 저장할 수 있어요."
          },
          "starterCode": "class User:\n    # TODO: __init__ 메소드를 정의하세요.\n    # 형식: def __init__(self, 매개변수1, 매개변수2):\n    #         self.속성이름1 = 매개변수1\n    #         self.속성이름2 = 매개변수2\n    def (self, username, email):\n        # username 값을 self.username 에 저장\n        self. = \n        # email 값을 self.email 에 저장\n        self. = \n\n# 아래는 테스트용 코드입니다.\nuser1 = User(\"alex_team\", \"alex@logicore.tech\")\nprint(f\"Username: {user1.username}, Email: {user1.email}\")\n",
          "testCode": "assert 'User' in locals() and hasattr(User, '__init__') and callable(getattr(User, '__init__', None)), \"User 클래스에 __init__ 메소드가 정의되지 않았습니다.\"; test_user = None; try: test_user = User(\"test_user\", \"test@email.com\") except TypeError: assert False, \"__init__ 메소드가 username과 email 매개변수를 제대로 받고 있는지 확인해주세요.\"; assert hasattr(test_user, 'username') and test_user.username == \"test_user\", \"username 속성이 올바르게 저장되지 않았습니다.\"; assert hasattr(test_user, 'email') and test_user.email == \"test@email.com\", \"email 속성이 올바르게 저장되지 않았습니다.\"",
          "feedback": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "초기화 기능 구현 완료",
              "content": "완벽합니다. 이제 우리가 만드는 모든 객체는 <span class='font-bold text-green-300'>생성 시 필요한 정보를 정확히 갖게 되었네요.</span> `__init__` 메소드를 통해 객체의 필수 상태를 설정하는 것은 매우 중요합니다."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "self 사용법을 확인해보세요",
              "content": "객체 속성이 제대로 저장되지 않은 것 같아요. `__init__` 메소드 안에서 <span class='font-bold text-teal-300'>`self.username = username`</span> 처럼 `self.`를 사용해서 속성을 저장했는지, 그리고 매개변수 이름(`username`, `email`)을 정확히 사용했는지 확인해주세요."
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, __init__ 문법 오류!",
              "content": "`__init__` 메소드를 정의할 때 오류가 발생했어요. `def __init__(self, ...):` 처럼 이름 앞뒤에 밑줄이 두 개씩 있는지, 첫 번째 매개변수로 `self`가 있는지, 마지막에 콜론(`:`)이 있는지 꼼꼼하게 확인해주세요."
            }
          },
          "task_adv": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "LogEntry 클래스 초기화 기능 추가",
            "content": "`LogEntry` 클래스에 객체 생성 시 로그 정보를 설정하는 기능을 추가합니다. <span class='font-bold text-yellow-300'>`__init__` 메소드</span>를 정의하여, <span class='font-bold text-yellow-300'>로그 메시지(`message`)</span>와 <span class='font-bold text-yellow-300'>로그 타입(`log_type`)</span>을 받아 객체 속성에 저장하도록 구현하세요. `log_type`은 기본값으로 'INFO'를 가져야 합니다."
          },
          "briefing_adv": {
            "character": "sena",
            "subtitle": "직속 선임의 팁",
            "title": "초기화 메소드와 기본값",
            "content": "객체가 처음 만들어질 때 실행되는 <span class='font-bold text-teal-300'>`__init__` 메소드</span>를 만들면 돼요 [cite: 2483-2484]. `message`와 `log_type`을 매개변수로 받아야 하는데, `log_type`은 기본값을 가지니까 <span class='font-bold text-teal-300'>`log_type='INFO'`</span> 이렇게 정의하면 되겠죠? 함수 안에서는 <span class='font-bold text-teal-300'>`self.message = message`</span> 와 같이 `self`를 이용해서 객체에 값을 저장해주면 됩니다!"
          },
          "starterCode_adv": "# 로그 항목 클래스에 생성 시 로그 메시지와 타입을 설정하는 기능을 추가합니다.\nclass LogEntry:\n    # TODO: __init__ 메소드를 정의하세요.\n    # 매개변수: self, message, log_type (기본값: 'INFO')\n    # 받은 message를 self.message 속성에 저장하세요.\n    # 받은 log_type을 self.log_type 속성에 저장하세요.\n    def __init__(self, message, log_type='INFO'):\n        self.message = message\n        self.log_type = log_type\n\n# 아래는 테스트용 코드입니다.\nlog1 = LogEntry(\"User logged in\")\nlog2 = LogEntry(\"File not found\", \"ERROR\")\nprint(f\"Log1: [{log1.log_type}] {log1.message}\")\nprint(f\"Log2: [{log2.log_type}] {log2.message}\")\n",
          "testCode_adv": "import inspect; assert 'LogEntry' in locals() and hasattr(LogEntry, '__init__') and callable(getattr(LogEntry, '__init__', None)), 'LogEntry 클래스에 __init__ 메소드가 없습니다.'; sig = inspect.signature(LogEntry.__init__); assert 'message' in sig.parameters, '__init__ 메소드에 message 매개변수가 없습니다.'; assert 'log_type' in sig.parameters and sig.parameters['log_type'].default == 'INFO', '__init__ 메소드에 log_type 매개변수가 없거나 기본값이 INFO가 아닙니다.'; log1 = LogEntry('Test message'); assert hasattr(log1, 'message') and log1.message == 'Test message', 'message 속성이 올바르게 저장되지 않았습니다.'; assert hasattr(log1, 'log_type') and log1.log_type == 'INFO', 'log_type 속성이 기본값 INFO로 올바르게 저장되지 않았습니다.'; log2 = LogEntry('Error occurred', 'ERROR'); assert log2.message == 'Error occurred' and log2.log_type == 'ERROR', 'log_type 인자를 전달했을 때 속성이 올바르게 저장되지 않았습니다.'",
          "feedback_adv": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "초기화 기능 구현 완료",
              "content": "완벽합니다. 이제 우리가 만드는 모든 객체는 <span class='font-bold text-green-300'>생성 시 필요한 정보를 정확히 갖게 되었네요.</span> `__init__` 메소드를 통해 객체의 필수 상태를 설정하는 것은 매우 중요합니다."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "self 사용법을 확인해보세요",
              "content": "객체 속성이 제대로 저장되지 않은 것 같아요. `__init__` 메소드 안에서 <span class='font-bold text-teal-300'>`self.username = username`</span> 처럼 `self.`를 사용해서 속성을 저장했는지, 그리고 매개변수 이름(`username`, `email`)을 정확히 사용했는지 확인해주세요."
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, __init__ 문법 오류!",
              "content": "`__init__` 메소드를 정의할 때 오류가 발생했어요. `def __init__(self, ...):` 처럼 이름 앞뒤에 밑줄이 두 개씩 있는지, 첫 번째 매개변수로 `self`가 있는지, 마지막에 콜론(`:`)이 있는지 꼼꼼하게 확인해주세요."
            }
          }
        },
        {
          "title": "객체의 행동, 메소드 추가하기",
          "filename": "user_model.py",
          "lecture": {
            "character": "profKim",
            "title": "강의 노트: 메소드 (Method)",
            "keyTakeaway": "메소드는 클래스에 소속된 함수이며, `self`를 통해 객체의 데이터를 활용하여 행동을 정의합니다.",
            "sandboxCode": "class Counter:\n    def __init__(self):\n        self.count = 0\n    \n    def click(self):\n        self.count = self.count + 1\n\n# 카운터 객체를 만들고, click 메소드를 3번 호출한 뒤\n# count 속성을 출력해보세요.\nc = Counter()\nc.click()\nc.click()\nc.click()\nprint(c.count)",
            "sections": [
              {
                "heading": "핵심 개념",
                "text": "메소드(Method)는 클래스 안에 정의된 함수이며, 해당 클래스의 객체가 수행할 수 있는 '행동'을 정의합니다 [cite: 2452, 2519-2520]. 메소드는 `self` 매개변수를 통해 객체의 속성(데이터)에 접근하고 조작할 수 있습니다.",
                "code": null
              },
              {
                "heading": "기본 문법",
                "text": "클래스 내부에 `def`를 사용하여 정의하며, 첫 매개변수는 항상 `self`여야 합니다 [cite: 2458-2459].",
                "code": "class User:\n    def __init__(self, name):\n        self.name = name\n\n    # 메소드 정의 (첫 매개변수는 항상 self)\n    def say_hello(self):\n        print(f\"Hello, {self.name}!\")\n\n# 객체 생성 및 메소드 호출\nuser1 = User(\"Sena\")\nuser1.say_hello() # \"Hello, Sena!\" 출력"
              },
              {
                "heading": "활용 사례",
                "text": "`Car` 객체의 `drive()` 메소드, `User` 객체의 `change_password()` 메소드처럼, 해당 객체의 데이터를 사용하여 특정 동작을 수행해야 할 때 사용됩니다.",
                "code": null
              },
              {
                "heading": "주의점 및 팁",
                "text": "클래스 안에 정의되는 모든 함수, 즉 메소드는 첫 번째 매개변수로 `self`를 반드시 포함해야 합니다.",
                "code": null
              }
            ]
          },
          "syntax_key": {
            "syntax_title": "print()",
            "syntax_comment": "`print()`는 괄호 안의 값을 화면에 출력하는 내장 함수입니다.",
            "systax_code": "print(\"Hello World\")"
          },
          "task": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "객체에 기능 부여하기",
            "content": "데이터뿐만 아니라, 객체에 '행동'을 부여해봅시다. `User` 클래스에 <span class='font-bold text-yellow-300'>`introduce` 메소드</span>를 추가해주세요. 이 메소드는 객체 자신의 `username`을 사용하여 <span class='font-bold text-yellow-300'>\"안녕하세요, 제 이름은 OOO입니다.\" 형식의 문자열을 반환</span>해야 합니다."
          },
          "briefing": {
            "character": "sena",
            "subtitle": "직속 선임의 팁",
            "title": "객체의 행동, 메소드!",
            "content": "메소드는 클래스 안에 사는 함수예요. `starterCode`를 볼까요? 첫 번째 빈칸에는 메소드 이름 <span class='font-bold text-teal-300'>`introduce`</span>를 넣으세요. `self`는 꼭 있어야 하고요! `return` 뒤 빈칸에는 f-string을 이용해서 <span class='font-bold text-teal-300'>`f\"안녕하세요, 제 이름은 {self.username}입니다.\"`</span> 라고 입력하면 돼요. <span class='font-bold text-teal-300'>`{self.username}`</span> 처럼 `self`를 통해 객체 자신의 이름(`username`)에 접근하는 거죠!"
          },
          "starterCode": "class User:\n    def __init__(self, username, email):\n        self.username = username\n        self.email = email\n\n    # TODO: 'introduce' 메소드를 추가하세요.\n    # 형식: def 이름(self):\n    #         return f\"... {self.속성} ...\"\n    def (self):\n        # TODO: 아래 빈칸에 \"안녕하세요, 제 이름은 {self.username}입니다.\" 형식의 f-string을 만드세요.\n        return \n\n# 아래는 테스트용 코드입니다. 수정하지 마세요.\nuser1 = User(\"sena_dev\", \"sena@logicore.tech\")\nmessage = user1.introduce()\nprint(message)\n",
          "testCode": "assert 'User' in locals() and hasattr(User, 'introduce') and callable(getattr(User, 'introduce', None)), \"User 클래스에 'introduce' 메소드가 정의되지 않았습니다.\"; test_user = User(\"Sena\", \"sena@logicore.tech\"); result = test_user.introduce(); expected = \"안녕하세요, 제 이름은 Sena입니다.\"; assert result == expected, f\"introduce 메소드의 반환값이 다릅니다. 기대값: '{expected}', 실제값: '{result}'\"",
          "feedback": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "객체 기능 추가 완료",
              "content": "<span class='font-bold text-green-300'>완벽합니다. 객체가 스스로의 데이터를 이용해 필요한 기능을 수행하는군요.</span> 데이터(속성)와 기능(메소드)을 하나로 묶는 객체 지향의 핵심을 잘 이해했습니다."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "반환된 문자열을 확인해볼까요?",
              "content": "메소드가 반환한 문자열이 요청한 형식과 조금 다르네요. 메소드 이름(`introduce`)을 정확히 입력했는지, `return` 뒤에 <span class='font-bold text-teal-300'>`f\"안녕하세요, 제 이름은 {self.username}입니다.\"`</span> f-string 형식이 정확한지 다시 한번 확인해주세요."
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, 메소드 정의 또는 호출 오류!",
              "content": "메소드를 정의하거나 사용하는 부분에서 오류가 발생했어요. 메소드를 정의할 때 `def 메소드이름(self):` 처럼 `self`를 첫 번째 매개변수로 꼭 넣어줘야 해요. `self`를 빼먹거나 콜론(`:`)을 잊었을 수 있어요!"
            }
          },
          "task_adv": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "로그 포맷팅 메소드 추가",
            "content": "`LogEntry` 객체가 스스로 로그 메시지를 형식에 맞게 출력할 수 있도록 기능을 추가합니다. <span class='font-bold text-yellow-300'>`format_log` 메소드</span>를 클래스에 추가하여, 객체가 가진 `log_type`과 `message`를 이용해 <span class='font-bold text-yellow-300'>\"[[로그타입]] 로그 메시지\" 형식의 문자열을 반환</span>하도록 구현해주세요."
          },
          "briefing_adv": {
            "character": "sena",
            "subtitle": "직속 선임의 팁",
            "title": "자신의 정보로 문자열 만들기",
            "content": "메소드 안에서는 <span class='font-bold text-teal-300'>`self`를 통해 객체의 속성에 접근</span>할 수 있죠? `self.log_type`과 `self.message` 값을 가져와서, <span class='font-bold text-teal-300'>f-string</span>을 사용하면 `f\"[{self.log_type}] {self.message}\"` 같은 형식의 문자열을 쉽게 만들 수 있어요. 이 문자열을 <span class='font-bold text-teal-300'>`return`</span> 해주면 됩니다!"
          },
          "starterCode_adv": "# LogEntry 클래스에 로그 정보를 포맷팅하여 반환하는 메소드를 추가합니다.\nclass LogEntry:\n    def __init__(self, message, log_type='INFO'):\n        self.message = message\n        self.log_type = log_type\n\n    # TODO: 'format_log' 메소드를 정의하세요.\n    # 이 메소드는 \"[[로그타입]] 로그 메시지\" 형식의 문자열을 반환해야 합니다.\n    # 예: \"[INFO] User logged in\"\n    def format_log(self):\n        return f\"[{self.log_type}] {self.message}\"\n\n# 아래는 테스트용 코드입니다.\nlog1 = LogEntry(\"User logged in\")\nlog2 = LogEntry(\"File not found\", \"ERROR\")\nprint(log1.format_log())\nprint(log2.format_log())\n",
          "testCode_adv": "assert 'LogEntry' in locals() and hasattr(LogEntry, 'format_log') and callable(getattr(LogEntry, 'format_log', None)), 'LogEntry 클래스에 format_log 메소드가 없습니다.'; log1 = LogEntry('Test msg'); result1 = log1.format_log(); expected1 = '[INFO] Test msg'; assert result1 == expected1, f'기본 로그 타입 форматирования 결과가 다릅니다. 기대값: \"{expected1}\", 실제값: \"{result1}\"'; log2 = LogEntry('Error msg', 'ERROR'); result2 = log2.format_log(); expected2 = '[ERROR] Error msg'; assert result2 == expected2, f'지정된 로그 타입 форматирования 결과가 다릅니다. 기대값: \"{expected2}\", 실제값: \"{result2}\"'",
          "feedback_adv": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "객체 기능 추가 완료",
              "content": "<span class='font-bold text-green-300'>완벽합니다. 객체가 스스로의 데이터를 이용해 필요한 기능을 수행하는군요.</span> 데이터(속성)와 기능(메소드)을 하나로 묶는 객체 지향의 핵심을 잘 이해했습니다."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "반환된 문자열을 확인해볼까요?",
              "content": "메소드가 반환한 문자열이 요청한 형식과 조금 다르네요. 메소드 이름(`introduce`)을 정확히 입력했는지, `return` 뒤에 <span class='font-bold text-teal-300'>`f\"안녕하세요, 제 이름은 {self.username}입니다.\"`</span> f-string 형식이 정확한지 다시 한번 확인해주세요."
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, 메소드 정의 또는 호출 오류!",
              "content": "메소드를 정의하거나 사용하는 부분에서 오류가 발생했어요. 메소드를 정의할 때 `def 메소드이름(self):` 처럼 `self`를 첫 번째 매개변수로 꼭 넣어줘야 해요. `self`를 빼먹거나 콜론(`:`)을 잊었을 수 있어요!"
            }
          }
        }
      ]
    },
    {
      "week": 9,
      "title": "객체 지향 프로그래밍 (2): 상속을 통한 코드 확장",
      "cycles": [
        {
          "title": "코드 재사용의 꽃, 상속(Inheritance)",
          "filename": "admin_model.py",
          "lecture": {
            "character": "profKim",
            "title": "강의 노트: 상속 (Inheritance)",
            "keyTakeaway": "상속은 `class 자식(부모):` 형태로, 부모 클래스의 모든 것을 물려받아 코드를 재사용하고 확장하는 기법입니다.",
            "sandboxCode": "class Animal:\n    def __init__(self, name):\n        self.name = name\n    def speak(self):\n        print(\"...\")\n\n# Animal 클래스를 상속받는 Dog 클래스를 만들어보세요.\nclass Dog(Animal):\n    def speak(self):\n        print(\"멍멍!\")\n\nmy_dog = Dog(\"해피\")\nprint(my_dog.name)\nmy_dog.speak()",
            "sections": [
              {
                "heading": "핵심 개념",
                "text": "상속(Inheritance)은 기존 클래스(부모 클래스, 슈퍼 클래스)의 모든 속성과 메소드를 물려받아 새로운 클래스(자식 클래스, 서브 클래스)를 만드는 것입니다 [cite: 2531-2532, 2579-2580]. 이를 통해 코드의 중복을 피하고, 클래스 간의 논리적인 계층 구조(형식과 세부 형식)를 만들 수 있습니다.",
                "code": null
              },
              {
                "heading": "기본 문법",
                "text": "클래스를 정의할 때 소괄호 `()` 안에 부모 클래스의 이름을 넣습니다 [cite: 2582-2583]. 자식 클래스의 `__init__`에서는 부모 클래스의 `__init__`을 명시적으로 호출해야 합니다.",
                "code": "# 부모 클래스를 괄호 안에 넣어 상속\nclass Admin(User):\n    def __init__(self, username, email, level):\n        # 부모 클래스의 __init__을 명시적으로 호출해야 함\n        User.__init__(self, username, email)\n        # 자식 클래스만의 속성 추가\n        self.admin_level = level"
              },
              {
                "heading": "활용 사례",
                "text": "현실 세계의 계층 구조를 모델링할 때 매우 유용합니다. 예를 들어 `동물` > `포유류` > `개` 와 같은 관계를 코드로 표현할 수 있습니다.",
                "code": null
              },
              {
                "heading": "주의점 및 팁",
                "text": "자식 클래스의 `__init__` 메소드에서는, 부모 클래스의 `__init__` 메소드를 명시적으로 호출하여 부모 클래스의 초기화 과정을 수행해줘야 합니다. 파이썬은 이 과정을 자동으로 처리해주지 않습니다.",
                "code": null
              }
            ]
          },
          "syntax_key": {
            "syntax_title": "print()",
            "syntax_comment": "`print()`는 괄호 안의 값을 화면에 출력하는 내장 함수입니다.",
            "systax_code": "print(\"Hello World\")"
          },
          "task": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "관리자(Admin) 타입 추가",
            "content": "서비스에 특별 권한을 가진 '관리자'가 필요하게 되었습니다. 관리자는 '사용자'의 속성(이름, 이메일)을 그대로 가지면서, 추가로 <span class='font-bold text-yellow-300'>'관리 등급(admin_level)'</span> 속성을 가져야 합니다. <span class='font-bold text-yellow-300'>상속(Inheritance)</span>을 사용하여 `User` 클래스를 확장한 `Admin` 클래스를 만들어주세요."
          },
          "briefing": {
            "character": "sena",
            "subtitle": "직속 선임의 OJT",
            "title": "코드 물려받기: 상속",
            "content": "상속은 부모 클래스의 기능을 그대로 물려받아 확장하는 거예요 [cite: 2531-2532]. `starterCode`를 봅시다! `class Admin` 옆 괄호 안에 부모 클래스 이름 <span class='font-bold text-teal-300'>`User`</span>를 넣으세요. `__init__` 메소드 괄호 안 빈칸에는 <span class='font-bold text-teal-300'>`admin_level`</span>을 추가하고요. 그 아래 빈칸에는 부모(`User`)의 초기화 함수를 호출하는 <span class='font-bold text-teal-300'>`User.__init__(self, username, email)`</span> 코드를 넣으세요. 마지막 빈칸에는 <span class='font-bold text-teal-300'>`admin_level`</span>을 넣어 `Admin`만의 속성을 저장하면 상속 완료!"
          },
          "starterCode": "class User:\n    def __init__(self, username, email):\n        self.username = username\n        self.email = email\n        # print(f\"(Initialized User: {self.username})\") # 주석 처리됨\n\n# TODO: 1. 아래 빈칸에 부모 클래스 이름 'User'를 넣어 Admin 클래스가 User를 상속받도록 하세요.\nclass Admin():\n    # TODO: 2. 아래 __init__ 메소드의 빈칸에 매개변수 'admin_level'을 추가하세요.\n    def __init__(self, username, email, ):\n        # TODO: 3. 아래 빈칸에 부모 클래스(User)의 __init__ 메소드를 호출하는 코드를 작성하세요.\n        # 형식: 부모클래스이름.__init__(self, 부모가필요한인자1, 부모가필요한인자2)\n        .__init__(self, , )\n        \n        # TODO: 4. '=' 오른쪽에 매개변수 'admin_level'을 넣어 self.admin_level 속성에 값을 저장하세요.\n        self.admin_level = \n\n# 아래는 테스트용 코드입니다. 수정하지 마세요.\nadmin1 = Admin(\"super_admin\", \"admin@logicore.tech\", 1)\nprint(f\"Username: {admin1.username}, Email: {admin1.email}, Level: {admin1.admin_level}\")\n",
          "testCode": "student_globals = {'User': User, 'Admin': None}; exec(student_code, student_globals); AdminClass = student_globals['Admin']; assert AdminClass is not None, 'Admin 클래스가 정의되지 않았습니다.'; assert issubclass(AdminClass, User), 'Admin 클래스는 User 클래스를 상속받아야 합니다.'; test_admin = None; try: test_admin = AdminClass('test', 'test@test.com', 2) except Exception as e: assert False, f'Admin 객체 생성에 실패했습니다: {e}'; assert hasattr(test_admin, 'username') and test_admin.username == 'test', '부모 클래스의 __init__이 호출되지 않아 username이 설정되지 않았습니다.'; assert hasattr(test_admin, 'email') and test_admin.email == 'test@test.com', '부모 클래스의 __init__이 호출되지 않아 email이 설정되지 않았습니다.'; assert hasattr(test_admin, 'admin_level') and test_admin.admin_level == 2, 'admin_level 속성이 올바르게 설정되지 않았습니다.'",
          "feedback": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피백",
              "title": "효율적인 클래스 확장",
              "content": "<span class='font-bold text-green-300'>코드 중복 없이 새로운 클래스를 깔끔하게 만들어냈군요.</span> 상속의 개념을 정확히 이해했습니다. 이제 우리는 `User` 클래스만 개선해도 하위 클래스들에 그 기능이 자동으로 반영되는 효율적인 구조를 갖게 되었습니다."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "상속 문법이나 __init__ 호출을 확인해보세요",
              "content": "클래스 상속이나 초기화 부분이 잘못된 것 같아요. 클래스 정의 시 `class Admin(User):` 처럼 괄호 안에 부모 클래스 이름을 넣었는지, `__init__` 메소드 안에서 `User.__init__(self, username, email)` 코드를 호출해서 부모 초기화를 실행했는지, `self.admin_level = admin_level` 로 속성을 제대로 저장했는지 확인해주세요."
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, 상속 또는 __init__ 문법 오류!",
              "content": "클래스를 정의하는 부분에서 오류가 발생했어요. 상속을 받으려면 `class Admin(User):` 처럼 클래스 이름 뒤 괄호 안에 부모 클래스 이름을 넣어줘야 해요. 괄호를 빠뜨리진 않았나요? `__init__` 메소드 정의(`def __init__(self, ...):`)도 다시 한번 확인해주세요."
            }
          },
          "task_adv": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "프리미엄 사용자 타입 추가",
            "content": "새로운 '프리미엄 사용자' 등급을 도입합니다. 프리미엄 사용자는 일반 '사용자'의 속성(이름, 가입일)을 가지면서, 추가로 <span class='font-bold text-yellow-300'>'멤버십 등급(membership_tier)'</span> 속성을 가져야 합니다. <span class='font-bold text-yellow-300'>상속</span>을 활용하여 `User` 클래스를 확장한 `PremiumUser` 클래스를 정의해주세요."
          },
          "briefing_adv": {
            "character": "sena",
            "subtitle": "직속 선임의 팁",
            "title": "기존 클래스 재활용하기",
            "content": "새 클래스를 만들 때 기존 `User` 클래스의 기능을 재사용하면 편하겠죠? <span class='font-bold text-teal-300'>`class PremiumUser(User):`</span>로 상속을 받고, `__init__` 메소드 안에서 <span class='font-bold text-teal-300'>`User.__init__(self, username, join_date)`</span>를 호출해서 부모 클래스가 필요한 초기화를 하도록 하세요. 그 다음 줄에 `PremiumUser`만의 속성인 `self.membership_tier`를 설정해주면 됩니다!"
          },
          "starterCode_adv": "class User:\n    def __init__(self, username, join_date):\n        self.username = username\n        self.join_date = join_date\n\n# TODO: User 클래스를 상속받는 PremiumUser 클래스를 정의하세요.\n# 1. 클래스 선언 시 User를 상속받도록 하세요.\n# 2. __init__ 메소드에서 username, join_date, membership_tier 인자를 받으세요.\n# 3. 부모 클래스(User)의 __init__ 메소드를 호출하여 username과 join_date를 초기화하세요.\n# 4. self.membership_tier 속성에 membership_tier 값을 저장하세요.\nclass PremiumUser(User):\n    def __init__(self, username, join_date, membership_tier):\n        User.__init__(self, username, join_date)\n        # super().__init__(username, join_date) # super()를 사용할 수도 있습니다.\n        self.membership_tier = membership_tier\n\n# 아래는 테스트용 코드입니다. 수정하지 마세요.\npremium_user = PremiumUser(\"pro_gamer\", \"2025-10-01\", \"Gold\")\nprint(f\"User: {premium_user.username}, Joined: {premium_user.join_date}, Tier: {premium_user.membership_tier}\")\n",
          "testCode_adv": "student_globals = {'User': User, 'PremiumUser': None}; exec(student_code, student_globals); PremiumUserClass = student_globals['PremiumUser']; assert PremiumUserClass is not None, 'PremiumUser 클래스가 정의되지 않았습니다.'; assert issubclass(PremiumUserClass, User), 'PremiumUser 클래스는 User 클래스를 상속받아야 합니다.'; test_user = None; try: test_user = PremiumUserClass('test_prem', '2025-01-01', 'Silver') except Exception as e: assert False, f'PremiumUser 객체 생성에 실패했습니다: {e}'; assert hasattr(test_user, 'username') and test_user.username == 'test_prem', '부모 클래스의 __init__이 호출되지 않아 username이 설정되지 않았습니다.'; assert hasattr(test_user, 'join_date') and test_user.join_date == '2025-01-01', '부모 클래스의 __init__이 호출되지 않아 join_date가 설정되지 않았습니다.'; assert hasattr(test_user, 'membership_tier') and test_user.membership_tier == 'Silver', 'membership_tier 속성이 올바르게 설정되지 않았습니다.'",
          "feedback_adv": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피백",
              "title": "효율적인 클래스 확장",
              "content": "<span class='font-bold text-green-300'>코드 중복 없이 새로운 클래스를 깔끔하게 만들어냈군요.</span> 상속의 개념을 정확히 이해했습니다. 이제 우리는 `User` 클래스만 개선해도 하위 클래스들에 그 기능이 자동으로 반영되는 효율적인 구조를 갖게 되었습니다."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "상속 문법이나 __init__ 호출을 확인해보세요",
              "content": "클래스 상속이나 초기화 부분이 잘못된 것 같아요. 클래스 정의 시 `class Admin(User):` 처럼 괄호 안에 부모 클래스 이름을 넣었는지, `__init__` 메소드 안에서 `User.__init__(self, username, email)` 코드를 호출해서 부모 초기화를 실행했는지, `self.admin_level = admin_level` 로 속성을 제대로 저장했는지 확인해주세요."
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, 상속 또는 __init__ 문법 오류!",
              "content": "클래스를 정의하는 부분에서 오류가 발생했어요. 상속을 받으려면 `class Admin(User):` 처럼 클래스 이름 뒤 괄호 안에 부모 클래스 이름을 넣어줘야 해요. 괄호를 빠뜨리진 않았나요? `__init__` 메소드 정의(`def __init__(self, ...):`)도 다시 한번 확인해주세요."
            }
          }
        },
        {
          "title": "기능 재정의와 다형성",
          "filename": "admin_model.py",
          "lecture": {
            "character": "profKim",
            "title": "강의 노트: 메소드 오버라이딩과 다형성",
            "keyTakeaway": "오버라이딩은 부모의 메소드를 자식이 재정의하는 것이며, 이를 통해 같은 이름의 메소드가 객체에 따라 다르게 동작(다형성)하게 만들 수 있습니다.",
            "sandboxCode": "class Parent:\n    def greet(self):\n        print(\"부모의 인사\")\n\nclass Child(Parent):\n    # greet 메소드를 오버라이딩 해보세요.\n    def greet(self):\n        print(\"자식의 인사\")\n\nc = Child()\nc.greet() # 무엇이 출력될까요?",
            "sections": [
              {
                "heading": "핵심 개념",
                "text": "메소드 오버라이딩은 자식 클래스가 부모 클래스로부터 물려받은 메소드를 자신만의 내용으로 새로 정의하는 것입니다. 다형성(Polymorphism)은 이렇게 서로 다른 클래스(User, Admin)의 객체들이 같은 이름의 메소드(`introduce`)를 호출해도, 각자의 클래스에 맞게 서로 다른 행동을 하는 특징을 말합니다 [cite: 2542-2544].",
                "code": null
              },
              {
                "heading": "기본 문법",
                "text": "자식 클래스에서 부모와 똑같은 이름의 메소드를 다시 정의하면 됩니다. `super()` 함수를 사용하면 오버라이딩된 메소드 내에서 부모 클래스의 원본 메소드를 호출할 수 있습니다.",
                "code": "class Admin(User):\n    # ... __init__ ...\n\n    # introduce 메소드를 새로 정의 (오버라이딩)\n    def introduce(self):\n        # 부모의 원래 기능을 먼저 호출하고 싶을 때\n        # base_intro = super().introduce()\n        print(f\"관리 등급은 {self.admin_level}입니다.\")"
              },
              {
                "heading": "활용 사례",
                "text": "게임에서 모든 캐릭터는 `attack()` 메소드를 가지지만, 전사는 칼로, 마법사는 마법으로 공격하는 것처럼, 같은 명령에 대해 객체마다 다른 동작을 구현할 때 사용됩니다.",
                "code": null
              },
              {
                "heading": "주의점 및 팁",
                "text": "메소드를 오버라이딩할 때는, 부모 클래스의 메소드 이름 및 매개변수 개수를 동일하게 유지하는 것이 일반적입니다.",
                "code": null
              }
            ]
          },
          "syntax_key": {
            "syntax_title": "print()",
            "syntax_comment": "`print()`는 괄호 안의 값을 화면에 출력하는 내장 함수입니다.",
            "systax_code": "print(\"Hello World\")"
          },
          "task": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "관리자 전용 기능 구현",
            "content": "`User`의 `introduce` 메소드는 일반 사용자용입니다. `Admin` 객체가 이 메소드를 호출할 때는 관리자에게 맞는 방식으로 소개하도록 기능을 변경해야 합니다. `Admin` 클래스에서 <span class='font-bold text-yellow-300'>`introduce` 메소드를 재정의(오버라이딩)</span>하여 <span class='font-bold text-yellow-300'>\"관리자 OOO입니다. 관리 등급은 X입니다.\" 형식의 문자열을 반환</span>하도록 수정해주세요."
          },
          "briefing": {
            "character": "sena",
            "subtitle": "직속 선임의 팁",
            "title": "기능 덮어쓰기: 오버라이딩",
            "content": "부모한테 물려받은 기능을 자식 클래스에서 새로 만드는 걸 <span class='font-bold text-teal-300'>'오버라이딩'</span>이라고 해요. `starterCode`를 볼까요? 첫 빈칸에 부모와 같은 메소드 이름 <span class='font-bold text-teal-300'>`introduce`</span>를 넣으세요. `return` 뒤 빈칸에는 관리자 소개 메시지를 f-string으로 만들면 돼요: <span class='font-bold text-teal-300'>`f\"관리자 {self.username}입니다. 관리 등급은 {self.admin_level}입니다.\"`</span>. 이제 `Admin` 객체는 이 새 `introduce` 메소드를 사용하게 될 거예요!"
          },
          "starterCode": "class User:\n    def __init__(self, username, email):\n        self.username = username\n        self.email = email\n    def introduce(self):\n        return f\"안녕하세요, 제 이름은 {self.username}입니다.\"\n\nclass Admin(User):\n    def __init__(self, username, email, admin_level):\n        User.__init__(self, username, email)\n        self.admin_level = admin_level\n\n    # TODO: 1. 아래 빈칸에 부모와 같은 이름의 메소드 'introduce'를 정의하세요.\n    # 형식: def 이름(self):\n    def (self):\n        # TODO: 2. 아래 return 뒤 빈칸에 f-string을 사용하여 관리자 소개 메시지를 만드세요.\n        # 형식: \"관리자 {self.username}입니다. 관리 등급은 {self.admin_level}입니다.\"\n        return \n\n# 아래는 테스트용 코드입니다. 수정하지 마세요.\nuser1 = User(\"sena_dev\", \"sena@logicore.tech\")\nadmin1 = Admin(\"super_admin\", \"admin@logicore.tech\", 1)\n\nprint(user1.introduce())\nprint(admin1.introduce())\n",
          "testCode": "student_globals = {'User': User, 'Admin': Admin}; # Assuming Admin class exists from previous step\nexec(student_code, student_globals); AdminClass = student_globals['Admin']; assert hasattr(AdminClass, 'introduce') and callable(getattr(AdminClass, 'introduce', None)), \"Admin 클래스에 'introduce' 메소드가 정의되지 않았습니다.\"; test_admin = AdminClass('super_admin', 'admin@logicore.tech', 1); result = test_admin.introduce(); expected = '관리자 super_admin입니다. 관리 등급은 1입니다.'; assert result == expected, f\"Admin의 introduce 메소드 반환값이 다릅니다. 기대값: '{expected}', 실제값: '{result}'\"",
          "feedback": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "유연한 구조 완성",
              "content": "<span class='font-bold text-green-300'>훌륭합니다. 이제 각 사용자 타입에 맞는 소개 메시지가 나오는군요.</span> 이렇게 다형성을 활용하면, 나중에 다양한 타입의 사용자를 동일한 방식으로 처리할 수 있어 코드가 매우 유연해집니다."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "메소드 정의나 f-string을 확인해보세요",
              "content": "메소드 정의가 잘못되었거나 반환된 메시지가 다르네요. 첫 빈칸에 메소드 이름 <span class='font-bold text-teal-300'>`introduce`</span>를 정확히 넣었나요? `return` 뒤 f-string <span class='font-bold text-teal-300'>`f\"관리자 {self.username}입니다. ... {self.admin_level}입니다.\"`</span> 형식도 다시 확인해주세요. 속성 이름(`self.username`, `self.admin_level`)에 오타는 없는지도요!"
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, 메소드 재정의 오류!",
              "content": "메소드를 재정의하는 부분에서 오류가 발생했어요. 자식 클래스 안에 `def introduce(self):` 처럼 메소드를 올바르게 정의했는지 확인해주세요. `self`를 빠뜨리거나 콜론(`:`)을 잊었을 수 있어요. `super()`를 사용했다면 괄호`()`를 붙였는지도 확인해보세요!"
            }
          },
          "task_adv": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "프리미엄 사용자 소개 방식 변경",
            "content": "프리미엄 사용자는 일반 사용자와 다른 방식으로 자신을 소개해야 합니다. `PremiumUser` 클래스에서 <span class='font-bold text-yellow-300'>`introduce` 메소드를 재정의</span>하세요. 이 메소드는 <span class='font-bold text-yellow-300'>부모 클래스(`User`)의 `introduce` 결과를 먼저 가져온 후</span>, 그 뒤에 <span class='font-bold text-yellow-300'>\", 등급: [멤버십 등급]\" 문자열을 덧붙여</span> 최종 결과를 반환해야 합니다."
          },
          "briefing_adv": {
            "character": "sena",
            "subtitle": "직속 선임의 팁",
            "title": "부모 기능 활용하고 덧붙이기",
            "content": "부모 클래스의 기능을 재사용하면서 내용을 추가하고 싶을 땐 <span class='font-bold text-teal-300'>`super()`</span> 함수를 쓰면 편리해요! 자식 클래스의 `introduce` 메소드 안에서 <span class='font-bold text-teal-300'>`super().introduce()`</span>를 호출하면 부모 클래스의 `introduce` 결과를 가져올 수 있어요. 그 결과 문자열에 필요한 내용을 덧붙여서 `return`하면 깔끔하게 구현할 수 있죠!"
          },
          "starterCode_adv": "class User:\n    def __init__(self, username, join_date):\n        self.username = username\n        self.join_date = join_date\n    def introduce(self):\n        return f\"사용자 {self.username} (가입일: {self.join_date})\"\n\nclass PremiumUser(User):\n    def __init__(self, username, join_date, membership_tier):\n        User.__init__(self, username, join_date)\n        self.membership_tier = membership_tier\n\n    # TODO: introduce 메소드를 오버라이딩하세요.\n    # 부모 클래스의 introduce 내용을 먼저 가져온 후,\n    # \", 등급: [멤버십 등급]\"을 덧붙여 반환해야 합니다.\n    # (힌트: super().introduce() 사용 가능)\n    def introduce(self):\n        base_intro = super().introduce() # 부모 메소드 호출\n        return f\"{base_intro}, 등급: {self.membership_tier}\"\n\n# 아래는 테스트용 코드입니다. 수정하지 마세요.\nuser = User(\"normal_user\", \"2025-09-15\")\npremium_user = PremiumUser(\"pro_gamer\", \"2025-10-01\", \"Gold\")\nprint(user.introduce())\nprint(premium_user.introduce())\n",
          "testCode_adv": "student_globals = {'User': User, 'PremiumUser': PremiumUser}; # Assuming PremiumUser class exists\nexec(student_code, student_globals); PremiumUserClass = student_globals['PremiumUser']; assert hasattr(PremiumUserClass, 'introduce') and callable(getattr(PremiumUserClass, 'introduce', None)), 'PremiumUser 클래스에 introduce 메소드가 없습니다.'; test_prem_user = PremiumUserClass('pro_gamer', '2025-10-01', 'Gold'); result = test_prem_user.introduce(); expected = '사용자 pro_gamer (가입일: 2025-10-01), 등급: Gold'; assert result == expected, f'PremiumUser의 introduce 메소드 반환값이 다릅니다. 기대값: \"{expected}\", 실제값: \"{result}\"'",
          "feedback_adv": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "유연한 구조 완성",
              "content": "<span class='font-bold text-green-300'>훌륭합니다. 이제 각 사용자 타입에 맞는 소개 메시지가 나오는군요.</span> 이렇게 다형성을 활용하면, 나중에 다양한 타입의 사용자를 동일한 방식으로 처리할 수 있어 코드가 매우 유연해집니다."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "메소드 정의나 f-string을 확인해보세요",
              "content": "메소드 정의가 잘못되었거나 반환된 메시지가 다르네요. 첫 빈칸에 메소드 이름 <span class='font-bold text-teal-300'>`introduce`</span>를 정확히 넣었나요? `return` 뒤 f-string <span class='font-bold text-teal-300'>`f\"관리자 {self.username}입니다. ... {self.admin_level}입니다.\"`</span> 형식도 다시 확인해주세요. 속성 이름(`self.username`, `self.admin_level`)에 오타는 없는지도요!"
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, 메소드 재정의 오류!",
              "content": "메소드를 재정의하는 부분에서 오류가 발생했어요. 자식 클래스 안에 `def introduce(self):` 처럼 메소드를 올바르게 정의했는지 확인해주세요. `self`를 빠뜨리거나 콜론(`:`)을 잊었을 수 있어요. `super()`를 사용했다면 괄호`()`를 붙였는지도 확인해보세요!"
            }
          }
        }
      ]
    },
    {
      "week": 10,
      "title": "파일 처리와 예외 관리: 데이터 영구 저장 및 오류 대응",
      "cycles": [
        {
          "title": "파일 읽고 쓰기",
          "filename": "logger.py",
          "lecture": {
            "character": "profKim",
            "title": "강의 노트: 파일 입출력",
            "keyTakeaway": "`with open()` 구문으로 파일을 안전하게 열고, `.write()`로 쓰고 `.read()` 또는 `.readline()`으로 읽을 수 있습니다.",
            "sandboxCode": "message = \"이것은 테스트 메시지입니다.\"\n\n# message 변수의 내용을 'test.txt' 파일에 써보세요.\nwith open('test.txt', 'w', encoding='utf-8') as f:\n    f.write(message)\n\nprint(\"'test.txt' 파일이 생성되었습니다.\")",
            "sections": [
              {
                "heading": "핵심 개념",
                "text": "파일 입출력(I/O)은 프로그램이 디스크의 파일 데이터를 읽거나 쓰는 것을 의미합니다 [cite: 2630-2631]. 이를 통해 프로그램 종료 후에도 데이터를 영구 보존(persistence)할 수 있습니다.",
                "code": null
              },
              {
                "heading": "기본 문법",
                "text": "`with open()` 구문을 사용하면 파일을 사용한 뒤 자동으로 닫아주어 안전합니다 [cite: 2665-2666].",
                "code": "# 파일 쓰기 ('w': 덮어쓰기, 'a': 이어쓰기, 'wb': 쓰기 바이너리)\nwith open('memo.txt', 'w', encoding='utf-8') as f:\n    f.write(\"안녕하세요\\n\")\n\n# 파일 읽기 ('r': 읽기, 'rb': 읽기 바이너리)\nwith open('memo.txt', 'r', encoding='utf-8') as f:\n    content = f.read() # 전체 읽기\n    # line = f.readline() # 한 줄 읽기"
              },
              {
                "heading": "활용 사례",
                "text": "사용자 설정 저장, 게임 진행 상황 저장, 데이터 분석을 위한 로그 파일 기록 등 프로그램의 상태나 결과를 보존해야 하는 모든 곳에 사용됩니다.",
                "code": null
              },
              {
                "heading": "주의점 및 팁",
                "text": "쓰기 모드('w')는 기존 파일 내용을 전부 삭제합니다. 이어 쓰려면 추가 모드('a')를 사용하세요 [cite: 2680-2681]. 텍스트 파일을 다룰 때는 `encoding='utf-8'`을 명시하는 것이 좋습니다.",
                "code": null
              }
            ]
          },
          "syntax_key": {
            "syntax_title": "print()",
            "syntax_comment": "`print()`는 괄호 안의 값을 화면에 출력하는 내장 함수입니다.",
            "systax_code": "print(\"Hello World\")"
          },
          "task": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "서버 이벤트 로그 기록",
            "content": "서버 이벤트를 파일에 기록해야 합니다. <span class='font-bold text-yellow-300'>`log_message` 내용을 `server.log` 파일에 새로 쓰는(write)</span> 코드를 작성해주세요. 그리고 기록 확인을 위해, <span class='font-bold text-yellow-300'>파일 전체 내용을 다시 읽어서(read)</span> `content` 변수에 저장해야 합니다. <span class='font-bold text-yellow-300'>`with open()` 구문</span>을 사용하세요."
          },
          "briefing": {
            "character": "sena",
            "subtitle": "직속 선임의 OJT",
            "title": "파일 열고, 쓰고, 읽기",
            "content": "파일 작업은 <span class='font-bold text-teal-300'>`with open()`</span> 구문을 쓰는 게 안전해요 [cite: 2665-2666]. `starterCode` 빈칸을 채워봅시다! 첫 `with open` 빈칸에는 각각 <span class='font-bold text-teal-300'>`filename`, `'w'`, `'utf-8'`, `f`</span>를 넣으세요 ('w'는 쓰기 모드). 다음 빈칸에는 <span class='font-bold text-teal-300'>`f.write(log_message)`</span>를 넣어 파일에 내용을 쓰고요. 두 번째 `with open` 빈칸에는 <span class='font-bold text-teal-300'>`filename`, `'r'`, `'utf-8'`, `f`</span>를 넣고 ('r'은 읽기 모드), 마지막 빈칸에는 <span class='font-bold text-teal-300'>`f.read()`</span>를 넣어 파일 내용을 읽어오면 됩니다!"
          },
          "starterCode": "import time\n\nlog_message = f\"{time.strftime('%Y-%m-%d %H:%M:%S')} - Server started.\"\nfilename = \"server.log\"\n\n# TODO: 1. 아래 빈칸들을 채워 'filename' 파일을 쓰기('w') 모드로 여세요.\n# 형식: with open(파일명, 모드, encoding='utf-8') as 별명:\nwith open(, '', encoding='') as :\n    # TODO: 2. 아래 빈칸들을 채워 log_message를 파일에 쓰세요.\n    # 형식: 파일별명.write(쓸 내용)\n    .write()\n\n# 파일 쓰기 완료 후\ncontent = \"\"\n# TODO: 3. 아래 빈칸들을 채워 'filename' 파일을 읽기('r') 모드로 여세요.\nwith open(, '', encoding='') as :\n    # TODO: 4. '=' 오른쪽에 파일 전체 내용을 읽어오는 코드를 작성하세요.\n    # 형식: 파일별명.read()\n    content = \n\n# 아래는 테스트용 코드입니다.\nprint(f\"파일 [{filename}] 내용:\")\nprint(content)\n",
          "testCode": "import os, time; filename=\"server.log\"; student_globals = {'time': time, 'log_message': log_message, 'filename': filename, 'content': ''}; if os.path.exists(filename): os.remove(filename); exec(student_code, student_globals); assert os.path.exists(filename), f'{filename} 파일이 생성되지 않았습니다.'; file_content = ''; try: with open(filename, 'r', encoding='utf-8') as f: file_content = f.read(); except Exception as e: assert False, f'파일 읽기 중 오류 발생: {e}'; expected_end = ' - Server started.'; assert file_content.endswith(expected_end), f'파일에 저장된 로그 메시지 내용({file_content})이 올바르지 않습니다.'; assert 'content' in student_globals and student_globals['content'] == file_content, '파일에서 읽은 내용이 content 변수에 올바르게 저장되지 않았습니다.'; if os.path.exists(filename): os.remove(filename)",
          "feedback": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "파일 처리 완료",
              "content": "<span class='font-bold text-green-300'>파일에 정확히 기록되고, 다시 읽어오는 것까지 확인했습니다.</span> / <span class='font-bold text-green-300'>함수가 로그 메시지를 파일에 성공적으로 추가했습니다.</span> 훌륭합니다. 데이터를 파일로 다룰 수 있게 되었으니, 프로그램의 활용도가 더욱 높아질 것입니다."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "파일 열기나 읽기/쓰기 부분을 확인해보세요",
              "content": "파일 내용이 다르거나 작업이 제대로 안 된 것 같아요. `with open()` 빈칸에 파일 이름, 모드('w' 또는 'r'), 인코딩(`'utf-8'`), 별명(`f`)을 정확히 넣었나요? `f.write()` 괄호 안에 `log_message`를, `content =` 오른쪽에는 `f.read()`를 제대로 입력했는지 확인해주세요."
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, 파일 처리 오류!",
              "content": "파일을 다루는 코드에서 오류가 발생했어요. `with open(..., encoding='utf-8') as f:` 와 같이 파일 이름, 모드, `encoding`, `as` 키워드를 정확하게 사용했는지 확인해주세요. 콜론(`:`)이나 들여쓰기를 빠뜨렸을 수도 있어요."
            }
          },
          "task_adv": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "로그 추가 함수 완성",
            "content": "로그 메시지를 파일 끝에 계속 추가하는 `append_log` 함수를 완성해야 합니다. 함수 내부 로직을 구현하여, <span class='font-bold text-yellow-300'>주어진 파일(`filename`)을 '덧붙이기 모드(a)'로 열고</span>, 현재 시간과 함께 <span class='font-bold text-yellow-300'>`message` 내용을 파일 끝에 한 줄로 추가(write)</span>하도록 만들어주세요. <span class='font-bold text-yellow-300'>`with open()`</span>을 사용해야 합니다."
          },
          "briefing_adv": {
            "character": "sena",
            "subtitle": "직속 선임의 팁",
            "title": "파일 끝에 이어 쓰기",
            "content": "파일 내용을 지우지 않고 계속 이어서 쓰려면 <span class='font-bold text-teal-300'>`with open(파일명, 'a')`</span> 처럼 '덧붙이기(append) 모드'인 `'a'`를 사용하면 돼요 [cite: 2680-2681]. `with` 블록 안에서 <span class='font-bold text-teal-300'>`f.write(쓸내용)`</span>를 호출하면 파일 끝에 내용이 추가되죠. 아, 로그 메시지니까 한 줄 쓰고 <span class='font-bold text-teal-300'>줄바꿈 문자 `\\n`</span>을 꼭 넣어주는 게 좋겠네요!"
          },
          "starterCode_adv": "import time\n\n# 아래 함수는 주어진 파일 이름에 로그 메시지를 추가(append)합니다.\n# TODO: 함수 본문에서 'with open()'을 사용하여 파일을 '덧붙이기 모드(a)'로 열고,\n#       타임스탬프와 함께 message를 파일에 쓰도록(write) 완성하세요.\n#       (파일 끝에 줄바꿈 문자 '\\n' 추가 필요)\ndef append_log(filename, message):\n    timestamp = time.strftime('%Y-%m-%d %H:%M:%S')\n    log_entry = f\"{timestamp} - {message}\\n\"\n    \n    # 여기에 파일 덧붙이기 코드 작성\n    try:\n        with open(filename, 'a', encoding='utf-8') as f:\n            f.write(log_entry)\n    except Exception as e:\n        print(f\"로그 파일 쓰기 오류: {e}\")\n\n# 함수 호출 (수정 불필요)\nlog_file = \"app.log\"\nappend_log(log_file, \"Application started.\")\nappend_log(log_file, \"User logged in.\")\n\n# 파일 내용 확인 (수정 불필요)\ncontent = \"\"\ntry:\n    with open(log_file, 'r', encoding='utf-8') as f:\n        content = f.read()\n    print(f\"파일 [{log_file}] 내용:\")\n    print(content)\nexcept FileNotFoundError:\n    print(f\"로그 파일 '{log_file}'을 찾을 수 없습니다.\")\nexcept Exception as e:\n    print(f\"로그 파일 읽기 오류: {e}\")\n",
          "testCode_adv": "import os, time; student_globals = {'time': time, 'append_log': None, 'log_file': \"app.log\", 'content': ''}; log_file = student_globals['log_file']; if os.path.exists(log_file): os.remove(log_file); exec(student_code, student_globals); append_log_func = student_globals['append_log']; assert callable(append_log_func), 'append_log 함수가 정의되지 않았습니다.'; append_log_func(log_file, 'First log.'); append_log_func(log_file, 'Second log.'); assert os.path.exists(log_file), '로그 파일이 생성되지 않았습니다.'; content_read = ''; try: with open(log_file, 'r', encoding='utf-8') as f: content_read = f.read().strip().split('\\n'); except Exception as e: assert False, f'로그 파일 읽기 중 오류 발생: {e}'; assert len(content_read) == 2, f'로그 파일에 두 줄의 로그가 기록되어야 합니다. 실제 줄 수: {len(content_read)}'; assert content_read[0].endswith(' - First log.'), '첫 번째 로그 메시지가 올바르게 추가되지 않았습니다.'; assert content_read[1].endswith(' - Second log.'), '두 번째 로그 메시지가 올바르게 추가되지 않았습니다.'; if os.path.exists(log_file): os.remove(log_file)",
          "feedback_adv": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "파일 처리 완료",
              "content": "<span class='font-bold text-green-300'>파일에 정확히 기록되고, 다시 읽어오는 것까지 확인했습니다.</span> / <span class='font-bold text-green-300'>함수가 로그 메시지를 파일에 성공적으로 추가했습니다.</span> 훌륭합니다. 데이터를 파일로 다룰 수 있게 되었으니, 프로그램의 활용도가 더욱 높아질 것입니다."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "파일 열기나 읽기/쓰기 부분을 확인해보세요",
              "content": "파일 내용이 다르거나 작업이 제대로 안 된 것 같아요. `with open()` 빈칸에 파일 이름, 모드('w' 또는 'r'), 인코딩(`'utf-8'`), 별명(`f`)을 정확히 넣었나요? `f.write()` 괄호 안에 `log_message`를, `content =` 오른쪽에는 `f.read()`를 제대로 입력했는지 확인해주세요."
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, 파일 처리 오류!",
              "content": "파일을 다루는 코드에서 오류가 발생했어요. `with open(..., encoding='utf-8') as f:` 와 같이 파일 이름, 모드, `encoding`, `as` 키워드를 정확하게 사용했는지 확인해주세요. 콜론(`:`)이나 들여쓰기를 빠뜨렸을 수도 있어요."
            }
          }
        },
        {
          "title": "안정적인 프로그램 만들기 (예외 처리)",
          "filename": "safe_reader.py",
          "lecture": {
            "character": "profKim",
            "title": "강의 노트: 예외 처리 (Exception Handling)",
            "keyTakeaway": "`try` 블록으로 위험한 코드를 감싸고, `except` 블록으로 특정 오류가 발생했을 때의 대처 방법을 정의합니다.",
            "sandboxCode": "try:\n    num = int(\"안녕하세요\")\n    print(num)\nexcept ValueError:\n    print(\"숫자로 바꿀 수 없는 값입니다!\")",
            "sections": [
              {
                "heading": "핵심 개념",
                "text": "예외(Exception)란 프로그램 실행 중에 발생하는 예기치 않은 오류를 의미합니다 [cite: 2620-2621]. 예외 처리는 이러한 오류가 발생했을 때 프로그램이 강제 종료되지 않고, 미리 정의된 대응 절차를 수행하도록 하여 프로그램의 안정성을 높이는 기법입니다.",
                "code": null
              },
              {
                "heading": "기본 문법",
                "text": "`try` 블록에 오류 발생 가능 코드를, `except` 블록에 오류 발생 시 처리할 코드를 작성합니다. `else` 블록은 예외가 없을 때, `finally` 블록은 항상 실행됩니다 [cite: 2631-2632, 2642-2643, 2657].",
                "code": "try:\n    # 오류가 발생할 가능성이 있는 코드\n    f = open('non_existent_file.txt', 'r')\nexcept FileNotFoundError:\n    # FileNotFoundError가 발생했을 때 실행할 코드\n    print(\"파일을 찾을 수 없습니다.\")\nexcept Exception as e: # 다른 종류의 예외 처리\n    print(f\"다른 오류 발생: {e}\")\nelse:\n    # 예외가 발생하지 않았을 때 실행할 코드\n    print(\"파일 읽기 성공\")\nfinally:\n    # 오류 발생 여부와 상관없이 항상 실행되는 코드\n    print(\"작업 완료\")"
              },
              {
                "heading": "활용 사례",
                "text": "존재하지 않는 파일을 열려고 할 때 (`FileNotFoundError`), 숫자가 아닌 값을 숫자로 변환하려고 할 때 (`ValueError`), 인터넷 연결이 끊겼을 때 등 모든 종류의 오류 상황에 대처하는 데 사용됩니다.",
                "code": null
              },
              {
                "heading": "주의점 및 팁",
                "text": "`except` 뒤에 `FileNotFoundError`, `ValueError`처럼 특정 오류를 명시해주는 것이 좋습니다. 그냥 `except:`라고만 쓰면 모든 오류를 다 잡아버려서, 어떤 문제가 발생했는지 알기 어려워질 수 있습니다.",
                "code": null
              }
            ]
          },
          "syntax_key": {
            "syntax_title": "print()",
            "syntax_comment": "`print()`는 괄호 안의 값을 화면에 출력하는 내장 함수입니다.",
            "systax_code": "print(\"Hello World\")"
          },
          "task": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "파일 읽기 오류 방지",
            "content": "파일을 읽는 코드는 파일이 없을 때 오류를 일으키며 멈출 수 있습니다. <span class='font-bold text-yellow-300'>`try...except` 구문</span>을 사용하여, 존재하지 않는 파일(`non_existent_log.log`)을 열려고 할 때 발생하는 <span class='font-bold text-yellow-300'>`FileNotFoundError`를 처리</span>하고, 대신 \"로그 파일을 찾을 수 없습니다.\"라는 메시지를 출력하도록 코드를 작성해주세요."
          },
          "briefing": {
            "character": "sena",
            "subtitle": "직속 선임의 팁",
            "title": "오류 대비하기: `try-except`",
            "content": "오류가 날 만한 코드는 <span class='font-bold text-teal-300'>`try:`</span> 블록 안에 넣고, 그 오류를 처리할 코드는 <span class='font-bold text-teal-300'>`except 오류이름:`</span> 블록 안에 넣으면 돼요 [cite: 2631-2632]. `starterCode`를 봅시다! `try:` 다음 빈칸에는 없는 파일을 열려는 코드 <span class='font-bold text-teal-300'>`open('non_existent_log.log', 'r')`</span>를 넣으세요. `except` 뒤 빈칸에는 우리가 잡고 싶은 오류 이름 <span class='font-bold text-teal-300'>`FileNotFoundError`</span>를 넣고요. 마지막 `print()` 빈칸에는 오류 메시지 <span class='font-bold text-teal-300'>`\"로그 파일을 찾을 수 없습니다.\"`</span>를 넣으면, 파일이 없을 때 이 메시지가 출력될 거예요!"
          },
          "starterCode": "# TODO: 1. 아래 'try:' 블록 안에 존재하지 않는 파일('non_existent_log.log')을 읽기('r') 모드로 열려고 시도하는 코드를 작성하세요.\n#    (실제 파일을 열 필요는 없고, open() 함수 호출만 해도 됩니다.)\ntry:\n    open()\n# TODO: 2. 아래 'except' 뒤 빈칸에 처리할 오류 이름 'FileNotFoundError'를 넣으세요.\nexcept :\n    # TODO: 3. 아래 빈칸에 \"로그 파일을 찾을 수 없습니다.\" 메시지를 출력하는 print() 코드를 작성하세요.\n    print()\n",
          "testCode": "import io; from contextlib import redirect_stdout; f = io.StringIO(); student_globals = {}; with redirect_stdout(f): exec(student_code, student_globals); output = f.getvalue().strip(); expected = '로그 파일을 찾을 수 없습니다.'; assert 'try:' in source_code and 'except FileNotFoundError:' in source_code, \"'try'와 'except FileNotFoundError' 구문을 사용해야 합니다.\"; assert 'open(' in source_code.split('except')[0], \"'try' 블록 안에 파일을 열려는 시도가 없습니다.\"; assert output == expected, f\"오류 발생 시 출력 메시지가 다릅니다. 기대값: '{expected}', 실제값: '{output}'\"",
          "feedback": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "안정성 강화",
              "content": "<span class='font-bold text-green-300'>훌륭합니다. 이제 예상치 못한 오류가 발생해도 프로그램이 멈추지 않고 안정적으로 동작</span>하는군요. / <span class='font-bold text-green-300'>함수가 오류 상황을 잘 처리하고 결과를 정확히 반환합니다.</span> 예외 처리는 신뢰도 높은 프로그램을 만드는 핵심 기술입니다."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "try-except 구조를 확인해보세요",
              "content": "오류 처리가 제대로 안 됐어요. 오류가 날 만한 코드(`open(...)`)를 <span class='font-bold text-teal-300'>`try:`</span> 블록 안에 넣었는지, <span class='font-bold text-teal-300'>`except FileNotFoundError:`</span> 뒤에 콜론(:)을 찍고 그 아래에 오류 메시지를 출력하는 <span class='font-bold text-teal-300'>`print()`</span> 코드를 넣었는지 확인해주세요."
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, try-except 문법 오류!",
              "content": "`try-except` 구문에서 문법 오류가 발생했어요. `try:`와 `except FileNotFoundError:` 뒤에 콜론(`:`)을 빠뜨리진 않았나요? 그리고 각 블록에 포함되는 코드들은 반드시 들여쓰기를 해야 해요. 다시 한번 확인해볼까요?"
            }
          },
          "task_adv": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "안전한 파일 삭제 함수 완성",
            "content": "파일을 삭제하는 `safe_delete_file` 함수를 더 안정적으로 만들어야 합니다. <span class='font-bold text-yellow-300'>`try...except` 구문</span>을 사용하여, `os.remove()` 호출 시 파일이 없어 발생하는 <span class='font-bold text-yellow-300'>`FileNotFoundError`를 처리</span>하도록 수정해주세요. 오류 발생 시에는 메시지를 출력하고 <span class='font-bold text-yellow-300'>`False`를 반환</span>하고, 성공적으로 삭제하면 <span class='font-bold text-yellow-300'>`True`를 반환</span>해야 합니다."
          },
          "briefing_adv": {
            "character": "sena",
            "subtitle": "직속 선임의 팁",
            "title": "오류 잡고 결과 알려주기",
            "content": "파일 삭제(`os.remove`)처럼 실패할 수 있는 코드는 <span class='font-bold text-teal-300'>`try` 블록</span> 안에 넣는 게 좋아요. 그리고 만약 파일이 없어서 `FileNotFoundError`가 발생하면, <span class='font-bold text-teal-300'>`except FileNotFoundError:` 블록</span>에서 처리해주면 되죠. 여기서 메시지를 출력하고 `False`를 <span class='font-bold text-teal-300'>`return`</span>하면 되고, `try` 블록에서 삭제가 성공했다면 그 다음에 `True`를 <span class='font-bold text-teal-300'>`return`</span>하면 함수가 완성될 거예요!"
          },
          "starterCode_adv": "import os\n\n# 아래 함수는 파일을 삭제하는 함수입니다.\n# TODO: try-except 구문을 사용하여 os.remove() 호출 시 발생할 수 있는\n#       FileNotFoundError 예외를 처리하고, 오류 발생 시 False를 반환하세요.\n#       성공적으로 삭제하면 True를 반환해야 합니다.\ndef safe_delete_file(filename):\n    try:\n        os.remove(filename)\n        # 여기에 성공 시 True 반환 코드 추가\n        return True\n    except FileNotFoundError:\n        print(f\"오류: 파일 '{filename}'을(를) 찾을 수 없습니다.\")\n        # 여기에 실패 시 False 반환 코드 추가\n        return False\n    # return False # 이 줄은 위에서 처리되므로 삭제 가능\n\n# 함수 호출 및 결과 확인 (수정 불필요)\nresult1 = safe_delete_file(\"temp_file.txt\") # 존재하지 않는 파일\nprint(f\"삭제 시도 1 결과: {result1}\")\n\n# 테스트용 임시 파일 생성\nwith open(\"temp_file.txt\", 'w') as f:\n    f.write(\"test\")\nresult2 = safe_delete_file(\"temp_file.txt\") # 존재하는 파일\nprint(f\"삭제 시도 2 결과: {result2}\")\n\n# 테스트 파일 정리 (실제 실행 시 필요할 수 있음)\n# if os.path.exists(\"temp_file.txt\"): os.remove(\"temp_file.txt\")\n",
          "testCode_adv": "import os; student_globals = {'os': os, 'safe_delete_file': None}; exec(student_code, student_globals); safe_delete_file_func = student_globals['safe_delete_file']; assert callable(safe_delete_file_func), 'safe_delete_file 함수가 정의되지 않았습니다.'; result_not_found = safe_delete_file_func('non_existent_file_for_test.xyz'); assert result_not_found is False, '존재하지 않는 파일 삭제 시 False를 반환해야 합니다.'; test_filename = 'temp_test_file.txt'; with open(test_filename, 'w') as f: f.write('delete test'); result_found = safe_delete_file_func(test_filename); assert result_found is True, '존재하는 파일 삭제 성공 시 True를 반환해야 합니다.'; assert not os.path.exists(test_filename), '파일이 실제로 삭제되지 않았습니다.'; # Cleanup test file\nif os.path.exists(test_filename): os.remove(test_filename)",
          "feedback_adv": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "안정성 강화",
              "content": "<span class='font-bold text-green-300'>훌륭합니다. 이제 예상치 못한 오류가 발생해도 프로그램이 멈추지 않고 안정적으로 동작</span>하는군요. / <span class='font-bold text-green-300'>함수가 오류 상황을 잘 처리하고 결과를 정확히 반환합니다.</span> 예외 처리는 신뢰도 높은 프로그램을 만드는 핵심 기술입니다."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "try-except 구조를 확인해보세요",
              "content": "오류 처리가 제대로 안 됐어요. 오류가 날 만한 코드(`open(...)`)를 <span class='font-bold text-teal-300'>`try:`</span> 블록 안에 넣었는지, <span class='font-bold text-teal-300'>`except FileNotFoundError:`</span> 뒤에 콜론(:)을 찍고 그 아래에 오류 메시지를 출력하는 <span class='font-bold text-teal-300'>`print()`</span> 코드를 넣었는지 확인해주세요."
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, try-except 문법 오류!",
              "content": "`try-except` 구문에서 문법 오류가 발생했어요. `try:`와 `except FileNotFoundError:` 뒤에 콜론(`:`)을 빠뜨리진 않았나요? 그리고 각 블록에 포함되는 코드들은 반드시 들여쓰기를 해야 해요. 다시 한번 확인해볼까요?"
            }
          }
        }
      ]
    },
    {
      "week": 11,
      "title": "파이썬 생태계 첫걸음: 표준 라이브러리와 외부 패키지",
      "cycles": [
        {
          "title": "파이썬의 기본 도구함, 표준 라이브러리",
          "filename": "backup_v2.py",
          "lecture": {
            "character": "profKim",
            "title": "강의 노트: 표준 라이브러리",
            "keyTakeaway": "표준 라이브러리는 파이썬에 내장된 강력한 모듈 모음이며, `import`하여 바로 사용할 수 있습니다.",
            "sandboxCode": "import random\n\n# 1부터 100 사이의 무작위 숫자를 뽑아 출력해보세요.\nrandom_number = random.randint(1, 100)\nprint(f\"1부터 100 사이의 무작위 숫자: {random_number}\")",
            "sections": [
              {
                "heading": "핵심 개념",
                "text": "파이썬 표준 라이브러리는 파이썬을 설치할 때 기본적으로 함께 설치되는 방대한 양의 모듈 모음입니다 [cite: 2678-2679]. 파일 처리(`zipfile`, `os`), 운영체제 제어(`sys`), 인터넷 통신, 날짜/시간 관리(`time`, `datetime`) 등 자주 사용되는 기능들이 미리 만들어져 있어, 개발자는 복잡한 기능을 직접 구현할 필요 없이 가져다 쓰기만 하면 됩니다.",
                "code": null
              },
              {
                "heading": "기본 문법 (`zipfile` 예시)",
                "text": "필요한 모듈을 `import` 키워드로 불러와 사용합니다.",
                "code": "# 표준 라이브러리 모듈을 불러와 사용\nimport zipfile\nimport os\n\n# zipfile 모듈을 사용해 ZIP 파일 생성\nwith zipfile.ZipFile('backup.zip', 'w') as myzip:\n    # 파일 추가 (filename: 원본 경로, arcname: 압축 파일 내 경로/이름 - 생략 시 filename 사용)\n    myzip.write('important_file.txt') # 'important_file.txt' 이름으로 압축됨"
              },
              {
                "heading": "활용 사례",
                "text": "날짜를 다루는 `datetime`, 수학 계산을 위한 `math`, 무작위 숫자를 만드는 `random`, 파일 시스템을 다루는 `os` 등 모든 종류의 프로그램을 만들 때 필수적으로 사용됩니다.",
                "code": null
              },
              {
                "heading": "주의점 및 팁",
                "text": "어떤 기능이 필요할 때, 직접 만들기 전에 먼저 표준 라이브러리에 있는지 찾아보는 습관은 매우 좋은 습관입니다 [cite: 2735-2736]. 파이썬 공식 문서에서 모든 표준 라이브러리 목록과 사용법을 확인할 수 있습니다.",
                "code": null
              }
            ]
          },
          "syntax_key": {
            "syntax_title": "print()",
            "syntax_comment": "`print()`는 괄호 안의 값을 화면에 출력하는 내장 함수입니다.",
            "systax_code": "print(\"Hello World\")"
          },
          "task": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "백업 스크립트 기능 개선 (zipfile)",
            "content": "이전 백업 스크립트의 의존성 문제를 해결하기 위해, 파이썬 <span class='font-bold text-yellow-300'>표준 라이브러리 `zipfile`</span>을 사용하도록 코드를 개선합니다. <span class='font-bold text-yellow-300'>`zipfile.ZipFile`</span>을 사용하여 `backup.zip` 파일을 열고, `important_data.txt` 파일을 이 <span class='font-bold text-yellow-300'>ZIP 아카이브에 추가</span>하는 코드를 작성해주세요. `with` 구문을 사용해야 합니다."
          },
          "briefing": {
            "character": "sena",
            "subtitle": "직속 선임의 OJT",
            "title": "파이썬 내장 압축 도구: `zipfile`",
            "content": "파이썬에는 파일을 압축하는 <span class='font-bold text-teal-300'>`zipfile`</span>이라는 기본 도구가 있어요! `starterCode`를 봅시다. 첫 빈칸에는 <span class='font-bold text-teal-300'>`import zipfile`</span>을 넣어 도구를 불러오세요. 다음 `with`문 빈칸에는 각각 <span class='font-bold text-teal-300'>`zipfile`, `target_zip`, `'w'`, `myzip`</span>을 넣어 압축 파일을 열어요 ('w'는 쓰기 모드). 마지막 빈칸에는 <span class='font-bold text-teal-300'>`myzip.write(source_file)`</span>을 넣어 파일을 압축 파일에 추가하면 됩니다!"
          },
          "starterCode": "import os\n# TODO: 1. 아래 빈칸에 'zipfile' 모듈을 불러오는(import) 코드를 작성하세요.\n\n\n# 백업할 테스트용 파일을 생성합니다. (수정 불필요)\nwith open('important_data.txt', 'w', encoding='utf-8') as f:\n    f.write('This is important data.')\n\nsource_file = 'important_data.txt'\ntarget_zip = 'backup.zip'\n\n# TODO: 2. 아래 빈칸들을 채워 'target_zip' 파일을 쓰기('w') 모드로 여세요.\n# 형식: with zipfile.ZipFile(파일명, 모드) as 별명:\nwith .ZipFile(, '') as :\n    # TODO: 3. 아래 빈칸들을 채워 source_file을 압축 파일에 추가하세요.\n    # 형식: zip파일별명.write(압축할파일)\n    .write()\n\n# 아래는 테스트용 코드입니다. (수정 불필요)\nif os.path.exists(target_zip):\n    print(f\"'{target_zip}' 파일이 성공적으로 생성되었습니다.\")\n# 생성된 테스트 파일 삭제 (실제 실행 시 필요)\n# if os.path.exists(source_file): os.remove(source_file)\n# if os.path.exists(target_zip): os.remove(target_zip)\n",
          "testCode": "import os, zipfile; file_content_check = 'This is important data.'; source_file = 'important_data.txt'; target_zip = 'backup.zip'; student_globals = {'os': os, 'source_file': source_file, 'target_zip': target_zip}; if os.path.exists(source_file): os.remove(source_file); if os.path.exists(target_zip): os.remove(target_zip); try: with open(source_file, 'w', encoding='utf-8') as f: f.write(file_content_check); except Exception: pass; exec(student_code, student_globals); assert os.path.exists(target_zip), f'{target_zip} 파일이 생성되지 않았습니다.'; zf = None; extracted_content = ''; error_msg = ''; try: zf = zipfile.ZipFile(target_zip, 'r'); assert source_file in zf.namelist(), f'ZIP 파일 안에 {source_file}이 없습니다.'; extracted_content = zf.read(source_file).decode('utf-8'); except Exception as e: error_msg = f'ZIP 파일 검증 중 오류: {e}'; finally: if zf: zf.close(); if error_msg: assert False, error_msg; assert extracted_content == file_content_check, f'압축된 파일의 내용({extracted_content})이 원본({file_content_check})과 다릅니다.'; if os.path.exists(source_file): os.remove(source_file); if os.path.exists(target_zip): os.remove(target_zip)",
          "feedback": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "표준 라이브러리 활용 성공",
              "content": "<span class='font-bold text-green-300'>훌륭합니다. `zipfile` 모듈을 사용하여 압축 파일을 성공적으로 생성했군요.</span> 이렇게 표준 라이브러리를 잘 활용하면 프로그램의 안정성과 이식성을 크게 높일 수 있습니다."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "zipfile 사용법을 확인해보세요",
              "content": "압축 파일이 제대로 생성되지 않았거나 내용이 비어있네요. 모듈을 `import zipfile`로 불러왔는지, `with zipfile.ZipFile(target_zip, 'w') as myzip:` 형태로 파일을 열었는지, `myzip.write(source_file)` 코드로 파일을 추가했는지 확인해주세요. 파일 이름이나 모드('w')에 오타는 없는지도요!"
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, zipfile 사용 오류!",
              "content": "`zipfile` 모듈을 사용하는 코드에서 오류가 발생했어요. `zipfile.ZipFile(파일명, 모드)` 처럼 클래스 이름과 메소드 이름에 오타는 없는지, 필요한 인자를 정확하게 전달했는지 문법을 다시 한번 꼼꼼하게 확인해주세요."
            }
          },
          "task_adv": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "ZIP 압축 함수 완성",
            "content": "파일 목록을 받아 ZIP 파일로 압축하는 `create_backup_zip` 함수를 완성해야 합니다. 함수 내부에서 <span class='font-bold text-yellow-300'>`zipfile` 모듈</span>을 사용하여, `sources` 리스트에 있는 <span class='font-bold text-yellow-300'>각 파일을 `target_zip` 아카이브에 추가</span>하는 로직을 구현해주세요. 파일이 존재하지 않는 경우에 대한 처리도 이미 포함되어 있습니다."
          },
          "briefing_adv": {
            "character": "sena",
            "subtitle": "직속 선임의 팁",
            "title": "여러 파일 압축하기",
            "content": "여러 파일을 압축하려면, 먼저 <span class='font-bold text-teal-300'>`with zipfile.ZipFile(...)`</span>로 압축 파일을 열고, 그 안에서 <span class='font-bold text-teal-300'>`for` 루프</span>로 파일 목록(`sources`)을 순회하면 돼요. 루프 안에서는 각 파일에 대해 <span class='font-bold text-teal-300'>`zipf.write(파일경로, 압축내_파일이름)`</span>를 호출해주면 되죠. `os.path.basename()` 함수를 쓰면 파일 경로에서 이름만 쉽게 추출할 수 있어요!"
          },
          "starterCode_adv": "import os\nimport zipfile\nimport time\n\n# 아래 함수는 지정된 파일 목록(sources)을 target_zip 파일로 압축합니다.\n# TODO: 함수 본문에서 zipfile 모듈을 사용하여 sources 리스트의 각 파일을\n#       target_zip 아카이브에 추가하는 로직을 완성하세요.\ndef create_backup_zip(target_zip, sources):\n    print(f\"압축 파일 생성 시작: {target_zip}\")\n    try:\n        # 여기에 zipfile을 열고 파일을 추가하는 코드 작성\n        with zipfile.ZipFile(target_zip, 'w') as zipf:\n            for file in sources:\n                if os.path.exists(file):\n                    # 파일을 아카이브에 추가 (파일 이름만 사용)\n                    zipf.write(file, os.path.basename(file))\n                    print(f\" - {file} 추가 완료\")\n                else:\n                    print(f\" - 경고: {file}을(를) 찾을 수 없습니다.\")\n        print(\"압축 파일 생성 완료!\")\n        return True\n    except Exception as e:\n        print(f\"압축 중 오류 발생: {e}\")\n        return False\n\n# 함수 호출 (수정 불필요)\n# 테스트용 파일 생성\nfile_list = ['log1.txt', 'report.docx']\nfor fname in file_list:\n    with open(fname, 'w', encoding='utf-8') as f:\n        f.write(f'Content of {fname}')\n\nbackup_filename = f\"backup_{time.strftime('%Y%m%d')}.zip\"\ncreate_backup_zip(backup_filename, file_list + ['non_existent.txt'])\n\n# 생성된 테스트 파일 및 zip 파일 삭제 (실제 실행 시 필요)\n# for fname in file_list: \n#     if os.path.exists(fname): os.remove(fname)\n# if os.path.exists(backup_filename): os.remove(backup_filename)\n",
          "testCode_adv": "import os, zipfile, time; student_globals = {'os': os, 'zipfile': zipfile, 'time': time, 'create_backup_zip': None}; test_files = ['test1.tmp', 'test2.tmp']; for fname in test_files: with open(fname, 'w') as f: f.write(fname); backup_fn_test = f'test_backup_{time.strftime('%Y%m%d')}.zip'; if os.path.exists(backup_fn_test): os.remove(backup_fn_test); exec(student_code, student_globals); create_backup_zip_func = student_globals['create_backup_zip']; assert callable(create_backup_zip_func), 'create_backup_zip 함수가 정의되지 않았습니다.'; success = create_backup_zip_func(backup_fn_test, test_files); assert success is True, '백업 함수가 성공 시 True를 반환해야 합니다.'; assert os.path.exists(backup_fn_test), '백업 zip 파일이 생성되지 않았습니다.'; zf = None; zipped_files = []; error_msg = ''; try: zf = zipfile.ZipFile(backup_fn_test, 'r'); zipped_files = zf.namelist(); except Exception as e: error_msg = f'zip 파일 검증 중 오류: {e}'; finally: if zf: zf.close(); if error_msg: assert False, error_msg; assert set(zipped_files) == set(os.path.basename(f) for f in test_files), f'zip 파일 내 파일 목록({zipped_files})이 올바르지 않습니다.'; for fname in test_files: if os.path.exists(fname): os.remove(fname); if os.path.exists(backup_fn_test): os.remove(backup_fn_test)",
          "feedback_adv": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "표준 라이브러리 활용 성공",
              "content": "<span class='font-bold text-green-300'>훌륭합니다. `zipfile` 모듈을 사용하여 압축 파일을 성공적으로 생성했군요.</span> 이렇게 표준 라이브러리를 잘 활용하면 프로그램의 안정성과 이식성을 크게 높일 수 있습니다."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "zipfile 사용법을 확인해보세요",
              "content": "압축 파일이 제대로 생성되지 않았거나 내용이 비어있네요. 모듈을 `import zipfile`로 불러왔는지, `with zipfile.ZipFile(target_zip, 'w') as myzip:` 형태로 파일을 열었는지, `myzip.write(source_file)` 코드로 파일을 추가했는지 확인해주세요. 파일 이름이나 모드('w')에 오타는 없는지도요!"
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, zipfile 사용 오류!",
              "content": "`zipfile` 모듈을 사용하는 코드에서 오류가 발생했어요. `zipfile.ZipFile(파일명, 모드)` 처럼 클래스 이름과 메소드 이름에 오타는 없는지, 필요한 인자를 정확하게 전달했는지 문법을 다시 한번 꼼꼼하게 확인해주세요."
            }
          }
        },
        {
          "title": "외부 라이브러리 설치 및 활용 (pip)",
          "filename": "time_checker.py",
          "lecture": {
            "character": "profKim",
            "title": "강의 노트: pip와 외부 라이브러리",
            "keyTakeaway": "`pip install [패키지명]`으로 외부 라이브러리를 설치하고, `import`하여 강력한 기능들을 활용할 수 있습니다.",
            "sandboxCode": "# requests 라이브러리가 설치되었다고 가정합니다.\nimport requests\n\n# 테스트용 공개 API를 호출합니다.\nresponse = requests.get('https://jsonplaceholder.typicode.com/todos/1')\nprint(response.json())",
            "sections": [
              {
                "heading": "핵심 개념",
                "text": "PyPI(Python Package Index)는 파이썬을 위한 공식 서드파티 소프트웨어 저장소입니다. `pip`는 PyPI에 등록된 패키지(라이브러리)들을 설치하고 관리하는 공식 패키지 관리 도구입니다 [cite: 2792-2793]. 이를 통해 우리는 웹 요청(`requests`), 데이터 분석 등 거의 모든 분야의 강력한 기능들을 손쉽게 활용할 수 있습니다.",
                "code": null
              },
              {
                "heading": "기본 문법 (`requests` 예시)",
                "text": "먼저 터미널에서 패키지를 설치한 후 (`pip install requests`), 파이썬 코드에서 `import`하여 사용합니다.",
                "code": "# 1. 터미널(명령 프롬프트)에서 패키지 설치\n# pip install requests\n\n# 2. 파이썬 코드에서 불러와 사용\nimport requests\n\ntry:\n    response = requests.get('https://api.example.com/data', timeout=5) # 5초 이상 걸리면 타임아웃\n    response.raise_for_status() # 200 OK 아니면 오류 발생\n    data = response.json() # JSON 응답을 딕셔너리로 변환\n    print(data)\nexcept requests.exceptions.RequestException as e:\n    print(f\"API 호출 실패: {e}\")"
              },
              {
                "heading": "활용 사례",
                "text": "웹 프레임워크(Flask, Django), 데이터 과학(Pandas, NumPy), 인공지능(TensorFlow, PyTorch) 등 현대적인 파이썬 개발의 거의 모든 영역이 외부 라이브러리를 기반으로 이루어집니다.",
                "code": null
              },
              {
                "heading": "주의점 및 팁",
                "text": "프로젝트에 사용된 외부 라이브러리 목록을 `requirements.txt` 파일에 기록해두면, 다른 개발자가 `pip install -r requirements.txt` 명령어로 동일한 개발 환경을 쉽게 구축할 수 있습니다.",
                "code": null
              }
            ]
          },
          "syntax_key": {
            "syntax_title": "print()",
            "syntax_comment": "`print()`는 괄호 안의 값을 화면에 출력하는 내장 함수입니다.",
            "systax_code": "print(\"Hello World\")"
          },
          "task": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "외부 API 연동 기초",
            "content": "외부 API를 호출하여 데이터를 가져오는 연습을 합니다. 미리 준비된 <span class='font-bold text-yellow-300'>`requests` 객체</span>를 사용하여 WorldTimeAPI(`url` 변수)를 호출하고, <span class='font-bold text-yellow-300'>응답받은 JSON 데이터</span>에서 <span class='font-bold text-yellow-300'>'datetime' 키에 해당하는 값을 `seoul_time` 변수에 저장</span>해주세요."
          },
          "briefing": {
            "character": "sena",
            "subtitle": "직속 선임의 팁",
            "title": "웹에서 데이터 가져오기: `requests`",
            "content": "외부 라이브러리 `requests`는 웹 API에 요청을 보내고 응답을 쉽게 받게 해줘요. `starterCode` 빈칸을 채워볼까요? 첫 빈칸에는 <span class='font-bold text-teal-300'>`requests.get(url)`</span>을 넣어 API를 호출하고 응답을 받아요. 두 번째 빈칸에는 <span class='font-bold text-teal-300'>`response.json()`</span>을 넣어 JSON 데이터를 딕셔너리로 바꾸고요. 마지막 빈칸에는 딕셔너리에서 값을 꺼내는 <span class='font-bold text-teal-300'>`data['datetime']`</span> 코드를 넣으면, 서울 시간 정보를 얻을 수 있을 거예요!"
          },
          "starterCode": "# --- 가상 라이브러리 --- \n# 실제로는 'pip install requests'를 통해 설치해야 하지만,\n# 학습 환경을 위해 requests 객체를 아래와 같이 시뮬레이션합니다.\nclass MockResponse: def json(self): return {'datetime': '2025-10-01T12:30:00+09:00'}\nclass MockRequests: def get(self, url): print(f\"GET {url}\"); return MockResponse()\nrequests = MockRequests()\n# --------------------------\n\nurl = \"http://worldtimeapi.org/api/timezone/Asia/Seoul\"\nseoul_time = \"\"\n\n# TODO: 1. '=' 오른쪽에 requests 객체를 사용하여 url 주소로 GET 요청을 보내고 응답(response)을 받는 코드를 작성하세요.\n# 형식: requests.get(주소)\nresponse = \n\n# TODO: 2. '=' 오른쪽에 응답(response) 객체의 .json() 메소드를 호출하여 JSON 데이터를 딕셔너리로 변환하는 코드를 작성하세요.\ndata = \n\n# TODO: 3. '=' 오른쪽에 위 딕셔너리(data)에서 'datetime' 키에 해당하는 값을 가져오는 코드를 작성하세요.\n# 형식: 딕셔너리이름['키이름']\nseoul_time = \n\n# 아래는 테스트용 코드입니다.\nprint(seoul_time)\n",
          "testCode": "student_globals = {'requests': requests, 'url': url, 'seoul_time': ''}; exec(student_code, student_globals); assert 'seoul_time' in student_globals, \"'seoul_time' 변수가 정의되지 않았습니다.\"; expected = '2025-10-01T12:30:00+09:00'; assert student_globals['seoul_time'] == expected, f\"seoul_time 변수에 저장된 값이 다릅니다. 기대값: '{expected}', 실제값: '{student_globals['seoul_time']}'\"",
          "feedback": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "외부 세계와의 연결",
              "content": "<span class='font-bold text-green-300'>외부 API를 호출하여 데이터를 성공적으로 가져왔군요!</span> / <span class='font-bold text-green-300'>함수가 API 호출 및 예외 처리를 통해 데이터를 잘 가져옵니다.</span> 이것은 현대적인 서비스 개발의 기본입니다. 이제 파이썬 생태계를 활용할 준비가 되었습니다."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "requests 사용법이나 키 이름을 확인해보세요",
              "content": "API 호출이나 데이터 추출이 잘못된 것 같아요. 첫 빈칸에 <span class='font-bold text-teal-300'>`requests.get(url)`</span>, 두 번째에 <span class='font-bold text-teal-300'>`response.json()`</span>, 세 번째에 <span class='font-bold text-teal-300'>`data['datetime']`</span> 코드를 정확히 입력했는지 확인해주세요. 함수나 메소드 이름, 딕셔너리 키 이름에 오타가 없는지도요!"
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, requests 사용 오류!",
              "content": "`requests` 라이브러리를 사용하는 부분에서 오류가 발생했어요. `requests.get(url)` 함수를 올바르게 호출했는지, 응답 객체의 메소드(`.json()`, `.raise_for_status()`) 이름에 오타는 없는지 확인해주세요. 실제 환경에서는 `import requests`를 했는지도 확인해야 하고요."
            }
          },
          "task_adv": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "API 호출 함수 완성",
            "content": "API를 호출하여 Unix 시간을 가져오는 `get_current_unixtime` 함수를 완성해야 합니다. 함수 내부에서 <span class='font-bold text-yellow-300'>`requests.get()`</span>을 호출하고, 응답 오류를 확인(`raise_for_status()`)한 뒤, <span class='font-bold text-yellow-300'>JSON 데이터에서 'unixtime' 값을 추출하여 반환</span>하도록 로직을 구현하세요. <span class='font-bold text-yellow-300'>API 호출 중 발생할 수 있는 모든 예외(Exception)를 처리</span>하여 오류 발생 시 `None`을 반환해야 합니다."
          },
          "briefing_adv": {
            "character": "sena",
            "subtitle": "직속 선임의 팁",
            "title": "안전하게 API 호출하기",
            "content": "API 호출은 네트워크 문제 등으로 실패할 수 있으니 <span class='font-bold text-teal-300'>`try...except`</span>로 감싸주는 게 좋아요. `try` 블록 안에서 <span class='font-bold text-teal-300'>`response = requests.get(url, timeout=5)`</span>로 호출하고, <span class='font-bold text-teal-300'>`response.raise_for_status()`</span>로 혹시 오류 응답이 왔는지 확인해요 [cite: 2717-2718]. 이상 없으면 <span class='font-bold text-teal-300'>`response.json()['unixtime']`</span> 값을 `return`하고, `except requests.exceptions.RequestException:` 블록 (혹은 더 넓게 `except Exception:`) 에서는 오류 메시지를 출력하고 `None`을 `return`하면 안전한 함수가 완성돼요!"
          },
          "starterCode_adv": "# --- 가상 라이브러리 --- \nimport time\nclass MockResponse: \n    def __init__(self, ok=True): self._ok = ok; self._status_code = 200 if ok else 404\n    @property\n    def status_code(self): return self._status_code\n    def raise_for_status(self): \n        if not self._ok: raise Exception(f'API Error {self._status_code}')\n    def json(self): \n        if not self._ok: return {}\n        # Simulate slight delay sometimes\n        if time.time() % 3 > 1: return {'unixtime': 1767225600 + 3600}\n        else: return {'unixtime': 1767225600}\nclass MockRequestsException(Exception): pass\nclass MockRequests:\n    class exceptions:\n        RequestException = MockRequestsException\n    def get(self, url, timeout=5): \n        print(f\"GET {url}\")\n        # Simulate occasional errors or network issues\n        rand_val = time.time() % 7\n        if rand_val < 1: raise self.exceptions.RequestException(\"Connection timed out\")\n        return MockResponse(ok=rand_val > 2)\nrequests = MockRequests()\n# --------------------------\n\n# 아래 함수는 API를 호출하여 현재 Unix 시간을 가져옵니다.\n# TODO: 함수 본문에서 try-except 블록을 사용하여 API 호출 및 데이터 추출 로직을 완성하세요.\n# 1. requests.get()으로 API 호출 (타임아웃 5초).\n# 2. response.raise_for_status()로 오류 확인.\n# 3. response.json()에서 'unixtime' 값을 추출하여 반환.\n# 4. requests 관련 예외(requests.exceptions.RequestException) 및 기타 예외 발생 시 None을 반환.\ndef get_current_unixtime(url=\"http://worldtimeapi.org/api/ip\"):\n    try:\n        # 여기에 API 호출 및 데이터 추출 코드 작성\n        response = requests.get(url, timeout=5)\n        response.raise_for_status() # HTTP 오류 체크\n        data = response.json()\n        return data.get('unixtime') # .get() 사용으로 KeyError 방지\n    except requests.exceptions.RequestException as e: # requests 관련 오류 처리\n        print(f\"API 요청 오류: {e}\")\n        return None\n    except Exception as e: # 기타 예외 처리 (예: JSON 파싱 오류 등)\n        print(f\"데이터 처리 오류: {e}\")\n        return None\n    # return None # try 블록에서 반환하거나 except 블록에서 None 반환하므로 불필요\n\n# 함수 호출 및 결과 확인 (수정 불필요)\ncurrent_time = get_current_unixtime()\nif current_time:\n    print(f\"현재 Unix 시간: {current_time}\")\nelse:\n    print(\"시간 정보를 가져오는데 실패했습니다.\")\n",
          "testCode_adv": "import time; student_globals = {'requests': requests, 'time': time, 'get_current_unixtime': None}; exec(student_code, student_globals); get_current_unixtime_func = student_globals['get_current_unixtime']; assert callable(get_current_unixtime_func), 'get_current_unixtime 함수가 정의되지 않았습니다.'; # 여러 번 실행하여 성공/실패 케이스 확인\nresults = [get_current_unixtime_func() for _ in range(5)]; print(f'API 호출 결과들: {results}'); assert any(isinstance(r, int) for r in results if r is not None) or all(r is None for r in results), '함수는 정수(Unix 시간) 또는 None을 반환해야 합니다.'; assert any(r is None for r in results), '예외 처리(None 반환)가 제대로 동작하지 않는 것 같습니다.'",
          "feedback_adv": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "외부 세계와의 연결",
              "content": "<span class='font-bold text-green-300'>외부 API를 호출하여 데이터를 성공적으로 가져왔군요!</span> / <span class='font-bold text-green-300'>함수가 API 호출 및 예외 처리를 통해 데이터를 잘 가져옵니다.</span> 이것은 현대적인 서비스 개발의 기본입니다. 이제 파이썬 생태계를 활용할 준비가 되었습니다."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "requests 사용법이나 키 이름을 확인해보세요",
              "content": "API 호출이나 데이터 추출이 잘못된 것 같아요. 첫 빈칸에 <span class='font-bold text-teal-300'>`requests.get(url)`</span>, 두 번째에 <span class='font-bold text-teal-300'>`response.json()`</span>, 세 번째에 <span class='font-bold text-teal-300'>`data['datetime']`</span> 코드를 정확히 입력했는지 확인해주세요. 함수나 메소드 이름, 딕셔너리 키 이름에 오타가 없는지도요!"
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, requests 사용 오류!",
              "content": "`requests` 라이브러리를 사용하는 부분에서 오류가 발생했어요. `requests.get(url)` 함수를 올바르게 호출했는지, 응답 객체의 메소드(`.json()`, `.raise_for_status()`) 이름에 오타는 없는지 확인해주세요. 실제 환경에서는 `import requests`를 했는지도 확인해야 하고요."
            }
          }
        }
      ]
    },
    {
      "week": 12,
      "title": "최종 프로젝트: 주소록 관리 프로그램 제작",
      "cycles": [
        {
          "title": "최종 프로젝트 설계 및 구조 잡기",
          "filename": "address_book_design.txt",
          "lecture": {
            "character": "profKim",
            "title": "강의 노트: 소프트웨어 설계",
            "keyTakeaway": "코딩 전에 '무엇을, 어떻게 만들지'를 먼저 정리하는 설계 과정은 프로젝트의 성패를 좌우합니다.",
            "sandboxCode": null,
            "sections": [
              {
                "heading": "핵심 개념",
                "text": "소프트웨어 설계는 큰 문제를 해결 가능한 작은 문제들로 나누는 과정입니다. 먼저 데이터(Data)를 어떻게 표현하고 저장할지 결정하고(자료구조, 클래스), 필요한 기능(Functionality)들을 정의하며(함수, 메소드), 사용자와의 상호작용(User Interface) 및 데이터 영속성(Persistence), 예외 처리(Error Handling) 등을 고려해야 합니다 [cite: 2431-2433].",
                "code": null
              },
              {
                "heading": "설계 단계 예시",
                "text": "주소록 프로젝트를 다음 요소로 나누어 설계할 수 있습니다.",
                "code": "# 1. 데이터 모델: Person 클래스 (name, email, phone)\n# 2. 관리 구조: AddressBook 클래스 (내부에 연락처 dict 보유)\n# 3. 핵심 기능: 추가(add), 검색(search), 삭제(delete), 보기(view), 저장(save), 로드(load)\n# 4. UI: 메뉴 출력 -> 사용자 입력 -> 기능 호출 -> 결과 출력 반복\n# 5. 영속성: pickle 모듈 사용, 특정 파일에 저장/로드\n# 6. 예외 처리: 파일 없음(FileNotFoundError), 잘못된 입력 등"
              },
              {
                "heading": "활용 사례",
                "text": "지금 진행하는 최종 프로젝트 자체가 모든 지식을 활용하는 최고의 사례입니다.",
                "code": null
              },
              {
                "heading": "주의점 및 팁",
                "text": "처음부터 완벽한 설계를 하려고 하기보다, 가장 핵심적인 기능부터 단순하게 설계하고 점차 기능을 확장해나가는 것이 더 효과적입니다. 각 기능(메소드)이 어떤 입력(인자)을 받고 어떤 출력(반환값)을 내보낼지 미리 정의하면 구현이 쉬워집니다.",
                "code": null
              }
            ]
          },
          "syntax_key": {
            "syntax_title": "print()",
            "syntax_comment": "`print()`는 괄호 안의 값을 화면에 출력하는 내장 함수입니다.",
            "systax_code": "print(\"Hello World\")"
          },
          "task": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "최종 프로젝트: 명령줄 주소록 개발 (설계)",
            "content": "마지막 과제입니다! <span class='font-bold text-yellow-300'>연락처를 추가하고 볼 수 있는</span> 간단한 '명령줄 주소록 프로그램'을 만들려고 합니다. 이번 단계에서는 코딩 대신, 이 프로그램의 <span class='font-bold text-yellow-300'>기능 목록, 데이터 저장 방식(클래스/변수 구조), 데이터 영속성(파일 저장) 방안, 사용자 인터페이스 흐름</span> 등을 포함한 구체적인 '설계' 문서를 작성해주세요."
          },
          "briefing": {
            "character": "sena",
            "subtitle": "직속 선임의 조언",
            "title": "프로그램 만들기 전 생각 정리!",
            "content": "마지막 프로젝트네요! 코딩 전에 계획을 세우는 건 정말 중요해요. `starterCode`에 있는 질문들을 보면서 자유롭게 생각을 정리해보세요. 한 사람 정보는 8주차에 배운 <span class='font-bold text-teal-300'>클래스</span>로 묶으면 좋겠죠? 전체 목록은 6주차에 배운 <span class='font-bold text-teal-300'>딕셔너리</span>가 이름으로 찾기 편할 거고요. 데이터를 파일에 저장하는 건 10주차 <span class='font-bold text-teal-300'>pickle 모듈</span>이 딱이겠네요! 어떤 기능을 넣을지, 사용자는 어떻게 쓸지 등을 적어보세요."
          },
          "starterCode": "# 이 파일에 '명령줄 주소록' 프로그램의 설계도를 자유롭게 작성해주세요.\n# 아래 질문들에 답하면서 계획을 세워보는 것을 추천합니다.\n\n# 1. 어떤 데이터를 저장해야 할까요?\n#   - 한 사람의 정보: 이름? 이메일? 전화번호?\n#   - 이 정보 묶음을 어떻게 표현할까요? (힌트: 클래스?)\n#   - 전체 주소록 목록은 어떻게 관리할까요? (힌트: 리스트? 딕셔너리?)\n#\n\n# 2. 어떤 기능들이 필요할까요?\n#   - 새 연락처 추가하기\n#   - 등록된 모든 연락처 보기\n#   - (더 필요한 기능은 없을까요? 예: 검색? 삭제?)\n#\n\n# 3. 프로그램 종료 후에도 데이터가 유지되려면 어떻게 해야 할까요?\n#   - 데이터를 파일에 저장해야 할까요?\n#   - 어떤 형식으로 저장하면 좋을까요? (힌트: pickle?)\n#\n\n# 4. 사용자는 프로그램을 어떻게 사용하게 될까요?\n#    - 프로그램 시작 시 메뉴 보여주기\n#    - 사용자가 번호 등으로 메뉴 선택하기\n#    - 기능 실행 후 결과 보여주고 다시 메뉴로 돌아가기\n#    - 종료 메뉴 선택 시 프로그램 끝내기\n#\n",
          "testCode": "assert True, \"설계 단계는 개념적인 과제입니다.\"",
          "feedback": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "설계 승인",
              "content": "<span class='font-bold text-green-300'>매우 체계적인 설계입니다.</span> 필요한 기능과 데이터 구조, 처리 흐름을 명확하게 정의했군요. 이 설계안이라면 충분히 훌륭한 프로그램을 만들 수 있겠습니다. 설계가 승인되었으니, 다음 사이클부터 핵심 기능 구현을 시작해주세요."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "설계 검토",
              "title": "핵심 요소들을 더 구체화해볼까요?",
              "content": "설계 방향은 좋은데, 몇 가지 중요한 요소가 빠진 것 같아요. 예를 들어, 데이터 저장 방식은 정했는데 파일 저장/로드 기능에 대한 계획이 없네요. 사용자가 필요로 할 기능이나 발생할 수 있는 오류 상황을 다시 한번 생각해보는게 좋을 것 같아요."
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "설계 검토",
              "title": "코드는 다음 단계에!",
              "content": "이 단계는 코드를 작성하는 단계가 아니에요! 지금은 어떤 기능이 필요하고 어떤 데이터 구조를 쓸지 계획하는 '설계' 단계입니다. 작성해주신 계획안을 다시 한번 검토해주세요."
            }
          },
          "task_adv": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "최종 프로젝트: 주소록 클래스 설계",
            "content": "최종 프로젝트로 객체 지향적인 주소록 프로그램을 설계합니다. <span class='font-bold text-yellow-300'>`Person` 클래스</span>(연락처 정보)와 <span class='font-bold text-yellow-300'>`AddressBook` 클래스</span>(연락처 관리 및 파일 입출력 기능)를 중심으로 설계해주세요. 필요한 <span class='font-bold text-yellow-300'>속성(데이터)과 메소드(기능)</span>를 정의하고, <span class='font-bold text-yellow-300'>데이터 영속성 방안</span> 및 <span class='font-bold text-yellow-300'>오류 처리</span>까지 고려하여 상세한 설계 문서를 작성해야 합니다."
          },
          "briefing_adv": {
            "character": "sena",
            "subtitle": "직속 선임의 조언",
            "title": "객체 지향적으로 설계하기",
            "content": "객체 지향 설계에서는 역할 분담이 중요해요! <span class='font-bold text-teal-300'>`Person` 클래스</span>는 이름, 이메일 같은 '데이터'를 담는 역할에 집중하고, <span class='font-bold text-teal-300'>`AddressBook` 클래스</span>는 이 `Person` 객체들을 관리(추가, 삭제, 검색)하고 파일에 저장/로드하는 '기능'을 담당하게 하면 구조가 깔끔해져요 [cite: 2776-2778]. `AddressBook` 클래스에 `add_person`, `save_to_file` 같은 메소드를 미리 구상해보는 거죠. 오류 처리(예외 처리)도 잊지 마시고요!"
          },
          "starterCode_adv": "# 이 파일에 개선된 '명령줄 주소록' 프로그램의 설계도를 작성해주세요.\n\n# 1. 데이터 구조 (기존 + 개선):\n# - Person 클래스 (name, email, phone 속성 포함)\n# - AddressBook 클래스 (연락처 딕셔너리 관리, 파일 저장/로드 메소드 포함)\n\n# 2. 핵심 기능 목록 (CRUD + α):\n# - 연락처 추가 (Create)\n# - 연락처 검색/보기 (Read)\n# - 연락처 수정 (Update)\n# - 연락처 삭제 (Delete)\n# - 파일 저장 / 로드\n# - 종료\n\n# 3. 데이터 영속성 (어떤 모듈과 파일 형식을 사용할까요?):\n# - pickle 모듈 사용\n# - 파일 이름: address_book.data (바이너리 형식)\n\n# 4. 사용자 인터페이스 (메뉴 구조, 입력 방식 등 상세화):\n#    - 메인 루프 (while True:)\n#    - 메뉴 출력 (print)\n#    - 사용자 메뉴 선택 입력 받기 (input/raw_input)\n#    - 선택에 따른 기능 실행 (if/elif/else)\n#    - 각 기능 실행 시 필요한 정보 입력 받기 (예: 이름, 이메일 등)\n#    - 실행 결과 또는 오류 메시지 출력 (print)\n#    - 종료 선택 시 루프 탈출 (break)\n\n# 5. 오류 처리 (어떤 예외 상황을 고려해야 할까요?):\n#    - 잘못된 메뉴 번호 입력 (ValueError 처리 또는 조건문으로 확인)\n#    - 연락처 검색/수정/삭제 시 해당 이름이 없는 경우\n#    - 파일 로드 시 파일이 없는 경우 (FileNotFoundError)\n#    - 파일 로드/저장 시 데이터 손상 또는 기타 오류 (Exception)\n",
          "testCode_adv": "assert True, \"설계 단계는 개념적인 과제입니다.\"",
          "feedback_adv": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "설계 승인",
              "content": "<span class='font-bold text-green-300'>매우 체계적인 설계입니다.</span> 필요한 기능과 데이터 구조, 처리 흐름을 명확하게 정의했군요. 이 설계안이라면 충분히 훌륭한 프로그램을 만들 수 있겠습니다. 설계가 승인되었으니, 다음 사이클부터 핵심 기능 구현을 시작해주세요."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "설계 검토",
              "title": "핵심 요소들을 더 구체화해볼까요?",
              "content": "설계 방향은 좋은데, 몇 가지 중요한 요소가 빠진 것 같아요. 예를 들어, 데이터 저장 방식은 정했는데 파일 저장/로드 기능에 대한 계획이 없네요. 사용자가 필요로 할 기능이나 발생할 수 있는 오류 상황을 다시 한번 생각해보는게 좋을 것 같아요."
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "설계 검토",
              "title": "코드는 다음 단계에!",
              "content": "이 단계는 코드를 작성하는 단계가 아니에요! 지금은 어떤 기능이 필요하고 어떤 데이터 구조를 쓸지 계획하는 '설계' 단계입니다. 작성해주신 계획안을 다시 한번 검토해주세요."
            }
          }
        },
        {
          "title": "핵심 기능 구현",
          "filename": "address_book.py",
          "lecture": {
            "character": "profKim",
            "title": "교수님의 조언: 통합적 구현",
            "keyTakeaway": "클래스, 딕셔너리, 함수/메소드, 반복문 등 배운 개념들을 조합하여 실제 기능을 구현하는 연습이 중요합니다.",
            "sandboxCode": null,
            "sections": [
              {
                "heading": "핵심 조언",
                "text": "이번 단계는 설계한 내용을 코드로 옮기는 과정입니다. 클래스를 정의하고(`__init__`), 객체를 생성하며, 딕셔너리에 객체를 저장하고(`{key: object}`), 반복문을 통해 딕셔너리의 내용을 순회하는(`for key, value in dict.items()` 또는 `for value in dict.values()`) 등 이전에 배운 여러 개념을 종합적으로 활용해야 합니다. 각 기능별로 작은 함수나 메소드로 나누어 구현하면 코드를 관리하기 좋습니다.",
                "code": null
              }
            ]
          },
          "syntax_key": {
            "syntax_title": "print()",
            "syntax_comment": "`print()`는 괄호 안의 값을 화면에 출력하는 내장 함수입니다.",
            "systax_code": "print(\"Hello World\")"
          },
          "task": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "주소록 핵심 기능 구현",
            "content": "설계안을 바탕으로 실제 구현에 들어갑니다. 먼저 <span class='font-bold text-yellow-300'>`Person` 클래스를 정의</span>하고, 연락처를 추가하는 <span class='font-bold text-yellow-300'>`add_contact` 함수</span>와 전체 연락처를 보는 <span class='font-bold text-yellow-300'>`view_all_contacts` 함수</span>를 구현해주세요. 연락처 데이터는 `address_book` 딕셔너리에 저장합니다."
          },
          "briefing": {
            "character": "sena",
            "subtitle": "직속 선임의 팁",
            "title": "배운 것들로 조립하기!",
            "content": "이제 배운 것들을 합쳐볼 시간이에요! `Person` 클래스 `__init__` 빈칸은 8주차처럼 채우세요 (<span class='font-bold text-teal-300'>`__init__`, `name`, `email`, `name`, `name`, `email`, `email`</span>). `add_contact` 함수에서는 <span class='font-bold text-teal-300'>`person_obj = Person(name, email)`</span>로 객체를 만들고, <span class='font-bold text-teal-300'>`address_book[name] = person_obj`</span>로 딕셔너리에 추가해요. `view_all_contacts` 함수에서는 6주차처럼 <span class='font-bold text-teal-300'>`name`, `person_obj`, `address_book`, `f\"{name}: {person_obj.email}\"`</span>을 빈칸에 넣어 모든 연락처를 출력하면 됩니다!"
          },
          "starterCode": "class Person:\n    # TODO: 1. __init__ 메소드를 정의하여 이름(name)과 이메일(email)을 받아 속성에 저장하세요.\n    # (8주차 2번 사이클 참고)\n    def (self, , ):\n        self. = \n        self. = \n\naddress_book = {} # 연락처를 저장할 딕셔너리 (수정 불필요)\n\ndef add_contact(name, email):\n    # TODO: 2. Person 클래스로 객체를 생성(person_obj)하고,\n    #          address_book 딕셔너리에 name을 키로, person_obj를 값으로 추가하세요.\n    # (6주차 1번, 8주차 1번 사이클 참고)\n     = Person(, )\n    [] = \n\ndef view_all_contacts():\n    print(\"--- 전체 연락처 ---\")\n    # TODO: 3. for 문과 .items()를 사용하여 address_book의 모든 연락처를 출력하세요.\n    #          각 연락처는 \"이름: 이메일\" 형식으로 출력합니다.\n    # (6주차 2번 사이클 참고)\n    for ,  in .items():\n        print()\n    print(\"------------------\")\n\n# -- 아래는 프로그램을 실행하고 테스트하기 위한 부분입니다. (수정 불필요) --\nadd_contact(\"Alex\", \"alex@example.com\")\nadd_contact(\"Sena\", \"sena@example.com\")\nview_all_contacts()\n",
          "testCode": "student_globals = {'Person': None, 'address_book': {}, 'add_contact': None, 'view_all_contacts': None}; exec(student_code, student_globals); PersonClass = student_globals['Person']; add_contact_func = student_globals['add_contact']; view_all_contacts_func = student_globals['view_all_contacts']; address_book_dict = student_globals['address_book']; p = PersonClass('Test', 'test@test.com'); assert hasattr(p, 'name') and p.name == 'Test' and hasattr(p, 'email') and p.email == 'test@test.com', 'Person 클래스의 __init__이 올바르게 동작하지 않습니다.'; add_contact_func('Alex', 'alex@example.com'); assert 'Alex' in address_book_dict and isinstance(address_book_dict['Alex'], PersonClass), 'add_contact 함수가 딕셔너리에 Person 객체를 추가하지 못했습니다.'; assert address_book_dict['Alex'].email == 'alex@example.com', '추가된 Person 객체의 이메일 정보가 올바르지 않습니다.'; add_contact_func('Sena', 'sena@example.com'); import io; from contextlib import redirect_stdout; f = io.StringIO(); with redirect_stdout(f): view_all_contacts_func(); output = f.getvalue().strip().split('\\n'); expected_start = '--- 전체 연락처 ---'; expected_end = '------------------'; assert output[0] == expected_start, 'view_all_contacts 출력 시작 형식이 다릅니다.'; assert output[-1] == expected_end, 'view_all_contacts 출력 끝 형식이 다릅니다.'; expected_contacts = {'Alex: alex@example.com', 'Sena: sena@example.com'}; actual_contacts = set(output[1:-1]); assert actual_contacts == expected_contacts, f'view_all_contacts 출력 내용이 다릅니다.\\n기대값(순서 무관):{expected_contacts}\\n실제값:{actual_contacts}'",
          "feedback": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "핵심 기능 동작 확인",
              "content": "<span class='font-bold text-green-300'>주소록의 핵심 기능들이 설계대로 잘 동작</span>합니다. 프로그램의 뼈대가 튼튼하게 만들어졌군요. 이제 데이터 영속성 기능과 나머지 부가 기능을 추가하여 프로그램을 완성해봅시다."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "디버깅 지원",
              "title": "각 함수/클래스의 빈칸을 다시 확인해보세요",
              "content": "핵심 기능 중 일부가 의도대로 동작하지 않네요. `Person` 클래스 `__init__` 부분, `add_contact` 함수에서 객체 생성 및 딕셔너리 추가 부분, `view_all_contacts` 함수에서 `for` 루프와 `print` 부분을 다시 확인해주세요. 변수 이름이나 메소드 이름에 오타는 없는지도요!"
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "디버깅 지원",
              "title": "앗, 클래스 또는 함수/메소드 오류!",
              "content": "코드를 실행하다가 오류가 발생했어요. 클래스나 함수/메소드를 정의할 때 문법(`def`, `class`, `:`, 들여쓰기)을 올바르게 사용했는지, 객체의 속성이나 메소드를 호출할 때 이름에 오타는 없는지 다시 한번 꼼꼼하게 확인해볼까요?"
            }
          },
          "task_adv": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "AddressBook 클래스 메소드 구현",
            "content": "객체 지향 설계에 따라 `AddressBook` 클래스의 핵심 메소드들을 구현합니다. <span class='font-bold text-yellow-300'>`add_person` (추가)</span>, <span class='font-bold text-yellow-300'>`search_person` (검색)</span>, <span class='font-bold text-yellow-300'>`view_all` (전체 보기)</span> 세 가지 메소드의 내부 로직을 완성하여 주소록의 기본 기능을 동작하게 만들어주세요."
          },
          "briefing_adv": {
            "character": "sena",
            "subtitle": "직속 선임의 팁",
            "title": "클래스 안에서 데이터 관리하기",
            "content": "클래스 메소드 안에서는 `self`를 통해 객체의 속성에 접근할 수 있어요. `add_person`에서는 `Person` 객체를 만들어서 <span class='font-bold text-teal-300'>`self.contacts[이름] = Person객체`</span>로 딕셔너리에 저장하면 되죠. `search_person`에서는 <span class='font-bold text-teal-300'>`self.contacts.get(이름)`</span>을 사용하면 해당 이름의 연락처를 찾거나 `None`을 얻을 수 있어요. `view_all`에서는 <span class='font-bold text-teal-300'>`for person in self.contacts.values():`</span> 루프로 모든 `Person` 객체를 순회하며 정보를 출력하면 됩니다!"
          },
          "starterCode_adv": "class Person:\n    def __init__(self, name, email, phone):\n        self.name = name\n        self.email = email\n        self.phone = phone\n\nclass AddressBook:\n    def __init__(self):\n        self.contacts = {} # 연락처 저장용 딕셔너리\n\n    # TODO: 1. 연락처 추가 메소드 완성\n    #       Person 객체를 생성하여 self.contacts 딕셔너리에 name을 키로 추가\n    def add_person(self, name, email, phone):\n        person = Person(name, email, phone)\n        self.contacts[name] = person\n        print(f\"'{name}'님의 연락처가 추가되었습니다.\") # 추가 확인 메시지\n\n    # TODO: 2. 연락처 검색 메소드 완성\n    #       name을 키로 self.contacts 딕셔너리에서 Person 객체를 찾아 반환\n    #       (없으면 None 반환, .get() 메소드 사용)\n    def search_person(self, name):\n        return self.contacts.get(name)\n\n    # TODO: 3. 전체 연락처 보기 메소드 완성\n    #       self.contacts의 모든 Person 객체 정보를 출력 (for value in dict.values() 사용)\n    #       (예: \"이름: ..., 이메일: ..., 번호: ...\")\n    def view_all(self):\n        if not self.contacts:\n            print(\"주소록이 비어 있습니다.\")\n            return\n        print(\"--- 전체 연락처 ---\")\n        for person in self.contacts.values():\n            print(f\"이름: {person.name}, 이메일: {person.email}, 번호: {person.phone}\")\n        print(\"------------------\")\n\n# -- 테스트 코드 (수정 불필요) --\nbook = AddressBook()\nbook.add_person(\"Alex\", \"alex@example.com\", \"010-1111-1111\")\nbook.add_person(\"Sena\", \"sena@example.com\", \"010-2222-2222\")\nprint(\"--- 검색 결과 ---\")\nperson = book.search_person(\"Alex\")\nif person:\n    print(f\"{person.name}: {person.email}, {person.phone}\")\nelse:\n    print(\"검색 결과 없음\")\nprint(\"--- 전체 목록 ---\")\nbook.view_all()\n",
          "testCode_adv": "student_globals = {'Person': Person, 'AddressBook': None}; exec(student_code, student_globals); AddressBookClass = student_globals['AddressBook']; p = Person('T', 't@e.com', '1'); assert hasattr(p,'name') and p.name=='T' and hasattr(p,'email') and p.email=='t@e.com' and hasattr(p,'phone') and p.phone=='1', 'Person 클래스 초기화 오류'; book = AddressBookClass(); book.add_person('Alex', 'a@e.com', '1'); assert 'Alex' in book.contacts and book.contacts['Alex'].phone == '1', 'add_person 메소드 오류'; person = book.search_person('Alex'); assert person is not None and person.name == 'Alex', 'search_person 메소드 오류 (찾기)'; person_none = book.search_person('None'); assert person_none is None, 'search_person 메소드 오류 (못 찾기)'; import io; from contextlib import redirect_stdout; f = io.StringIO(); book.add_person('Sena', 's@e.com', '2'); with redirect_stdout(f): book.view_all(); output = f.getvalue().strip().split('\\n'); expected_lines = ['--- 전체 연락처 ---', '이름: Alex, 이메일: a@e.com, 번호: 1', '이름: Sena, 이메일: s@e.com, 번호: 2', '------------------']; # 순서는 보장되지 않을 수 있음\nassert output[0] == expected_lines[0], 'view_all 출력 시작 오류'; assert output[-1] == expected_lines[-1], 'view_all 출력 끝 오류'; actual_content = set(output[1:-1]); expected_content = set(expected_lines[1:-1]); assert actual_content == expected_content, f'view_all 출력 내용 오류.\\n기대값(순서무관): {expected_content}\\n실제값: {actual_content}'",
          "feedback_adv": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "핵심 기능 동작 확인",
              "content": "<span class='font-bold text-green-300'>주소록의 핵심 기능들이 설계대로 잘 동작</span>합니다. 프로그램의 뼈대가 튼튼하게 만들어졌군요. 이제 데이터 영속성 기능과 나머지 부가 기능을 추가하여 프로그램을 완성해봅시다."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "디버깅 지원",
              "title": "각 함수/클래스의 빈칸을 다시 확인해보세요",
              "content": "핵심 기능 중 일부가 의도대로 동작하지 않네요. `Person` 클래스 `__init__` 부분, `add_contact` 함수에서 객체 생성 및 딕셔너리 추가 부분, `view_all_contacts` 함수에서 `for` 루프와 `print` 부분을 다시 확인해주세요. 변수 이름이나 메소드 이름에 오타는 없는지도요!"
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "디버깅 지원",
              "title": "앗, 클래스 또는 함수/메소드 오류!",
              "content": "코드를 실행하다가 오류가 발생했어요. 클래스나 함수/메소드를 정의할 때 문법(`def`, `class`, `:`, 들여쓰기)을 올바르게 사용했는지, 객체의 속성이나 메소드를 호출할 때 이름에 오타는 없는지 다시 한번 꼼꼼하게 확인해볼까요?"
            }
          }
        },
        {
          "title": "기능 완성 및 회고",
          "filename": "address_book_final.py",
          "lecture": {
            "character": "profKim",
            "title": "강의 노트: Pickle과 예외 처리 복습",
            "keyTakeaway": "pickle 모듈로 파이썬 객체를 파일에 저장/로드할 수 있으며, 파일 작업 시 예외 처리는 필수입니다.",
            "sandboxCode": "import pickle\n\ndata_to_save = {'a': 1, 'b': 2}\nfilename = 'mydata.pkl'\n\n# 데이터 저장 (피클링)\ntry:\n    with open(filename, 'wb') as f:\n        pickle.dump(data_to_save, f)\n    print(\"데이터 저장 성공\")\nexcept Exception as e:\n    print(f\"저장 실패: {e}\")\n\n# 데이터 로드 (언피클링)\ntry:\n    with open(filename, 'rb') as f:\n        loaded_data = pickle.load(f)\n    print(\"데이터 로드 성공:\", loaded_data)\nexcept FileNotFoundError:\n    print(\"로드 실패: 파일 없음\")\nexcept Exception as e:\n    print(f\"로드 실패: {e}\")",
            "sections": [
              {
                "heading": "Pickle 모듈",
                "text": "파이썬 `pickle` 모듈은 파이썬 객체 구조를 직렬화(serialization)하고 역직렬화(deserialization)하는 데 사용됩니다. 즉, 객체를 파일에 저장 가능한 바이트 스트림으로 변환(`pickle.dump`)하거나, 파일에서 바이트 스트림을 읽어 다시 원래 객체로 복원(`pickle.load`)할 수 있습니다 [cite: 2605-2609].",
                "code": null
              },
              {
                "heading": "파일 모드 (바이너리)",
                "text": "pickle로 데이터를 저장하거나 로드할 때는 파일을 반드시 바이너리 모드로 열어야 합니다. 쓰기 모드는 `'wb'`, 읽기 모드는 `'rb'`를 사용합니다.",
                "code": null
              },
              {
                "heading": "예외 처리 복습",
                "text": "파일 작업은 다양한 이유로 실패할 수 있습니다 (파일 없음, 권한 부족 등). `try...except` 구문을 사용하여 `FileNotFoundError`나 일반적인 `Exception` 등을 처리하여 프로그램이 예기치 않게 종료되는 것을 방지해야 합니다.",
                "code": null
              }
            ]
          },
          "syntax_key": {
            "syntax_title": "print()",
            "syntax_comment": "`print()`는 괄호 안의 값을 화면에 출력하는 내장 함수입니다.",
            "systax_code": "print(\"Hello World\")"
          },
          "task": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "주소록 프로그램 완성 (데이터 저장/로드)",
            "content": "마지막 단계입니다. 프로그램이 종료되어도 데이터가 사라지지 않도록 <span class='font-bold text-yellow-300'>`pickle` 모듈</span>을 사용하여 주소록 데이터를 파일(`FILENAME`)에 저장하고 불러오는 기능을 추가해야 합니다. <span class='font-bold text-yellow-300'>`save_data` 함수</span>와 <span class='font-bold text-yellow-300'>`load_data` 함수</span>의 내부 로직을 완성해주세요. 파일이 없을 때의 오류 처리(`FileNotFoundError`)도 필요합니다."
          },
          "briefing": {
            "character": "sena",
            "subtitle": "직속 선임의 팁",
            "title": "데이터 저장/불러오기: `pickle`",
            "content": "`pickle` 모듈을 쓰면 파이썬 데이터를 파일에 그대로 저장하고 불러올 수 있어요 [cite: 2605-2609]! `load_data` 함수 빈칸에는 <span class='font-bold text-teal-300'>`FILENAME`, `'rb'`, `f`, `loaded_data = pickle.load(f)`, `loaded_data`</span> 를 넣으세요 ('rb'는 읽기 바이너리 모드). 파일 없을 때 오류 처리 빈칸에는 <span class='font-bold text-teal-300'>`{}`</span> 를 넣어 빈 딕셔너리를 반환하고요. `save_data` 함수 빈칸에는 <span class='font-bold text-teal-300'>`FILENAME`, `'wb'`, `f`, `address_book`, `f`</span> 를 넣어 데이터를 저장하면 됩니다 ('wb'는 쓰기 바이너리 모드)!"
          },
          "starterCode": "import pickle\n\nFILENAME = \"address_book.data\"\n\nclass Person:\n    def __init__(self, name, email):\n        self.name = name\n        self.email = email\n\ndef load_data():\n    try:\n        # TODO: 1. 아래 빈칸들을 채워 파일을 '읽기 바이너리(rb)' 모드로 열고,\n        #          pickle.load()로 데이터를 불러와 반환하세요.\n        with open(, '') as :\n             = pickle.load()\n            return \n    except FileNotFoundError:\n        # TODO: 2. 아래 return 뒤 빈칸에 비어있는 딕셔너리 {} 를 넣으세요.\n        return \n\ndef save_data(address_book):\n    # TODO: 3. 아래 빈칸들을 채워 파일을 '쓰기 바이너리(wb)' 모드로 열고,\n    #          pickle.dump()로 address_book 데이터를 파일에 저장하세요.\n    with open(, '') as :\n        pickle.dump(, )\n\n# -- 아래는 테스트를 위한 부분입니다. (수정 불필요) --\naddress_book_to_save = {\"Alex\": Person(\"Alex\", \"alex@example.com\")}\nsave_data(address_book_to_save)\nloaded_book = load_data()\nprint(\"Loaded data:\", loaded_book)\nif \"Alex\" in loaded_book:\n    print(f\"Alex's email: {loaded_book['Alex'].email}\")\n\n# 테스트 후 파일 삭제 (실제 실행 시 필요)\n# import os\n# if os.path.exists(FILENAME): os.remove(FILENAME)\n",
          "testCode": "import os, pickle; student_globals = {'pickle': pickle, 'FILENAME': FILENAME, 'Person': Person, 'load_data': None, 'save_data': None}; exec(student_code, student_globals); load_data_func = student_globals['load_data']; save_data_func = student_globals['save_data']; if os.path.exists(FILENAME): os.remove(FILENAME); test_data_save = {'Alex': Person('Alex', 'a@e.com')}; save_data_func(test_data_save); assert os.path.exists(FILENAME), 'save_data 함수가 파일을 생성하지 못했습니다.'; loaded = load_data_func(); assert isinstance(loaded, dict) and 'Alex' in loaded and hasattr(loaded['Alex'], 'email') and loaded['Alex'].email == 'a@e.com', 'load_data 함수가 데이터를 올바르게 불러오지 못했습니다.'; if os.path.exists(FILENAME): os.remove(FILENAME); empty_loaded = load_data_func(); assert empty_loaded == {}, '파일이 없을 때 load_data 함수는 빈 딕셔너리를 반환해야 합니다.'",
          "feedback": {
            "success": {
              "character": "alex",
              "subtitle": "최종 평가",
              "title": "프로젝트 성공! 그리고 새로운 시작",
              "content": "<span class='font-bold text-green-300'>축하합니다, ${userName}님. 모든 요구사항을 만족하는 주소록 프로그램을 성공적으로 완성했습니다.</span> 데이터 저장/로드 기능까지 완벽하게 구현했네요! 지난 12주간의 노력이 담긴 훌륭한 결과물입니다. 이제 ${userName}님은 주어진 문제를 해결할 수 있는 역량을 갖춘 개발자로 성장했습니다. LogiCore Tech의 정식 개발자가 되신 것을 진심으로 환영합니다!"
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "디버깅 지원",
              "title": "pickle 사용법이나 파일 모드를 확인해보세요",
              "content": "데이터 저장 또는 로드가 제대로 안 됐어요. `load_data` 함수에서는 `with open(FILENAME, 'rb')`로 열고 `pickle.load(f)`로 불러왔는지, `FileNotFoundError` 처리 시 `{}`를 반환하는지 확인해주세요. `save_data` 함수에서는 `with open(FILENAME, 'wb')`로 열고 `pickle.dump(address_book, f)`로 저장했는지 확인해야 해요. 바이너리 모드('rb', 'wb')가 중요해요!"
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "디버깅 지원",
              "title": "앗, 파일 또는 Pickle 오류!",
              "content": "파일을 저장하거나 불러오다 오류가 발생했어요. `pickle` 모듈은 바이너리 모드('wb'나 'rb')로 파일을 열어야 해요. 이 부분을 빠뜨렸거나, `pickle.dump/load` 함수 사용법에 오타가 있을 수 있어요. `try...except` 구문도 올바르게 작성되었는지 확인해보세요!"
            }
          },
          "task_adv": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "AddressBook 클래스 완성",
            "content": "`AddressBook` 클래스의 나머지 기능을 완성합니다. <span class='font-bold text-yellow-300'>`delete_person` 메소드</span>를 구현하여 이름으로 연락처를 삭제하는 기능을 추가하고, <span class='font-bold text-yellow-300'>`save_data`와 `load_data` 메소드</span>를 완성하여 <span class='font-bold text-yellow-300'>`pickle` 모듈</span>로 `self.contacts` 데이터를 파일에 저장하고 불러오는 영속성 기능을 구현해주세요. 파일 입출력 시 발생할 수 있는 예외 처리도 포함해야 합니다."
          },
          "briefing_adv": {
            "character": "sena",
            "subtitle": "직속 선임의 팁",
            "title": "클래스 기능 완성하기",
            "content": "이제 클래스를 완성할 차례네요! `delete_person`에서는 `del self.contacts[이름]`으로 딕셔너리 항목을 삭제하면 돼요. 삭제하려는 이름이 없을 수도 있으니 `if 이름 in self.contacts:`로 확인하는 게 좋겠죠? `save_data`에서는 <span class='font-bold text-teal-300'>`pickle.dump(self.contacts, f)`</span>, `load_data`에서는 <span class='font-bold text-teal-300'>`return pickle.load(f)`</span>를 사용하면 됩니다 (생성자 `__init__`에서 `self.contacts`에 바로 할당). 파일 열 때 <span class='font-bold text-teal-300'>바이너리 모드('wb', 'rb')</span>와 `try-except` 예외 처리 잊지 마시고요!"
          },
          "starterCode_adv": "import pickle\nimport os\n\nFILENAME = \"address_book.data\"\n\nclass Person:\n    def __init__(self, name, email, phone):\n        self.name = name; self.email = email; self.phone = phone\n\nclass AddressBook:\n    def __init__(self):\n        self.contacts = self.load_data()\n\n    def add_person(self, name, email, phone):\n        if name in self.contacts:\n            print(f\"오류: '{name}'님은 이미 등록되어 있습니다.\") # 중복 체크 추가\n            return\n        self.contacts[name] = Person(name, email, phone)\n        print(f\"'{name}' 추가 완료\")\n\n    def search_person(self, name):\n        return self.contacts.get(name)\n\n    # TODO: 1. 연락처 삭제 메소드 완성\n    #       name을 키로 self.contacts 딕셔너리에서 항목을 삭제 (del 또는 pop 사용)\n    #       삭제 성공/실패 여부 메시지 출력 (try-except 또는 if-in 사용)\n    def delete_person(self, name):\n        if name in self.contacts:\n            del self.contacts[name]\n            print(f\"'{name}' 삭제 완료.\")\n        else:\n            print(f\"오류: '{name}'님을 찾을 수 없습니다.\")\n\n    # TODO: 2. 파일 저장 메소드 완성\n    #       pickle.dump를 사용하여 self.contacts 데이터를 FILENAME에 저장 ('wb' 모드)\n    def save_data(self):\n        try:\n            # 여기에 저장 로직 구현\n            with open(FILENAME, 'wb') as f:\n                pickle.dump(self.contacts, f)\n            print(\"데이터 저장 완료.\")\n        except Exception as e:\n            print(f\"데이터 저장 실패: {e}\")\n\n    # TODO: 3. 파일 로드 메소드 완성\n    #       pickle.load를 사용하여 FILENAME에서 데이터를 로드 ('rb' 모드)\n    #       FileNotFoundError 발생 시 빈 딕셔너리 반환\n    #       다른 Exception 발생 시에도 빈 딕셔너리 반환 및 오류 메시지 출력\n    def load_data(self):\n        try:\n            # 여기에 로드 로직 구현\n            with open(FILENAME, 'rb') as f:\n                return pickle.load(f)\n        except FileNotFoundError:\n            print(\"데이터 파일 없음. 새로 시작합니다.\")\n            return {}\n        except Exception as e:\n            print(f\"데이터 로드 실패: {e}\")\n            return {}\n\n    def view_all(self):\n        if not self.contacts:\n            print(\"주소록이 비어 있습니다.\")\n            return\n        print(\"--- 전체 연락처 ---\")\n        # 이름 순으로 정렬하여 출력 (개선)\n        for name in sorted(self.contacts.keys()):\n            person = self.contacts[name]\n            print(f\"이름: {person.name}, 이메일: {person.email}, 번호: {person.phone}\")\n        print(\"------------------\")\n\n# -- 테스트 코드 (수정 불필요) --\n# 이전 테스트 실행 시 파일이 남아있을 수 있으므로 시작 전 삭제\nif os.path.exists(FILENAME): os.remove(FILENAME)\n\nbook = AddressBook()\nbook.delete_person(\"Sena\") # 없는 이름 삭제 시도\nbook.add_person(\"Sena\", \"sena@example.com\", \"010-2222-2222\")\nbook.delete_person(\"Sena\") # 있는 이름 삭제 시도\nbook.add_person(\"Alex\", \"alex@example.com\", \"010-1111-1111\") # 저장할 데이터 추가\nbook.save_data()\n\n# 저장된 데이터 로드 테스트\nprint(\"\\n--- 데이터 로드 테스트 ---\")\nbook2 = AddressBook()\nfound = book2.search_person(\"Alex\")\nif found:\n    print(f\"로드된 Alex 정보: {found.email}\")\nelse:\n    print(\"Alex 정보를 로드하지 못했습니다.\")\n\n# 테스트 후 파일 삭제 (정리)\nif os.path.exists(FILENAME): os.remove(FILENAME)\n",
          "testCode_adv": "import os, pickle; student_globals = {'pickle': pickle, 'os': os, 'FILENAME': FILENAME, 'Person': Person, 'AddressBook': None}; if os.path.exists(FILENAME): os.remove(FILENAME); exec(student_code, student_globals); AddressBookClass = student_globals['AddressBook']; book_test = AddressBookClass(); book_test.add_person('TestDelete', 'd@e.com', '3'); book_test.delete_person('TestDelete'); assert 'TestDelete' not in book_test.contacts, 'delete_person 메소드가 연락처를 삭제하지 못했습니다.'; book_test.add_person('TestSave', 's@e.com', '4'); book_test.save_data(); assert os.path.exists(FILENAME), 'save_data 메소드가 파일을 생성하지 못했습니다.'; book_test_load = AddressBookClass(); assert 'TestSave' in book_test_load.contacts and book_test_load.contacts['TestSave'].phone == '4', 'load_data 메소드가 저장된 데이터를 올바르게 불러오지 못했습니다.'; book_test_load.delete_person('TestSave'); assert 'TestSave' not in book_test_load.contacts, '로드 후 delete_person 이 동작하지 않습니다.'; if os.path.exists(FILENAME): os.remove(FILENAME)",
          "feedback_adv": {
            "success": {
              "character": "alex",
              "subtitle": "최종 평가",
              "title": "프로젝트 성공! 그리고 새로운 시작",
              "content": "<span class='font-bold text-green-300'>축하합니다, ${userName}님. 모든 요구사항을 만족하는 주소록 프로그램을 성공적으로 완성했습니다.</span> 데이터 저장/로드 기능까지 완벽하게 구현했네요! 지난 12주간의 노력이 담긴 훌륭한 결과물입니다. 이제 ${userName}님은 주어진 문제를 해결할 수 있는 역량을 갖춘 개발자로 성장했습니다. LogiCore Tech의 정식 개발자가 되신 것을 진심으로 환영합니다!"
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "디버깅 지원",
              "title": "pickle 사용법이나 파일 모드를 확인해보세요",
              "content": "데이터 저장 또는 로드가 제대로 안 됐어요. `load_data` 함수에서는 `with open(FILENAME, 'rb')`로 열고 `pickle.load(f)`로 불러왔는지, `FileNotFoundError` 처리 시 `{}`를 반환하는지 확인해주세요. `save_data` 함수에서는 `with open(FILENAME, 'wb')`로 열고 `pickle.dump(address_book, f)`로 저장했는지 확인해야 해요. 바이너리 모드('rb', 'wb')가 중요해요!"
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "디버깅 지원",
              "title": "앗, 파일 또는 Pickle 오류!",
              "content": "파일을 저장하거나 불러오다 오류가 발생했어요. `pickle` 모듈은 바이너리 모드('wb'나 'rb')로 파일을 열어야 해요. 이 부분을 빠뜨렸거나, `pickle.dump/load` 함수 사용법에 오타가 있을 수 있어요. `try...except` 구문도 올바르게 작성되었는지 확인해보세요!"
            }
          }
        }
      ]
    }
  ]
}