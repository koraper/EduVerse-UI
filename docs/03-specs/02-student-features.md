# EduVerse 기능 명세서 - Part 2: 학생 기능

## 📋 문서 정보

| 항목 | 내용 |
|------|------|
| 문서명 | 기능 명세서 Part 2: 학생 기능 |
| 버전 | 1.2 |
| 최종 수정일 | 2025-10-19 |
| 상태 | 개발 중 |
| 관련 문서 | PRD v2.8, 역할별 기능 리스트 v3.7, 시스템 아키텍처 v1.4 |

## 📝 변경 이력

| 버전 | 일자 | 변경 내용 | 작성자 |
|------|------|----------|--------|
| 1.2 | 2025-10-19 | 정합성 개선: PRD v2.8, 역할별 기능 리스트 v3.7, 시스템 아키텍처 v1.4 반영 | Claude AI |
| 1.1 | 2025-10-17 | 문서 정보 한글화 | Claude AI |
| 1.0 | 2025-01-14 | 초기 버전 작성 | Claude AI |

---

## 📖 전체 문서 목차

**Part 1: 개요 및 인증** → [01-overview-and-auth.md](./01-overview-and-auth.md)
- 1. 개요
- 2. 명세서 작성 가이드
- 3. 랜딩페이지 기능
- 4. 인증 및 인가

**Part 2: 학생 기능** (현재 문서)
- 5. [학생 기능](#5-학생-기능)

**Part 3: 교수자 기능** → [03-professor-features.md](./03-professor-features.md)
- 6. 교수자 기능

**Part 4: 관리자 기능** → [04-admin-features.md](./04-admin-features.md)
- 7. 관리자 기능

**Part 5: 공통 가이드** → [05-common-guidelines.md](./05-common-guidelines.md)
- 8. 공통 기능
- 9. UI/UX 공통 가이드
- 10. 기술 제약사항

---

## 관련 문서

- **[UI 와이어프레임](../04-design/wireframes/)** (상세 화면 설계)
  - [학생 화면](../04-design/wireframes/03-student-wireframes.md)
  - [공통화면 (인증)](../04-design/wireframes/02-common-wireframes.md)

> **💡 UI 요소 참고**: 이 문서의 UI 요소 섹션은 간단한 개요만 포함합니다. 상세한 와이어프레임과 컴포넌트 명세는 위의 와이어프레임 문서를 참조하세요.

---

## 5. 학생 기능

### ST-CLASS-01 초대 코드 입력

**우선순위**: P0
**담당 역할**: Student

#### 기능 개요
- 학생이 교수자가 발급한 6자리 초대 코드를 입력하여 수업에 참여합니다.

#### 사용자 스토리
```
AS A 학생
I WANT TO 선생님이 알려준 6자리 코드를 입력하여
SO THAT 수업에 참여하고 학습을 시작할 수 있다
```

#### 전제조건
- 학생으로 로그인된 상태

#### 입력
| 필드명 | 타입 | 필수 | 설명 | 제약사항 |
|--------|------|------|------|----------|
| invite_code* | string | ✅ | 초대 코드 | 6자리, 영문 대문자+숫자 조합 (예: ABC123) |

#### 처리 로직
1. 학생 대시보드에서 "수업 참여하기" 버튼 클릭
2. 초대 코드 입력 모달/페이지 표시
3. 6자리 코드 입력 (자동 대문자 변환)
4. `POST /api/classes/join` 호출
5. 서버에서 코드 유효성 검증
   - 존재하는 코드인지 확인
   - 수업이 활성 상태인지 확인
   - 이미 참여한 수업인지 확인
6. 수업-학생 관계 테이블에 추가
   ```sql
   INSERT INTO class_students (class_id, student_id, joined_at)
   VALUES (?, ?, NOW())
   ```
7. 수업 정보 페이지로 리다이렉트
8. 환영 메시지 표시: "{{class_name}}에 참여하셨습니다!"

#### 출력
| 필드명 | 타입 | 설명 |
|--------|------|------|
| class_id | integer | 수업 ID |
| class_name | string | 수업명 |
| professor_name | string | 교수자 이름 |
| duration_weeks | integer | 수업 기간 (주) |
| student_count | integer | 현재 참여 학생 수 |

#### UI 요소

**초대 코드 입력 폼**:
```
┌────────────────────────────────────┐
│        수업에 참여하기              │
├────────────────────────────────────┤
│                                     │
│  선생님이 알려준 6자리 초대 코드를   │
│  입력해주세요                        │
│                                     │
│  초대 코드                          │
│  [A][B][C][1][2][3]                │
│  └─각 글자마다 개별 입력 칸           │
│                                     │
│  예시: ABC123                       │
│                                     │
│  [       참여하기       ]           │
│                                     │
│  [취소]                             │
└────────────────────────────────────┘
```

**입력 방식**:
- 6개 개별 입력 칸 (각 1자)
- 자동으로 다음 칸 이동
- 붙여넣기 지원
- 자동 대문자 변환

#### 예외 처리
| 에러 코드 | 상황 | 메시지 | 처리 방법 |
|-----------|------|--------|-----------|
| 400 | 코드 형식 오류 | "6자리 코드를 입력해주세요" | 입력 칸 강조 |
| 404 | 존재하지 않는 코드 | "유효하지 않은 초대 코드입니다" | 코드 재입력 유도 |
| 409 | 이미 참여한 수업 | "이미 참여 중인 수업입니다" | 수업 목록으로 이동 버튼 |
| 410 | 종료된 수업 | "이 수업은 종료되었습니다" | 확인 버튼 |

#### 제약사항

**기술적 제약**:
- 코드 검증 API 응답 시간: < 100ms
- 초대 코드는 대소문자 구분 없음 (대문자로 통일)

**비즈니스 제약**:
- 한 학생은 동일한 수업에 중복 참여 불가
- 종료된 수업은 참여 불가

#### 관련 기능/API
- `POST /api/classes/join`: 수업 참여 API
- ST-CLASS-02: 수업 목록 조회
- PR-CLASS-02: 초대 코드 생성

#### 테스트 시나리오

**정상 시나리오**:
1. 유효한 초대 코드 입력
   - "ABC123" 입력
   - 수업 참여 성공
   - 수업 상세 페이지로 이동
   - "{{수업명}}에 참여하셨습니다!" 토스트 메시지

**예외 시나리오**:
1. 잘못된 코드
   - "XYZ999" (존재하지 않는 코드) 입력
   - "유효하지 않은 초대 코드입니다" 오류
   - 입력 칸 초기화 및 재입력

2. 이미 참여한 수업
   - 이미 참여 중인 수업의 코드 입력
   - "이미 참여 중인 수업입니다" 오류
   - "수업 목록으로 가기" 버튼 제공

---

### ST-LEARN-01 시나리오 학습

**우선순위**: P0
**담당 역할**: Student

#### 기능 개요
- 학생이 "LogiCore Tech" 가상 회사의 인턴십 시나리오를 따라 단계별로 프로그래밍을 학습합니다.
- 각 시나리오는 실무 상황을 모사하며, NPC 캐릭터(Alex, Sena, 김교수)와 대화하며 진행됩니다.

#### 사용자 스토리
```
AS A 학생
I WANT TO 실제 회사 인턴처럼 시나리오 기반으로 학습하고
SO THAT 단순 문법 학습이 아닌 실무적인 프로그래밍 경험을 쌓을 수 있다
```

#### 전제조건
- 학생으로 로그인된 상태
- 수업에 참여한 상태 (ST-CLASS-01 완료)

#### 입력
| 필드명 | 타입 | 필수 | 설명 | 제약사항 |
|--------|------|------|------|----------|
| class_id | integer | ✅ | 수업 ID | 참여 중인 수업 |
| week | integer | ✅ | 주차 | 1-N (수업 기간에 따라) |
| task_id | integer | ✅ | 과제 ID | 해당 주차의 과제 |

#### 처리 로직
1. 학생이 대시보드에서 현재 주차 클릭
2. `GET /api/classes/{class_id}/weeks/{week}/tasks/{task_id}` 호출
3. 서버에서 시나리오 데이터 조회
   - 시나리오 제목, 설명
   - NPC 대화 스크립트
   - 과제 설명
   - 제공 코드 템플릿
   - 테스트 케이스
4. 학습 페이지 렌더링
   - 왼쪽: 시나리오 설명 + NPC 대화
   - 오른쪽: 코드 에디터 (ST-LEARN-02)
5. 학생이 시나리오를 읽으며 과제 이해
6. NPC 대화 클릭 시 순차적으로 대화 진행

#### 출력
| 필드명 | 타입 | 설명 |
|--------|------|------|
| scenario | object | 시나리오 전체 데이터 |
| scenario.title | string | 시나리오 제목 (예: "첫 출근: Python 개발 환경 익히기") |
| scenario.week | integer | 주차 |
| scenario.description | string | 시나리오 설명 (Markdown) |
| scenario.dialogues | array | NPC 대화 배열 |
| scenario.dialogues[].character | string | 캐릭터 이름 (Alex/Sena/김교수) |
| scenario.dialogues[].message | string | 대화 내용 |
| scenario.task | object | 과제 정보 |
| scenario.task.title | string | 과제 제목 |
| scenario.task.description | string | 과제 설명 |
| scenario.task.language | enum | 프로그래밍 언어 (python/javascript/c/java) |
| scenario.task.starter_code | string | 초기 코드 템플릿 |
| scenario.task.test_cases | array | 테스트 케이스 배열 |

#### UI 요소

**학습 페이지 레이아웃**:
```
┌─────────────────────────────────────────────────────────────────┐
│ [← 대시보드] EduVerse | Week 1: 첫 출근                         │
├──────────────────────┬──────────────────────────────────────────┤
│                      │                                          │
│  📖 시나리오          │  💻 코드 에디터                          │
│                      │                                          │
│  [NPC 아바타]        │  언어: [Python ▼]    [저장] [실행] [테스트]│
│                      │                                          │
│  🧑‍💼 Alex (팀 리더)   │  1  def greet(name):                   │
│  "안녕! 오늘부터     │  2      # TODO: 구현하세요              │
│   우리 팀에서        │  3      pass                             │
│   인턴으로 일하게    │  4                                       │
│   될 거야. 첫 과제는 │  5  # 테스트                             │
│   간단한 인사        │  6  print(greet("Alex"))                │
│   함수를 만드는      │                                          │
│   거야."             │  ───────────────────────────────────────│
│                      │  🖥️ 실행 결과:                          │
│  [다음 대화 →]       │                                          │
│                      │  Hello, Alex!                            │
│  📝 과제 설명        │                                          │
│  greet() 함수를      │  ✅ 테스트 1/3 통과                      │
│  작성하세요.         │                                          │
│  - 입력: 이름        │                                          │
│  - 출력: "Hello, 이름"│                                         │
│                      │                                          │
│  💡 힌트(강의보기)   │  [📊 진도: 20%]                          │
│  💭 질문하기         │                                          │
│                      │                                          │
└──────────────────────┴──────────────────────────────────────────┘
```

**시나리오 패널 (좌측)**:
- NPC 캐릭터 아바tar
- 대화 말풍선 (순차 진행)
- 과제 설명 (Markdown 렌더링)
- 힌트(강의보기) 버튼 (ST-LEARN-06)
- 질문하기 버튼 (ST-INTER-02)

**코드 에디터 패널 (우측)**:
- Monaco Editor (ST-LEARN-02)
- 언어 선택 드롭다운
- 저장/실행/테스트 버튼
- 실행 결과 콘솔
- 테스트 통과 현황
- 진도율 표시

#### 예외 처리
| 에러 코드 | 상황 | 메시지 | 처리 방법 |
|-----------|------|--------|-----------|
| 404 | 시나리오 없음 | "해당 주차의 학습 자료가 아직 준비되지 않았습니다" | 대시보드로 이동 |
| 403 | 접근 권한 없음 | "이전 주차를 먼저 완료해주세요" | 이전 주차로 이동 유도 |
| 500 | 데이터 로드 실패 | "시나리오를 불러오는 중 오류가 발생했습니다" | 재시도 버튼 |

#### 제약사항

**기술적 제약**:
- 시나리오 로드 시간: < 500ms
- Markdown 렌더링: 보안 sanitization 필수
- 대화 순서 보장 (순차적으로만 진행)

**비즈니스 제약**:
- **순차 진행 불필요**: 이전 주차 미완료 시에도 특정 주차 시작 가능 (예: 1주차 건너뛰고 2주차 시작)
- 시나리오는 관리자만 수정 가능
- MVP에서는 LogiCore Tech 1개 시나리오만 제공
- **커리큘럼**: 4개 사전 등록 (C, Java, JavaScript, C#), 각 12주차

#### 관련 기능/API
- `GET /api/classes/{class_id}/weeks/{week}/tasks/{task_id}`: 시나리오 조회
- ST-LEARN-02: 코드 작성
- ST-LEARN-03: 코드 실행
- ST-LEARN-05: 테스트 실행
- ST-INTER-01: 캐릭터 대화
- ST-INTER-02: 질문하기

#### 테스트 시나리오

**정상 시나리오**:
1. 첫 주차 시나리오 진입
   - Week 1 클릭
   - 시나리오 로드 성공
   - Alex의 환영 메시지 표시
   - 코드 템플릿 자동 로드

2. 대화 순차 진행
   - "다음 대화" 버튼 클릭
   - Sena의 대화 표시
   - 김교수의 조언 표시
   - 과제 설명 확인

**예외 시나리오**:
1. 미완료 주차 건너뛰기 시도
   - Week 1 미완료 상태에서 Week 2 클릭
   - "이전 주차를 먼저 완료해주세요" 경고
   - Week 1로 자동 이동

---

### ST-LEARN-02 코드 작성

**우선순위**: P0
**담당 역할**: Student

#### 기능 개요
- Monaco Editor를 사용하여 브라우저에서 코드를 작성합니다.
- 문법 하이라이팅, 자동 완성, 에러 감지 등 IDE 수준의 편집 기능을 제공합니다.

#### 사용자 스토리
```
AS A 학생
I WANT TO 브라우저에서 IDE처럼 편안하게 코드를 작성하고
SO THAT 별도 개발 환경 설치 없이 바로 프로그래밍을 시작할 수 있다
```

#### 전제조건
- ST-LEARN-01 시나리오 페이지 진입 완료

#### 입력
| 필드명 | 타입 | 필수 | 설명 | 제약사항 |
|--------|------|------|------|----------|
| code | string | ✅ | 사용자가 작성한 코드 | 최대 100KB |
| language | enum | ✅ | 프로그래밍 언어 | python/javascript/c/java |
| task_id | integer | ✅ | 현재 과제 ID | 진행 중인 과제 |

#### 처리 로직
1. Monaco Editor 초기화
   - 언어별 문법 하이라이팅 설정
   - 테마 적용 (VS Code Dark 스타일)
   - 자동 완성 활성화
2. 초기 코드 템플릿 로드 (scenario.task.starter_code)
3. 사용자가 코드 작성
   - 실시간 문법 검사
   - 자동 들여쓰기
   - 괄호 자동 닫기
4. 코드 변경 시 debounce(3초) 후 자동 저장 (ST-LEARN-04)
5. Ctrl+S / Cmd+S 단축키로 수동 저장

#### 출력
| 필드명 | 타입 | 설명 |
|--------|------|------|
| code | string | 사용자가 작성한 코드 |
| last_saved | timestamp | 마지막 저장 시각 |
| auto_save_enabled | boolean | 자동 저장 활성화 여부 |

#### UI 요소

**Monaco Editor 설정**:
```typescript
// 에디터 옵션
{
  theme: 'vs-dark',
  language: 'python', // 동적 변경
  fontSize: 14,
  lineNumbers: 'on',
  minimap: { enabled: true },
  scrollBeyondLastLine: false,
  automaticLayout: true,
  tabSize: 4,
  insertSpaces: true,
  wordWrap: 'on',
  quickSuggestions: true,
  suggestOnTriggerCharacters: true,
  folding: true,
  lineHeight: 20
}
```

**에디터 상단 툴바**:
```
┌────────────────────────────────────────────────────────┐
│ 언어: [Python ▼]  [💾 저장] [▶️ 실행] [✅ 테스트]       │
│                                      마지막 저장: 1분 전 │
└────────────────────────────────────────────────────────┘
```

**언어 선택 드롭다운**:
- Python
- JavaScript
- C
- Java

**키보드 단축키**:
- `Ctrl+S` / `Cmd+S`: 저장
- `Ctrl+Enter` / `Cmd+Enter`: 실행
- `Ctrl+/` / `Cmd+/`: 주석 토글
- `Ctrl+F` / `Cmd+F`: 찾기
- `Ctrl+H` / `Cmd+H`: 찾기 및 바꾸기

#### 예외 처리
| 에러 코드 | 상황 | 메시지 | 처리 방법 |
|-----------|------|--------|-----------|
| 400 | 코드 크기 초과 | "코드가 너무 큽니다 (최대 100KB)" | 코드 간소화 유도 |
| 500 | 에디터 로드 실패 | "에디터를 불러오지 못했습니다" | 페이지 새로고침 유도 |

#### 제약사항

**기술적 제약**:
- Monaco Editor CDN 로드
- 코드 최대 크기: 100KB
- 자동 저장 debounce: 3초
- 언어 변경 시 기존 코드 유지 (경고 메시지)

**비즈니스 제약**:
- 코드는 학생 본인과 교수자만 조회 가능
- 실시간 협업 기능은 MVP 제외 (P2)

#### 관련 기능/API
- ST-LEARN-01: 시나리오 학습 (초기 템플릿 제공)
- ST-LEARN-03: 코드 실행
- ST-LEARN-04: 코드 저장
- `POST /api/tasks/{task_id}/code/save`: 코드 저장 API

#### 테스트 시나리오

**정상 시나리오**:
1. 에디터 초기화
   - 시나리오 페이지 로드
   - Monaco Editor 렌더링
   - 초기 템플릿 코드 표시
   - 문법 하이라이팅 적용

2. 코드 작성
   - 함수 작성
   - 자동 완성 팝업 표시
   - 들여쓰기 자동 조정
   - 3초 후 자동 저장 메시지

3. 언어 변경
   - 드롭다운에서 JavaScript 선택
   - "언어를 변경하면 문법 하이라이팅이 변경됩니다. 계속하시겠습니까?" 확인
   - 확인 클릭 → 언어 변경

**예외 시나리오**:
1. 코드 크기 초과
   - 100KB 이상 코드 붙여넣기
   - "코드가 너무 큽니다" 경고
   - 붙여넣기 차단

---

### ST-LEARN-03 코드 실행

**우선순위**: P0
**담당 역할**: Student

#### 기능 개요
- 브라우저에서 작성한 코드를 실행하여 결과를 확인합니다.
- 다중 언어 지원: Python (Pyodide), JavaScript (브라우저 네이티브), C/Java (Piston API)

#### 사용자 스토리
```
AS A 학생
I WANT TO 작성한 코드를 즉시 실행하여 결과를 확인하고
SO THAT 내 코드가 올바르게 동작하는지 빠르게 검증할 수 있다
```

#### 전제조건
- ST-LEARN-02 코드 작성 완료

#### 입력
| 필드명 | 타입 | 필수 | 설명 | 제약사항 |
|--------|------|------|------|----------|
| code* | string | ✅ | 실행할 코드 | 최대 100KB |
| language* | enum | ✅ | 언어 | python/javascript/c/java |
| task_id* | integer | ✅ | 과제 ID | - |
| stdin | string | ❌ | 표준 입력 | 선택 사항 |

#### 처리 로직

**언어별 실행 방식**:

1. **Python**:
   - Pyodide (WebAssembly) 사용
   - 브라우저 내 실행 (서버 요청 불필요)
   - 처리 과정:
     1. Pyodide 로드 확인 (초기 로드 ~3초)
     2. `pyodide.runPython(code)` 실행
     3. stdout, stderr 캡처
     4. 결과 반환

2. **JavaScript**:
   - 브라우저 네이티브 실행
   - 처리 과정:
     1. 코드를 `new Function()` 또는 `eval()` (샌드박스)
     2. stdout 리디렉트 (console.log → 캡처)
     3. try-catch로 에러 처리
     4. 결과 반환

3. **C / Java**:
   - Piston API 호출 (외부 코드 실행 서비스)
   - 처리 과정:
     1. `POST /api/code/execute` → 서버
     2. 서버에서 Piston API 호출
     3. 결과 수신 및 반환

**공통 처리**:
1. "▶️ 실행" 버튼 클릭
2. 실행 전 자동 저장 (ST-LEARN-04)
3. 언어별 실행 엔진 선택
4. 실행 로딩 인디케이터 표시
5. 실행 결과 캡처
   - stdout (표준 출력)
   - stderr (오류 출력)
   - execution_time (실행 시간)
   - memory_used (메모리 사용량 - Piston만)
6. 결과 콘솔에 출력
7. 실행 이력 저장 (교수자 모니터링용)

#### 출력
| 필드명 | 타입 | 설명 |
|--------|------|------|
| success | boolean | 실행 성공 여부 |
| stdout | string | 표준 출력 |
| stderr | string | 오류 출력 |
| execution_time | float | 실행 시간 (초) |
| memory_used | integer | 메모리 사용량 (KB) - Piston만 |
| exit_code | integer | 종료 코드 (0: 성공, 그 외: 실패) |

#### UI 요소

**실행 콘솔**:
```
┌──────────────────────────────────────────────────────┐
│ 🖥️ 실행 결과                      [지우기] [복사]     │
├──────────────────────────────────────────────────────┤
│ $ python script.py                                   │
│ Hello, Alex!                                         │
│ Hello, Sena!                                         │
│                                                      │
│ ✅ 실행 성공 (0.12초)                                │
└──────────────────────────────────────────────────────┘
```

**에러 표시**:
```
┌──────────────────────────────────────────────────────┐
│ 🖥️ 실행 결과                                         │
├──────────────────────────────────────────────────────┤
│ $ python script.py                                   │
│                                                      │
│ ❌ 오류 발생:                                        │
│ Traceback (most recent call last):                  │
│   File "script.py", line 3, in <module>             │
│     print(undefined_var)                             │
│ NameError: name 'undefined_var' is not defined      │
│                                                      │
│ ⏱️ 실행 시간: 0.05초                                 │
└──────────────────────────────────────────────────────┘
```

**로딩 상태**:
```
┌──────────────────────────────────────────────────────┐
│ 🖥️ 실행 결과                                         │
├──────────────────────────────────────────────────────┤
│                                                      │
│         ⏳ 코드 실행 중...                           │
│                                                      │
└──────────────────────────────────────────────────────┘
```

#### 예외 처리
| 에러 코드 | 상황 | 메시지 | 처리 방법 |
|-----------|------|--------|-----------|
| 400 | 코드 없음 | "실행할 코드가 없습니다" | 코드 작성 유도 |
| 408 | 실행 시간 초과 | "코드 실행이 10초를 초과했습니다" | 무한 루프 확인 유도 |
| 413 | 출력 크기 초과 | "출력 결과가 너무 큽니다 (최대 1MB)" | 출력 간소화 유도 |
| 500 | Pyodide 로드 실패 | "Python 실행 환경을 불러오지 못했습니다" | 페이지 새로고침 |
| 503 | Piston API 실패 | "외부 실행 서비스에 연결할 수 없습니다" | 잠시 후 재시도 |

#### 제약사항

**기술적 제약**:
- **실행 시간 제한**: 10초 (타임아웃)
- **메모리 제한**: 256MB
- **출력 크기 제한**: 1MB
- Pyodide 초기 로드: ~3초 (첫 실행 시만)
- Piston API 응답 시간: < 3초

**보안 제약**:
- 파일 시스템 접근 차단
- 네트워크 요청 차단
- 시스템 명령어 차단
- JavaScript: 샌드박스 환경에서 실행

**비즈니스 제약**:
- Rate Limiting: 1분에 10회 실행 제한
- 실행 이력은 교수자에게 실시간 전송 (PR-MON-01)

#### 관련 기능/API
- `POST /api/tasks/{task_id}/code/execute`: 코드 실행 API (C/Java)
- ST-LEARN-02: 코드 작성
- ST-LEARN-04: 코드 저장 (실행 전 자동 저장)
- PR-MON-01: 실시간 대시보드 (교수자가 실행 이력 확인)

#### 테스트 시나리오

**정상 시나리오**:
1. Python 코드 실행
   - `print("Hello, World!")` 작성
   - "실행" 버튼 클릭
   - 콘솔에 "Hello, World!" 출력
   - "✅ 실행 성공 (0.08초)" 표시

2. JavaScript 코드 실행
   - `console.log([1, 2, 3].map(x => x * 2))` 작성
   - 실행
   - "[2, 4, 6]" 출력

**예외 시나리오**:
1. 문법 오류
   - `print("Hello"` (닫는 괄호 누락) 작성
   - 실행
   - "❌ 오류 발생: SyntaxError..." 표시

2. 무한 루프
   - `while True: pass` 작성
   - 실행
   - 10초 후 "코드 실행이 10초를 초과했습니다" 경고
   - 실행 강제 종료

3. Rate Limit 초과
   - 1분에 11회 실행 시도
   - "잠시 후 다시 시도해주세요 (1분에 10회 제한)" 경고

---

### ST-LEARN-04 코드 저장

**우선순위**: P0
**담당 역할**: Student

#### 기능 개요
- 학생이 작성한 코드를 자동 또는 수동으로 저장합니다.
- 자동 저장은 코드 변경 후 3초 debounce, 수동 저장은 Ctrl+S 또는 버튼 클릭.

#### 사용자 스토리
```
AS A 학생
I WANT TO 작성 중인 코드가 자동으로 저장되고
SO THAT 브라우저를 닫아도 내 작업이 손실되지 않는다
```

#### 전제조건
- ST-LEARN-02 코드 작성 중

#### 입력
| 필드명 | 타입 | 필수 | 설명 | 제약사항 |
|--------|------|------|------|----------|
| task_id* | integer | ✅ | 과제 ID | 현재 과제 |
| code* | string | ✅ | 저장할 코드 | 최대 100KB |
| language* | enum | ✅ | 언어 | python/javascript/c/java |
| save_type | enum | ❌ | 저장 유형 | auto/manual (기본: auto) |

#### 처리 로직

**자동 저장**:
1. 사용자가 코드 입력
2. onChange 이벤트 발생
3. 3초 debounce 타이머 시작
4. 3초 내 추가 입력 없으면 저장 실행
5. `POST /api/tasks/{task_id}/code/save` 호출
6. 서버에서 DB 저장:
   ```sql
   INSERT INTO student_code (task_id, student_id, code, language, saved_at)
   VALUES (?, ?, ?, ?, NOW())
   ON DUPLICATE KEY UPDATE
     code = VALUES(code),
     language = VALUES(language),
     saved_at = NOW()
   ```
7. 성공 시 UI에 "저장됨" 표시 (토스트 없이 텍스트만)

**수동 저장**:
1. 학생이 Ctrl+S 누르거나 "💾 저장" 버튼 클릭
2. 즉시 저장 API 호출
3. 토스트 메시지: "코드가 저장되었습니다"

**저장 이력 관리**:
- 최근 10개 버전 유지 (P1 기능)
- MVP에서는 최신 버전만 저장 (덮어쓰기)

#### 출력
| 필드명 | 타입 | 설명 |
|--------|------|------|
| success | boolean | 저장 성공 여부 |
| saved_at | timestamp | 저장 시각 (ISO 8601) |
| version | integer | 버전 번호 (MVP에서는 항상 1) |

#### UI 요소

**저장 상태 표시**:
```
┌────────────────────────────────────────────────────────┐
│ 언어: [Python ▼]  [💾 저장] [▶️ 실행] [✅ 테스트]       │
│                                      마지막 저장: 방금 전│
└────────────────────────────────────────────────────────┘
```

**저장 상태 변화**:
- 저장 전: "마지막 저장: 1분 전" (회색)
- 저장 중: "저장 중..." (애니메이션)
- 저장 완료: "마지막 저장: 방금 전" (초록색 체크 아이콘 0.5초)

**수동 저장 토스트**:
```
┌────────────────────────────────┐
│ ✅ 코드가 저장되었습니다        │
└────────────────────────────────┘
```

#### 예외 처리
| 에러 코드 | 상황 | 메시지 | 처리 방법 |
|-----------|------|--------|-----------|
| 400 | 코드 크기 초과 | "코드가 너무 큽니다 (최대 100KB)" | 저장 차단, 간소화 유도 |
| 401 | 인증 만료 | "로그인이 만료되었습니다" | 로그인 페이지 리다이렉트 |
| 500 | 저장 실패 | "코드 저장에 실패했습니다" | 3회 재시도, 실패 시 로컬 스토리지에 임시 저장 |
| 503 | 서버 점검 | "서버 점검 중입니다" | 로컬 스토리지에 임시 저장 + 알림 |

#### 제약사항

**기술적 제약**:
- 자동 저장 debounce: 3초
- 코드 최대 크기: 100KB
- API 응답 시간: < 100ms
- 로컬 스토리지 백업 (서버 실패 시)

**비즈니스 제약**:
- 저장된 코드는 학생 본인과 교수자만 조회 가능
- 최신 버전만 유지 (MVP)
- 버전 이력은 P1 기능

#### 관련 기능/API
- `POST /api/tasks/{task_id}/code/save`: 코드 저장 API
- `GET /api/tasks/{task_id}/code/latest`: 최신 코드 조회
- ST-LEARN-02: 코드 작성
- ST-LEARN-03: 코드 실행 (실행 전 자동 저장)

#### 테스트 시나리오

**정상 시나리오**:
1. 자동 저장
   - 코드 입력
   - 3초 대기
   - "마지막 저장: 방금 전" 표시
   - DB 저장 확인

2. 수동 저장
   - Ctrl+S 입력
   - 즉시 저장
   - "✅ 코드가 저장되었습니다" 토스트
   - 0.5초 후 토스트 사라짐

3. 페이지 새로고침 후 복원
   - 코드 작성 및 저장
   - F5 새로고침
   - 저장된 코드 자동 로드

**예외 시나리오**:
1. 네트워크 끊김
   - 코드 작성
   - 저장 시도
   - "코드 저장에 실패했습니다" 경고
   - 로컬 스토리지에 임시 저장
   - 네트워크 복구 시 자동 재시도

2. 코드 크기 초과
   - 100KB 초과 코드 작성
   - 저장 시도
   - "코드가 너무 큽니다" 경고
   - 저장 차단

---

### ST-LEARN-05 테스트 실행

**우선순위**: P0
**담당 역할**: Student

#### 기능 개요
- 학생이 작성한 코드를 미리 정의된 테스트 케이스로 검증합니다.
- 각 테스트 케이스의 입력값으로 코드를 실행하고, 기대 출력값과 비교합니다.

#### 사용자 스토리
```
AS A 학생
I WANT TO 작성한 코드가 모든 테스트 케이스를 통과하는지 확인하고
SO THAT 정답 여부를 명확히 알고 다음 단계로 진행할 수 있다
```

#### 전제조건
- ST-LEARN-02 코드 작성 완료
- 테스트 케이스가 과제에 정의되어 있음

#### 입력
| 필드명 | 타입 | 필수 | 설명 | 제약사항 |
|--------|------|------|------|----------|
| task_id* | integer | ✅ | 과제 ID | - |
| code* | string | ✅ | 테스트할 코드 | 최대 100KB |
| language* | enum | ✅ | 언어 | python/javascript/c/java |

#### 처리 로직
1. "✅ 테스트" 버튼 클릭
2. 코드 자동 저장 (ST-LEARN-04)
3. `POST /api/tasks/{task_id}/code/test` 호출
4. 서버에서 테스트 케이스 조회
   ```sql
   SELECT * FROM test_cases WHERE task_id = ?
   ```
5. 각 테스트 케이스마다 코드 실행:
   ```
   for each test_case in test_cases:
     result = execute_code(code, language, test_case.input)
     if result.stdout == test_case.expected_output:
       test_case.passed = True
     else:
       test_case.passed = False
   ```
6. 모든 테스트 결과 수집
7. 전체 통과 여부 판정
   - 모두 통과: `task_progress.status = 'completed'`
   - 일부 실패: `task_progress.status = 'in_progress'`
8. 결과 UI에 표시

#### 출력
| 필드명 | 타입 | 설명 |
|--------|------|------|
| all_passed | boolean | 모든 테스트 통과 여부 |
| total_count | integer | 총 테스트 케이스 수 |
| passed_count | integer | 통과한 테스트 수 |
| test_results | array | 테스트 결과 배열 |
| test_results[].case_id | integer | 테스트 케이스 ID |
| test_results[].name | string | 테스트 케이스 이름 |
| test_results[].input | string | 입력값 |
| test_results[].expected_output | string | 기대 출력값 |
| test_results[].actual_output | string | 실제 출력값 |
| test_results[].passed | boolean | 통과 여부 |
| test_results[].error | string | 오류 메시지 (있을 경우) |

#### UI 요소

**테스트 결과 패널**:
```
┌──────────────────────────────────────────────────────┐
│ ✅ 테스트 결과: 3/3 통과                              │
├──────────────────────────────────────────────────────┤
│ ✅ 테스트 1: 기본 입력                                │
│    입력: "Alex"                                      │
│    기대: "Hello, Alex!"                              │
│    출력: "Hello, Alex!" ✅                           │
│                                                      │
│ ✅ 테스트 2: 빈 문자열                                │
│    입력: ""                                          │
│    기대: "Hello, !"                                  │
│    출력: "Hello, !" ✅                               │
│                                                      │
│ ✅ 테스트 3: 긴 이름                                  │
│    입력: "Alexander"                                 │
│    기대: "Hello, Alexander!"                         │
│    출력: "Hello, Alexander!" ✅                      │
│                                                      │
│ 🎉 축하합니다! 모든 테스트를 통과했습니다!            │
│ [다음 과제로 →]                                      │
└──────────────────────────────────────────────────────┘
```

**일부 실패 시**:
```
┌──────────────────────────────────────────────────────┐
│ ⚠️ 테스트 결과: 2/3 통과                              │
├──────────────────────────────────────────────────────┤
│ ✅ 테스트 1: 기본 입력                                │
│    입력: "Alex"                                      │
│    기대: "Hello, Alex!"                              │
│    출력: "Hello, Alex!" ✅                           │
│                                                      │
│ ❌ 테스트 2: 빈 문자열                                │
│    입력: ""                                          │
│    기대: "Hello, !"                                  │
│    출력: "Hello, None!" ❌                           │
│    💡 힌트(강의보기): 빈 문자열 처리를 확인해보세요   │
│                                                      │
│ ✅ 테스트 3: 긴 이름                                  │
│    ...                                               │
│                                                      │
│ 💡 [힌트(강의보기)] [질문하기]                        │
└──────────────────────────────────────────────────────┘
```

**테스트 로딩 상태**:
```
┌──────────────────────────────────────────────────────┐
│ ⏳ 테스트 실행 중... (2/3)                            │
└──────────────────────────────────────────────────────┘
```

#### 예외 처리
| 에러 코드 | 상황 | 메시지 | 처리 방법 |
|-----------|------|--------|-----------|
| 400 | 코드 없음 | "테스트할 코드가 없습니다" | 코드 작성 유도 |
| 404 | 테스트 케이스 없음 | "이 과제에는 테스트가 정의되지 않았습니다" | 교수자에게 문의 유도 |
| 408 | 테스트 시간 초과 | "테스트 실행이 30초를 초과했습니다" | 코드 최적화 유도 |
| 500 | 테스트 실행 실패 | "테스트 실행 중 오류가 발생했습니다" | 재시도 버튼 |

#### 제약사항

**기술적 제약**:
- 전체 테스트 시간 제한: 30초
- 개별 테스트 시간 제한: 10초
- 테스트 케이스 최대 개수: 20개

**비즈니스 제약**:
- 테스트 케이스는 학생에게 공개 (입력/출력 모두 표시)
- Hidden 테스트는 P1 기능 (MVP 제외)
- 모든 테스트 통과 시 자동으로 다음 과제 잠금 해제

#### 관련 기능/API
- `POST /api/tasks/{task_id}/code/test`: 테스트 실행 API
- ST-LEARN-03: 코드 실행 (테스트는 실행의 특수한 형태)
- ST-LEARN-04: 코드 저장 (테스트 전 자동 저장)
- ST-PROG-01: 진도 확인 (테스트 통과 시 진도 업데이트)
- PR-MON-01: 실시간 대시보드 (교수자가 테스트 결과 모니터링)

#### 테스트 시나리오

**정상 시나리오**:
1. 모든 테스트 통과
   - 올바른 코드 작성
   - "✅ 테스트" 버튼 클릭
   - 모든 테스트 실행
   - "🎉 축하합니다! 모든 테스트를 통과했습니다!" 메시지
   - "다음 과제로" 버튼 활성화
   - 진도 자동 업데이트

2. 일부 테스트 실패
   - 불완전한 코드 작성
   - 테스트 실행
   - 실패한 테스트 빨간색 표시
   - 기대값과 실제값 비교 표시
   - "힌트(강의보기)" 버튼 제공

**예외 시나리오**:
1. 무한 루프로 테스트 중단
   - 무한 루프 코드 작성
   - 테스트 실행
   - 10초 후 개별 테스트 타임아웃
   - "❌ 테스트 2: 시간 초과 (10초)" 표시
   - 나머지 테스트 계속 실행

2. 런타임 에러
   - 에러가 발생하는 코드 작성
   - 테스트 실행
   - "❌ 테스트 1: 런타임 에러" 표시
   - 에러 메시지 표시
   - 나머지 테스트 계속 실행

---

### ST-LEARN-08 제출 데이터 수정 불가

**우선순위**: P0
**담당 역할**: Student

#### 기능 개요
- 학생이 주차별 수업에서 한 번 제출한 데이터는 수정할 수 없습니다.
- 재도전은 가능하지만, 첫 번째 제출 결과가 최종 평가에 사용됩니다.
- 이 정책은 학습 데이터의 무결성과 평가의 공정성을 보장합니다.

#### 사용자 스토리
```
AS A 학생
I WANT TO 첫 번째 제출 후에도 재도전할 수 있지만
SO THAT 첫 번째 제출 결과가 최종 평가에 사용되어 공정한 평가가 이루어진다
```

#### 전제조건
- 학생으로 로그인된 상태
- 과제 또는 퀴즈를 한 번 이상 제출한 상태

#### 입력
| 필드명 | 타입 | 필수 | 설명 | 제약사항 |
|--------|------|------|------|----------|
| task_id* | integer | ✅ | 과제 ID | 현재 과제 |
| submission_data | object | ✅ | 제출 데이터 (코드, 퀴즈 답변, 설문 응답 등) | - |
| submission_type | enum | ✅ | 제출 유형 | quiz/survey/code/work_log |

#### 처리 로직

**첫 번째 제출**:
1. 학생이 과제/퀴즈/설문 제출 버튼 클릭
2. 서버에서 첫 번째 제출 여부 확인:
   ```sql
   SELECT COUNT(*) FROM submissions
   WHERE student_id = ? AND task_id = ? AND is_first_submission = TRUE
   ```
3. 첫 번째 제출인 경우:
   ```sql
   INSERT INTO submissions (
     student_id, task_id, week_number,
     submission_number, is_first_submission,
     data, score, submitted_at
   ) VALUES (?, ?, ?, 1, TRUE, ?, ?, NOW())
   ```
4. 제출 성공 메시지 표시: "제출이 완료되었습니다!"
5. 최종 제출 결과 표시: "✅ 최종 제출: 80점 (2025-10-17 14:30)"

**재도전 (두 번째 이후 제출)**:
1. 학생이 재도전 시도
2. 서버에서 첫 번째 제출 확인
3. 재도전 안내 메시지 표시:
   ```
   "이미 제출되었습니다. 재도전은 가능하지만 평가에는 첫 번째 결과가 사용됩니다."
   ```
4. 재도전 확인 모달:
   - 제목: "재도전하시겠습니까?"
   - 내용: "연습을 위해 다시 도전할 수 있습니다. 단, 성적에는 반영되지 않습니다."
   - 버튼: "다시 도전하기 (연습용)" / "취소"
5. 확인 시 재도전 제출:
   ```sql
   INSERT INTO submissions (
     student_id, task_id, week_number,
     submission_number, is_first_submission,
     data, score, submitted_at
   ) VALUES (?, ?, ?, ?, FALSE, ?, ?, NOW())
   -- submission_number는 자동 증가 (2, 3, 4...)
   ```
6. 재도전 결과 표시:
   - 현재 시도 점수: "이번 시도: 90점"
   - 최종 평가 점수: "✅ 최종 제출 (평가 반영): 80점 (2025-10-17 14:30)"

#### 출력
| 필드명 | 타입 | 설명 |
|--------|------|------|
| submission_id | integer | 제출 ID |
| is_first_submission | boolean | 첫 번째 제출 여부 |
| submission_number | integer | 제출 차수 (1, 2, 3...) |
| score | integer | 점수 |
| submitted_at | timestamp | 제출 시각 |
| first_submission_score | integer | 첫 번째 제출 점수 (재도전 시에만) |
| first_submission_date | timestamp | 첫 번째 제출 시각 (재도전 시에만) |

#### UI 요소

**첫 번째 제출 후 화면**:
```
┌────────────────────────────────────────────────────┐
│ ✅ 제출 완료                                       │
├────────────────────────────────────────────────────┤
│                                                    │
│ 제출이 완료되었습니다!                              │
│                                                    │
│ ✅ 최종 제출 (평가 반영): 80점                     │
│ 📅 제출 시각: 2025-10-17 14:30                     │
│                                                    │
│ 재도전하여 연습할 수 있습니다.                      │
│ (단, 성적에는 첫 번째 제출 결과만 반영됩니다)       │
│                                                    │
│ [다시 도전하기 (연습용)] [다음 과제로 →]           │
│                                                    │
└────────────────────────────────────────────────────┘
```

**재도전 확인 모달**:
```
┌────────────────────────────────────────────────────┐
│ 재도전하시겠습니까?                                 │
├────────────────────────────────────────────────────┤
│                                                    │
│ 연습을 위해 다시 도전할 수 있습니다.                │
│ 단, 성적에는 첫 번째 제출 결과만 반영됩니다.        │
│                                                    │
│ ✅ 최종 제출 (평가 반영): 80점                     │
│ 📅 제출 시각: 2025-10-17 14:30                     │
│                                                    │
│ [다시 도전하기 (연습용)] [취소]                     │
│                                                    │
└────────────────────────────────────────────────────┘
```

**재도전 결과 표시**:
```
┌────────────────────────────────────────────────────┐
│ 📊 재도전 결과                                     │
├────────────────────────────────────────────────────┤
│                                                    │
│ 🎯 이번 시도: 90점 (향상!)                         │
│                                                    │
│ ✅ 최종 제출 (평가 반영): 80점                     │
│ 📅 제출 시각: 2025-10-17 14:30                     │
│                                                    │
│ [다시 도전하기 (연습용)] [다음 과제로 →]           │
│                                                    │
└────────────────────────────────────────────────────┘
```

#### 예외 처리
| 에러 코드 | 상황 | 메시지 | 처리 방법 |
|-----------|------|--------|-----------|
| 400 | 제출 데이터 누락 | "제출할 데이터가 없습니다" | 데이터 입력 유도 |
| 403 | 주차별 수업 종료 | "이 주차 수업이 종료되어 제출할 수 없습니다" | 읽기 전용 모드로 전환 |
| 409 | 동시 제출 충돌 | "제출 처리 중입니다. 잠시만 기다려주세요" | 자동 재시도 |
| 500 | 제출 실패 | "제출 중 오류가 발생했습니다" | 재시도 버튼 제공 |

#### 제약사항

**기술적 제약**:
- 제출 API 응답 시간: < 500ms
- 첫 번째 제출 플래그는 DB 유니크 제약으로 보장
- 동시 제출 방지를 위한 트랜잭션 처리

**비즈니스 제약**:
- 적용 대상: 퀴즈/테스트, 설문, 코드 제출, 업무일지
- 재도전 횟수 제한 없음
- 교수자 대시보드는 첫 번째 제출 결과만 표시
- 재도전 이력은 학생 본인과 교수자만 조회 가능

**데이터 무결성**:
- 첫 번째 제출 데이터는 절대 삭제되지 않음 (Soft Delete도 불가)
- 재도전 데이터는 참고용으로 30일간 보관 후 정리 (향후 정책)

#### 관련 기능/API
- `POST /api/tasks/{task_id}/submit`: 제출 API
- `GET /api/tasks/{task_id}/submissions`: 제출 이력 조회
- `GET /api/tasks/{task_id}/first-submission`: 첫 번째 제출 조회
- ST-LEARN-05: 테스트 실행 (제출 전 단계)
- PR-MON-01: 실시간 대시보드 (교수자가 첫 번째 제출 결과만 확인)

#### 테스트 시나리오

**정상 시나리오**:
1. 첫 번째 제출
   - 과제 완료 후 제출 버튼 클릭
   - 제출 성공 메시지 표시
   - "✅ 최종 제출: 80점" 표시
   - DB에 is_first_submission=TRUE로 저장

2. 재도전 제출
   - "다시 도전하기 (연습용)" 버튼 클릭
   - 재도전 확인 모달 표시
   - "다시 도전하기 (연습용)" 확인
   - 재도전 완료
   - "이번 시도: 90점" 표시
   - "✅ 최종 제출 (평가 반영): 80점" 유지
   - DB에 is_first_submission=FALSE, submission_number=2로 저장

3. 여러 번 재도전
   - 3번째, 4번째 재도전
   - 매번 재도전 확인 모달 표시
   - 첫 번째 제출 점수는 변경되지 않음
   - 재도전 이력 누적

**예외 시나리오**:
1. 주차별 수업 종료 후 제출 시도
   - 제출 버튼 클릭
   - "이 주차 수업이 종료되어 제출할 수 없습니다" 오류
   - 읽기 전용 모드로 전환

2. 동시 제출 시도
   - 제출 버튼 연속 클릭
   - "제출 처리 중입니다. 잠시만 기다려주세요" 메시지
   - 첫 번째 요청만 처리, 나머지는 무시

---
