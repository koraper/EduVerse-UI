{
  "courseTitle": "LogiCore Tech 신입 개발자 과정",
  "weeks": [
    {
      "week": 1,
      "title": "신입사원 온보딩 및 개발 환경 구축",
      "cycles": [
        {
          "title": "오리엔테이션 및 파이썬 설치",
          "syntax_key": "installation",
          "filename": "check_python_version.py",
          "starterCode": "# 이 파일은 파이썬 설치를 확인하기 위한 스크립트입니다.\n# 코드를 수정할 필요 없이, 아래 터미널에서 'python check_python_version.py' 명령어를 실행하여 설치를 확인하세요.\n\nimport sys\n\nprint(\"파이썬 설치 확인 완료!\")\nprint(\"설치된 파이썬 버전:\", sys.version)\n",
          "testCode": "import sys\nassert sys.version_info.major >= 3, \"파이썬 3 이상 버전이 필요합니다.\"",
          "task": {
            "character": "alex",
            "subtitle": "팀장 환영사",
            "title": "LogiCore Tech에 오신 것을 환영합니다!",
            "content": "OOO님, 우리 LogiCore Tech의 일원이 되신 것을 진심으로 환영합니다. 우리 회사는 데이터를 통해 세상을 더 이롭게 만드는 것을 목표로 하고 있죠. 이를 위해 우리는 <span class='font-bold text-yellow-300'>간결하고 강력한 언어인 '파이썬'</span>을 주로 사용합니다. OOO님의 첫 번째 업무는 앞으로 함께할 가장 중요한 도구, <span class='font-bold text-yellow-300'>파이썬을 OOO님의 PC에 설치</span>하는 것입니다."
          },
          "briefing": {
            "character": "sena",
            "subtitle": "직속 선임의 OJT",
            "title": "첫 단추 채우기",
            "content": "세나 선임이에요. 반갑습니다! 개발자는 코드를 짜기 전에 <span class='font-bold text-teal-300'>자신의 개발 환경을 제대로 구축</span>하는 게 정말 중요해요. 마치 요리사가 자기 칼을 먼저 챙기는 것과 같죠. 파이썬 설치는 간단하지만, 나중에 터미널에서 명령어를 바로 쓰려면 <span class='font-bold text-teal-300'>'Add Python to PATH' 옵션</span>을 꼭 체크하는 게 좋아요. 막히는 부분 있으면 언제든 물어보세요!"
          },
          "lecture": {
            "character": "profKim",
            "title": "교수님의 쪽지: 언어와 인터프리터",
            "keyTakeaway": "파이썬 설치 = 컴퓨터에 파이썬 번역기 설치하기",
            "sandboxCode": null,
            "sections": [
              {
                "heading": "핵심 개념",
                "text": "파이썬은 '프로그래밍 언어'입니다. 우리가 파이썬 문법으로 작성한 코드를 컴퓨터가 이해할 수 있는 기계어로 번역해주는 '번역기'가 필요한데, 이것을 '파이썬 인터프리터'라고 부릅니다. 지금 우리는 바로 그 번역기를 설치하는 것입니다.",
                "code": null
              },
              {
                "heading": "기본 문법",
                "text": "설치가 완료되면 터미널(명령 프롬프트)에서 아래 명령어를 통해 설치된 버전을 확인할 수 있습니다.",
                "code": "python --version\n# 또는\npython -V"
              },
              {
                "heading": "활용 사례",
                "text": "모든 파이썬 프로그램은 이 인터프리터를 통해 실행됩니다. 웹 서버, 데이터 분석, 인공지능 등 모든 파이썬 기반 애플리케이션의 가장 기초적인 실행 환경입니다.",
                "code": null
              },
              {
                "heading": "주의점 및 팁",
                "text": "Windows 환경에서 설치할 경우, 'Add Python to PATH' 옵션을 체크하면 어떤 폴더에서든 `python` 명령어를 실행할 수 있어 매우 편리합니다. macOS나 Linux에는 기본적으로 파이썬이 설치되어 있는 경우가 많습니다.",
                "code": null
              }
            ]
          },
          "feedback": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "첫 번째 도구 획득!",
              "content": "<span class='font-bold text-green-300'>설치 완료된 것을 확인했습니다.</span> 훌륭합니다. 이제 OOO님은 파이썬이라는 강력한 언어를 사용할 준비를 마쳤습니다. 다음 단계를 진행하죠."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "음, 뭔가 이상한데요?",
              "content": "테스트 코드를 실행하는 데 실패했어요. {{ERROR_MESSAGE}} 라는 메시지가 보이네요. 혹시 설치 가이드에 따라 올바른 버전의 파이썬을 설치했는지 다시 한번 확인해 주시겠어요?"
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "명령어를 못 찾겠어요!",
              "content": "어라, 터미널에서 `python` 명령어를 찾을 수 없다고 나오네요. 혹시 설치할 때 'Add Python to PATH' 옵션을 놓치신 건 아닐까요? 환경 변수 설정을 다시 한번 확인해보시는 게 좋겠어요!"
            }
          }
        },
        {
          "title": "코드 에디터(VS Code) 설정",
          "syntax_key": "ide_setup",
          "filename": "welcome.py",
          "starterCode": "# VS Code 설치 및 폴더 열기 확인용 파일입니다.\n# 다음 사이클에서 이 파일을 수정하여 첫 코드를 작성하게 됩니다.\n\nprint(\"VS Code 준비 완료!\")\n",
          "testCode": "import os\nassert os.path.exists('welcome.py'), \"'welcome.py' 파일이 현재 폴더에 존재해야 합니다.\"",
          "task": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "우리의 작업 공간, 코드 에디터",
            "content": "두 번째 업무입니다. 전문 개발자는 메모장이 아닌 <span class='font-bold text-yellow-300'>'코드 에디터'</span>라는 전문 도구를 사용합니다. 우리는 'Visual Studio Code'를 표준으로 사용하고 있어요. <span class='font-bold text-yellow-300'>VS Code를 설치하고, 앞으로 작업할 이 프로젝트 폴더를 열어주세요.</span>"
          },
          "briefing": {
            "character": "sena",
            "subtitle": "직속 선임의 팁",
            "title": "VS Code, 친해져 보세요!",
            "content": "VS Code는 정말 좋은 에디터에요. 코드를 예쁘게 색칠해줘서(구문 강조) 오타도 잘 보이고, 터미널도 내장되어 있어서 편하죠. 나중에 'Python' 확장 프로그램을 설치하면 훨씬 더 강력해질 거예요. <span class='font-bold text-teal-300'>폴더를 열어서 작업하는 습관</span>을 들이면 파일 관리가 아주 편해진답니다."
          },
          "lecture": {
            "character": "profKim",
            "title": "교수님의 쪽지: IDE란?",
            "keyTakeaway": "IDE는 개발자의 생산성을 높여주는 만능 도구 상자입니다.",
            "sandboxCode": null,
            "sections": [
              {
                "heading": "핵심 개념",
                "text": "IDE(Integrated Development Environment, 통합 개발 환경)는 코드를 작성하는 에디터 기능뿐만 아니라, 코드를 실행하고 오류를 찾는 디버깅, 버전 관리 등 개발에 필요한 여러 기능을 하나로 합친 소프트웨어를 말합니다. PyCharm, VS Code 등이 좋은 예시입니다.",
                "code": null
              },
              {
                "heading": "기본 문법",
                "text": "IDE 자체의 문법은 없지만, 대부분의 IDE는 '폴더 열기(Open Folder)' 기능을 통해 프로젝트 단위로 파일을 관리하고, '새 파일(New File)' 기능을 통해 소스 코드 파일을 생성합니다.",
                "code": null
              },
              {
                "heading": "활용 사례",
                "text": "단순한 스크립트 작성부터 거대한 웹 서비스 개발까지, 거의 모든 소프트웨어 개발은 IDE 위에서 이루어집니다.",
                "code": null
              },
              {
                "heading": "주의점 및 팁",
                "text": "메모장 같은 일반 텍스트 편집기는 문법 강조나 자동 들여쓰기 기능이 없어 파이썬 개발에 적합하지 않습니다. 반드시 프로그래밍 전용 에디터나 IDE를 사용하는 습관을 들이는 것이 중요합니다.",
                "code": null
              }
            ]
          },
          "feedback": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "업무 환경 준비 완료",
              "content": "좋습니다. 프로젝트 폴더가 VS Code에 잘 열렸네요. 이제 OOO님의 <span class='font-bold text-green-300'>개인 작업 공간이 완벽하게 준비</span>되었습니다. 드디어 첫 코드를 작성할 시간이군요."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "파일을 못 찾겠어요",
              "content": "{{ERROR_MESSAGE}} 라는 메시지가 뜨네요. 혹시 현재 프로젝트 폴더가 아니라 다른 폴더를 여신 건 아닐까요? VS Code의 '파일' 메뉴에서 '폴더 열기'를 선택해서 올바른 작업 폴더를 열어주세요."
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "폴더가 열리지 않았어요",
              "content": "음, 아직 프로젝트 폴더가 열리지 않은 것 같아요. VS Code 화면 왼쪽의 탐색기 창에 'welcome.py' 파일이 보이는지 확인해주세요. 보이지 않는다면 폴더를 다시 열어주셔야 해요."
            }
          }
        },
        {
          "title": "첫 파이썬 프로그램 작성 및 실행",
          "syntax_key": "print_statement",
          "filename": "welcome.py",
          "starterCode": "# 이 파일에 'Hello, LogiCore Tech!'를 출력하는 코드를 작성하세요.\n",
          "expectedPrintOutput": "Hello, LogiCore Tech!",
          "testCode": null,
          "task": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "전통적인 첫걸음, Hello World!",
            "content": "모든 설정이 잘 되었는지 최종 확인할 시간입니다. 신입 개발자의 전통에 따라, 화면에 <span class='font-bold text-yellow-300'>'Hello, LogiCore Tech!'</span> 라는 문장을 출력하는 간단한 파이썬 스크립트를 작성하고 실행해주세요. OOO님의 첫 번째 공식적인 코드입니다."
          },
          "briefing": {
            "character": "sena",
            "subtitle": "직속 선임의 힌트",
            "title": "첫 코드, 긴장되시죠?",
            "content": "첫 스크립트네요! 간단해요. 지금 열려있는 `welcome.py` 파일에 작성하면 돼요. 화면에 글자를 출력할 때 어떤 함수를 썼는지 기억나시나요? <span class='font-bold text-teal-300'>`print()` 함수</span>를 사용했었죠. 괄호 안에 <span class='font-bold text-teal-300'>따옴표로 감싼 문자열</span>을 넣으면 된답니다. 한번 해보세요!"
          },
          "lecture": {
            "character": "profKim",
            "title": "강의 노트: print() 함수와 문자열",
            "keyTakeaway": "`print()` 함수는 괄호 안의 내용을 화면에 보여주는 가장 기본적인 명령입니다.",
            "sandboxCode": "print(\"파이썬, 반가워!\")",
            "sections": [
              {
                "heading": "핵심 개념",
                "text": "프로그램은 컴퓨터에 내리는 '명령문'들의 순차적인 나열입니다. `print()`는 파이썬이 기본으로 제공하는 '함수'이며, 괄호 안에 주어진 값을 화면(터미널)에 출력하라는 명령을 수행합니다.",
                "code": null
              },
              {
                "heading": "기본 문법",
                "text": "따옴표 안에 출력하고 싶은 문장을 넣어 함수를 호출합니다.",
                "code": "# 큰따옴표 사용\nprint(\"Hello, World!\")\n\n# 작은따옴표도 가능\nprint('Hello, Python!')"
              },
              {
                "heading": "활용 사례",
                "text": "프로그램의 실행 상태를 확인하거나, 사용자에게 메시지를 보여주거나, 계산 결과를 출력하는 등 가장 기본적이고 중요한 기능입니다.",
                "code": null
              },
              {
                "heading": "주의점 및 팁",
                "text": "문자열은 반드시 작은따옴표('')나 큰따옴표(\"\")로 감싸야 합니다. 또한, 파이썬은 대소문자를 구분하므로 `Print()`가 아닌 `print()`로 정확하게 입력해야 합니다.",
                "code": null
              }
            ]
          },
          "feedback": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "첫 커밋(Commit) 성공!",
              "content": "터미널에 메시지가 정확하게 출력되었군요. <span class='font-bold text-green-300'>모든 개발 환경이 완벽하게 동작한다는 의미</span>입니다. 축하합니다, OOO님의 첫 번째 코드가 성공적으로 실행되었습니다. LogiCore Tech에 오신 것을 다시 한번 환영합니다."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "메시지가 조금 다른데요?",
              "content": "앗, 출력된 메시지가 조금 다르네요. {{ERROR_MESSAGE}} 오탈자가 없는지, 대소문자는 정확한지, 쉼표나 마침표 같은 문장 부호까지 똑같은지 다시 한번 꼼꼼하게 확인해볼까요?"
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, 문법 오류!",
              "content": "어이쿠, 코드를 실행하다가 오류가 발생했어요. 혹시 `print`를 `Print`로 잘못 쓰시진 않았나요? 아니면 문자열 양쪽에 따옴표를 빠뜨렸을 수도 있고요. 파이썬은 이런 사소한 실수에 민감하거든요. 오류 메시지를 천천히 읽어보시면 어디가 틀렸는지 힌트를 얻을 수 있을 거예요."
            }
          }
        }
      ]
    },

    {
      "week": 2,
      "title": "데이터 기본기: 변수, 자료형, 연산자 다루기",
      "cycles": [
        {
          "title": "변수와 기본 자료형",
          "syntax_key": "variables_datatypes",
          "filename": "server_status.py",
          "starterCode": "# TODO: 아래 주석에 맞춰 서비스의 기본 정보를 변수에 저장해주세요.\n\n# 1. 서비스 이름(service_name)을 \"LogiCore\" 라는 문자열로 저장하세요.\n\n# 2. 현재 동시 접속자 수(concurrent_users)를 100 이라는 숫자로 저장하세요.\n\n# 3. 서비스 오픈 여부(is_active)를 True 라는 불리언 값으로 저장하세요.\n",
          "testCode": "assert 'service_name' in locals() and service_name == 'LogiCore', \"service_name 변수에 'LogiCore' 문자열을 할당해야 합니다.\"\nassert 'concurrent_users' in locals() and concurrent_users == 100, \"concurrent_users 변수에 숫자 100을 할당해야 합니다.\"\nassert 'is_active' in locals() and is_active is True, \"is_active 변수에 불리언 값 True를 할당해야 합니다.\"",
          "task": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "서비스 기본 정보 설정",
            "content": "좋은 아침입니다, OOO님. 간단한 업무부터 시작하죠. 우리 서비스의 <span class='font-bold text-yellow-300'>운영 상태를 관리할 변수</span>가 필요합니다. 서비스 이름(`service_name`)과 현재 동시 접속자 수(`concurrent_users`), 그리고 서비스 오픈 여부(`is_active`)를 각각 <span class='font-bold text-yellow-300'>문자열, 숫자, 불리언(True/False) 값</span>으로 변수에 저장해주세요."
          },
          "briefing": {
            "character": "sena",
            "subtitle": "직속 선임의 OJT",
            "title": "데이터를 담는 상자, 변수",
            "content": "세나 선임이에요. 변수는 일종의 <span class='font-bold text-teal-300'>'이름표가 붙은 상자'</span>라고 생각하면 편해요. 상자에 물건을 넣듯, 변수에 데이터를 저장하는 거죠. 파이썬은 똑똑해서 상자에 <span class='font-bold text-teal-300'>숫자를 넣으면 숫자 상자</span>로, <span class='font-bold text-teal-300'>글자를 넣으면 글자 상자</span>로 알아서 인식한답니다. 이걸 '동적 타이핑'이라고 불러요."
          },
          "lecture": {
            "character": "profKim",
            "title": "강의 노트: 변수와 자료형",
            "keyTakeaway": "변수는 값을 저장하는 공간이며, `=` 기호를 사용해 값을 할당(저장)합니다.",
            "sandboxCode": "# my_age 변수에 자신의 나이를 숫자로 저장하고 출력해보세요.\nmy_age = 25\nprint(my_age)",
            "sections": [
              {
                "heading": "핵심 개념",
                "text": "변수(Variable)는 데이터를 저장하기 위해 이름표를 붙인 메모리 공간입니다. 파이썬에서는 변수를 만들기 전에 미리 타입을 선언할 필요가 없습니다. 값을 할당하면 그 값의 종류에 따라 자동으로 자료형(Data Type)이 결정됩니다.",
                "code": null
              },
              {
                "heading": "기본 문법",
                "text": "변수이름 = 값 형태로 값을 할당합니다.",
                "code": "# 숫자형 (Integer)\nuser_count = 100\n\n# 문자열 (String)\nserver_status = \"running\"\n\n# 불리언 (Boolean)\nis_admin = True"
              },
              {
                "heading": "활용 사례",
                "text": "사용자 이름, 나이, 점수 등 프로그램이 동작하는 동안 계속해서 사용되거나 변경될 수 있는 모든 데이터를 저장하는 데 사용됩니다.",
                "code": null
              },
              {
                "heading": "주의점 및 팁",
                "text": "변수 이름은 숫자로 시작할 수 없으며, 공백을 포함할 수 없습니다. 또한, `my_name`과 `My_Name`은 서로 다른 변수로 인식될 만큼 대소문자를 엄격하게 구분합니다.",
                "code": null
              }
            ]
          },
          "feedback": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "기본 설정 완료",
              "content": "<span class='font-bold text-green-300'>변수들이 정확하게 선언되었군요.</span> 좋습니다. 이제 이 변수들을 이용해 우리 서비스가 다양한 상황에 맞게 동작하도록 만들 수 있습니다. 다음 업무로 넘어가죠."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "선언을 다시 확인해볼까요?",
              "content": "음, 테스트를 통과하지 못했어요. {{ERROR_MESSAGE}} 메시지를 보니 변수 이름에 오타가 있거나, 저장된 값의 종류(자료형)가 다른 것 같아요. 문자열은 따옴표로 감쌌는지, 숫자는 그냥 썼는지 한번 확인해볼까요?"
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, 문법 오류!",
              "content": "코드를 실행하다가 오류가 발생했어요. 변수 이름 규칙을 어긴 건 아닐까요? 변수 이름은 숫자로 시작할 수 없고, `my-name`처럼 특수문자를 쓸 수 없어요. 변수 이름을 다시 한번 확인해주세요!"
            }
          }
        },
        {
          "title": "연산자를 활용한 계산",
          "syntax_key": "operators",
          "filename": "analysis.py",
          "starterCode": "total_visits = 1250\npaid_users = 50\n\n# TODO: total_visits와 paid_users를 사용하여 conversion_rate를 계산하고, 그 결과를 출력하세요.\n# 전환율 공식: (유료 전환 사용자 / 총 방문자 수) * 100\n\nconversion_rate = 0 # 이 부분을 수정하여 계산식을 작성하세요.\nprint(conversion_rate)\n",
          "testCode": "assert 'conversion_rate' in locals(), \"conversion_rate 변수가 선언되지 않았습니다.\"\nassert abs(conversion_rate - 4.0) < 0.001, f\"계산된 전환율이 4.0이 아닙니다. 실제 계산값: {conversion_rate}\"",
          "task": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "사용자 데이터 분석",
            "content": "기획팀에서 간단한 데이터 분석을 요청했습니다. 어제 하루 동안의 <span class='font-bold text-yellow-300'>총 방문자 수(total_visits)가 1,250명</span>이고, <span class='font-bold text-yellow-300'>유료 전환 사용자(paid_users)가 50명</span>일 때, '유료 전환율(conversion_rate)'이 몇 퍼센트인지 계산해서 출력해주세요."
          },
          "briefing": {
            "character": "sena",
            "subtitle": "직속 선임의 팁",
            "title": "계산은 컴퓨터에게!",
            "content": "간단한 계산이네요. (유료 전환 사용자 / 총 방문자 수) * 100 으로 구하면 되겠죠? 파이썬에서는 사칙연산을 위한 <span class='font-bold text-teal-300'>산술 연산자(`+`, `-`, `*`, `/`)</span>를 바로 사용할 수 있어요. 코드로 계산식을 그대로 옮겨보면 금방 해결될 거예요."
          },
          "lecture": {
            "character": "profKim",
            "title": "강의 노트: 연산자와 수식",
            "keyTakeaway": "연산자는 값을 계산하고 비교하는 데 사용되며, 괄호로 계산 순서를 제어할 수 있습니다.",
            "sandboxCode": "my_score = 85\npass_score = 60\n\n# my_score가 pass_score보다 높은지 확인해보세요.\nprint(my_score > pass_score)",
            "sections": [
              {
                "heading": "핵심 개념",
                "text": "연산자(Operator)는 덧셈, 뺄셈, 비교 등 특정 연산을 수행하는 기호입니다. 연산자와 값이 결합하여 만들어지는 하나의 식을 수식(Expression)이라고 합니다. 수식은 계산되어 하나의 결과값을 만들어냅니다.",
                "code": null
              },
              {
                "heading": "기본 문법",
                "text": "다양한 연산자를 사용하여 수식을 만들 수 있습니다.",
                "code": "# 산술 연산자\nresult = 10 + 5   # 15\nresult = 10 / 2   # 5.0\n\n# 비교 연산자 (결과는 True 또는 False)\nis_equal = (10 == 5) # False\nis_greater = (10 > 5)  # True"
              },
              {
                "heading": "활용 사례",
                "text": "점수 합계 계산, 상품 가격 비교, 사용자 입력값 검증 등 데이터에 기반한 모든 판단과 계산에 사용됩니다.",
                "code": null
              },
              {
                "heading": "주의점 및 팁",
                "text": "곱셈/나눗셈(`*`, `/`)이 덧셈/뺄셈(`+`, `-`)보다 먼저 계산됩니다. 계산 순서가 헷갈릴 때는, 괄호 `()`를 사용하여 명확하게 순서를 지정해주는 것이 좋은 습관입니다. 예: `(a + b) / 2`",
                "code": null
              }
            ]
          },
          "feedback": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "분석 결과 확인",
              "content": "<span class='font-bold text-green-300'>전환율 계산이 정확하네요.</span> 좋습니다. 이런 간단한 계산 자동화가 개발의 시작입니다. 이제 이 결과를 보고서 형태로 보기 좋게 만드는 작업을 해보죠."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "계산 결과를 다시 확인해볼까요?",
              "content": "어라, 계산 결과가 약간 다른 것 같아요. {{ERROR_MESSAGE}} 혹시 수식에 오타가 있거나, 변수 이름을 잘못 쓴 건 아닐까요? 아니면 나눗셈 순서가 바뀌었을 수도 있고요. 수식을 다시 한번 천천히 살펴봐 주세요."
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, 계산 중 오류!",
              "content": "코드를 실행하다가 오류가 발생했어요. 혹시 숫자가 아닌 값으로 계산을 시도했거나, 존재하지 않는 변수를 사용한 건 아닐까요? 변수 이름에 오타는 없는지 꼼꼼히 확인해보세요."
            }
          }
        },
        {
          "title": "문자열 다루기",
          "syntax_key": "string_formatting",
          "filename": "report.py",
          "starterCode": "report_date = '2025-09-29'\nconversion_rate = 4.0\n\n# TODO: f-string을 사용하여 \"2025-09-29 기준, 유료 전환율은 4.0% 입니다.\" 형식의 문자열을 만들어 출력하세요.\n\nreport_message = \"\"\nprint(report_message)\n",
          "testCode": "expected_output = f\"{report_date} 기준, 유료 전환율은 {conversion_rate}% 입니다.\"\nassert 'report_message' in locals(), \"'report_message' 변수를 선언해야 합니다.\"\nassert report_message == expected_output, f\"report_message 변수의 값이 기대와 다릅니다. 기대값: '{expected_output}', 실제값: '{report_message}'\"",
          "task": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "동적 보고 메시지 생성",
            "content": "방금 계산한 <span class='font-bold text-yellow-300'>유료 전환율 결과를 보고 메시지로 만드는 업무</span>입니다. `report_date` 변수(예: '2025-09-29')와 `conversion_rate` 변수의 값을 조합해서, <span class='font-bold text-yellow-300'>\"2025-09-29 기준, 유료 전환율은 4.0% 입니다.\"</span> 와 같은 최종 문자열을 만들어 출력해주세요."
          },
          "briefing": {
            "character": "sena",
            "subtitle": "직속 선임의 팁",
            "title": "f-string을 써보세요!",
            "content": "여러 변수를 합쳐서 하나의 문장을 만들 때, `+` 기호로 계속 이어 붙이는 건 좀 옛날 방식이에요. <span class='font-bold text-teal-300'>f-string</span>을 써보세요. 문자열 앞에 `f`를 붙이고, 문자열 안에 `{변수이름}`을 넣으면 알아서 값이 쏙 들어가요. 코드가 훨씬 깔끔해져서 저도 애용하는 기능이랍니다!"
          },
          "lecture": {
            "character": "profKim",
            "title": "강의 노트: 문자열 포맷팅",
            "keyTakeaway": "f-string은 `f\"...{변수}...\"` 형태로, 변수 값을 문자열에 삽입하는 가장 현대적이고 편리한 방법입니다.",
            "sandboxCode": "item = \"커피\"\nprice = 5000\n\n# f-string을 이용해 \"상품: 커피, 가격: 5000원\"을 출력해보세요.\nprint(f\"상품: {item}, 가격: {price}원\")",
            "sections": [
              {
                "heading": "핵심 개념",
                "text": "문자열 포맷팅(String Formatting)은 문자열의 특정 위치에 변수의 값을 삽입하여, 동적인 문자열을 생성하는 기법입니다. 이를 통해 형식화된 보고서, 알림 메시지 등을 쉽게 만들 수 있습니다.",
                "code": null
              },
              {
                "heading": "기본 문법",
                "text": "문자열 시작 따옴표 앞에 `f`를 붙이고, 삽입할 변수나 값을 중괄호 `{}`로 감싸줍니다.",
                "code": "# f-string (가장 추천하는 방식)\nname = \"Sena\"\nage = 30\nmessage = f\"안녕하세요, 제 이름은 {name}이고, 나이는 {age}살 입니다.\""
              },
              {
                "heading": "활용 사례",
                "text": "로그 메시지 기록, 사용자에게 보내는 이메일 내용 생성, 데이터베이스 쿼리 문자열 생성 등 변수와 문자열을 조합해야 하는 모든 상황에 사용됩니다.",
                "code": null
              },
              {
                "heading": "주의점 및 팁",
                "text": "f-string을 사용할 때, 문자열 시작 따옴표 앞에 `f`를 빠뜨리지 않도록 주의하세요. 중괄호 `{}` 안에는 변수뿐만 아니라 ` {age + 1} `과 같은 간단한 계산식도 넣을 수 있습니다.",
                "code": null
              }
            ]
          },
          "feedback": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "보고서 형식 완성",
              "content": "<span class='font-bold text-green-300'>메시지가 아주 깔끔하게 출력되는군요.</span> f-string을 잘 활용했네요. 데이터를 다루는 기본기를 모두 익혔으니, 다음 주차에는 더 복잡한 로직을 다뤄보겠습니다. 수고했어요."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "메시지 형식이 조금 달라요",
              "content": "음, 만들어진 메시지가 요청한 형식과 조금 다르네요. {{ERROR_MESSAGE}} 띄어쓰기나 `%` 같은 특수문자, 마침표까지 정확하게 일치해야 해요. 중괄호 안에 변수 이름은 제대로 들어갔는지도 한번 확인해볼까요?"
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, 문법 오류!",
              "content": "코드를 실행하다가 오류가 발생했어요. f-string을 사용할 때 가장 흔한 실수는 문자열 앞에 `f`를 빠뜨리는 거예요. 혹시 잊으신 건 아닐까요? 아니면 중괄호 `{}`를 빠뜨렸거나, 변수 이름에 오타가 있을 수도 있어요!"
            }
          }
        }
      ]
    },

    {
      "week": 3,
      "title": "흐름 제어: 조건과 반복으로 똑똑한 코드 만들기",
      "cycles": [
        {
          "title": "조건에 따른 분기 (if-elif-else)",
          "syntax_key": "if_statement",
          "filename": "auth.py",
          "starterCode": "def get_welcome_message(user_role):\n    # TODO: if-elif-else 문을 사용하여 user_role에 따라 다른 메시지를 반환(return)하세요.\n    # 'admin' -> \"관리자님 환영합니다.\"\n    # 'editor' -> \"에디터님 안녕하세요.\"\n    # 그 외 모든 경우 -> \"환영합니다.\"\n    \n    # 아래 코드를 수정하여 로직을 구현하세요.\n    if user_role == 'admin':\n        return \"\"\n    \n    return \"\"\n\n# 아래는 테스트용 코드입니다. 수정하지 마세요.\nprint(get_welcome_message('admin'))\nprint(get_welcome_message('editor'))\nprint(get_welcome_message('user'))\n",
          "testCode": "assert get_welcome_message('admin') == \"관리자님 환영합니다.\", \"user_role이 'admin'일 때 반환값이 다릅니다.\"\nassert get_welcome_message('editor') == \"에디터님 안녕하세요.\", \"user_role이 'editor'일 때 반환값이 다릅니다.\"\nassert get_welcome_message('user') == \"환영합니다.\", \"user_role이 'user'일 때 반환값이 다릅니다.\"\nassert get_welcome_message('guest') == \"환영합니다.\", \"정의되지 않은 role('guest')일 때 '환영합니다.'를 반환해야 합니다.\"",
          "task": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "사용자 역할별 접근 제어",
            "content": "보안 강화의 첫 단계입니다. 현재 접속한 사용자의 역할(`user_role`)에 따라 다른 환영 메시지를 보여주는 기능을 구현해야 합니다. 역할이 <span class='font-bold text-yellow-300'>'admin'이면 '관리자님 환영합니다.'</span>를, <span class='font-bold text-yellow-300'>'editor'이면 '에디터님 안녕하세요.'</span>를, 그 외의 <span class='font-bold text-yellow-300'>'user'에게는 '환영합니다.'</span>를 출력해주세요."
          },
          "briefing": {
            "character": "sena",
            "subtitle": "직속 선임의 OJT",
            "title": "갈림길을 만드는 `if`",
            "content": "이건 마치 코드에 갈림길을 만들어주는 것과 같아요. '만약 ~라면 A로 가고, 아니고 만약 ~라면 B로 가고, 그것도 아니면 C로 가라'고 알려주는 거죠. 이때 <span class='font-bold text-teal-300'>`if`, `elif`, `else`</span> 구문을 사용하면 돼요. 변수의 값이 특정 문자열과 <span class='font-bold text-teal-300'>같은지 비교할 땐 `==` 기호</span>를 쓴다는 것만 기억하면 어렵지 않을 거예요."
          },
          "lecture": {
            "character": "profKim",
            "title": "강의 노트: if 조건문",
            "keyTakeaway": "`if`문은 조건의 참/거짓에 따라 프로그램의 실행 경로를 결정합니다.",
            "sandboxCode": "score = 85\n\nif score >= 90:\n    print(\"A 등급\")\nelif score >= 80:\n    print(\"B 등급\")\nelse:\n    print(\"C 등급\")",
            "sections": [
              {
                "heading": "핵심 개념",
                "text": "흐름 제어란 프로그램의 실행 순서를 제어하는 것을 말합니다. `if`문은 주어진 '조건(condition)'이 참(True)인지 거짓(False)인지에 따라 코드의 실행 흐름을 나누는 가장 기본적인 조건 분기문입니다.",
                "code": null
              },
              {
                "heading": "기본 문법",
                "text": "조건문 뒤에는 콜론(:)을, 실행할 코드는 들여쓰기를 해야 합니다.",
                "code": "if 조건1:\n    # 조건1이 참일 때 실행할 코드\nelif 조건2:\n    # 조건1은 거짓이고, 조건2가 참일 때 실행할 코드\nelse:\n    # 위의 모든 조건이 거짓일 때 실행할 코드"
              },
              {
                "heading": "활용 사례",
                "text": "사용자가 입력한 ID/PW가 올바른지 확인, 점수에 따른 합격/불합격/재시험 결정 등 프로그램이 특정 상황을 '판단'해야 하는 모든 곳에 사용됩니다.",
                "code": null
              },
              {
                "heading": "주의점 및 팁",
                "text": "조건문 뒤에는 반드시 콜론(:)을 붙여야 하며, 각 조건에 따라 실행될 코드 블록은 반드시 '들여쓰기(indentation)'를 해야 합니다. `=`는 값을 할당하는 것이고, `==`가 값이 같은지 비교하는 것이니 헷갈리지 않도록 주의하세요.",
                "code": null
              }
            ]
          },
          "feedback": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "접근 제어 로직 구현 완료",
              "content": "<span class='font-bold text-green-300'>훌륭합니다.</span> 사용자 역할에 따라 정확히 다른 메시지가 출력되는군요. 이 `if`문은 앞으로 만들 거의 모든 기능의 기초가 될 겁니다. 잘 익혀두었어요."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "조건을 다시 확인해볼까요?",
              "content": "테스트 결과가 조금 다르네요. {{ERROR_MESSAGE}} 혹시 `elif`나 `else` 조건이 빠졌거나, 문자열을 비교할 때 오타가 있는 건 아닐까요? 각 역할에 맞는 메시지가 정확히 반환되는지 확인해주세요."
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, 문법 오류!",
              "content": "코드를 실행하다가 오류가 발생했어요. `if`나 `elif`, `else` 뒤에 콜론(`:`)을 빠뜨리진 않았나요? 아니면 들여쓰기가 잘못되었을 수도 있어요. 파이썬은 들여쓰기에 아주 민감하거든요. 다시 한번 확인해주세요!"
            }
          }
        },
        {
          "title": "조건 기반 반복 (while)",
          "syntax_key": "while_loop",
          "filename": "monitor.py",
          "starterCode": "# 가상 서버 상태입니다. 루프가 돌 때마다 하나씩 처리됩니다.\nserver_status_sequence = ['booting', 'booting', 'running']\n\ndef wait_for_server():\n    logs = []\n    # TODO: while 문을 사용하여 server_status가 'running'이 아닐 동안 반복하세요.\n    # 루프 안에서는 아래 두 작업을 순서대로 처리해야 합니다.\n    # 1. logs 리스트에 \"서버 상태 확인 중...\" 메시지를 추가합니다.\n    # 2. server_status_sequence 리스트에서 첫 번째 항목을 꺼내 server_status 변수에 저장합니다.\n    server_status = \"\"\n    \n    # 이 곳에 while 루프를 작성하세요.\n\n\n    logs.append(f\"서버 상태: {server_status}\")\n    return logs\n\n# 아래는 테스트용 코드입니다. 수정하지 마세요.\nfor log in wait_for_server():\n    print(log)",
          "testCode": "server_status_sequence = ['booting', 'booting', 'running']\nexpected_logs = [\n    '서버 상태 확인 중...',\n    '서버 상태 확인 중...',\n    '서버 상태: running'\n]\nactual_logs = wait_for_server()\nassert actual_logs == expected_logs, f\"로그 메시지가 기대와 다릅니다.\\n기대값: {expected_logs}\\n실제값: {actual_logs}\"",
          "task": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "서버 상태 모니터링",
            "content": "새로운 분석 서버를 막 켰는데, 부팅되는 데 시간이 좀 걸립니다. <span class='font-bold text-yellow-300'>서버 상태(`server_status`)가 'running'이 될 때까지</span> 1초마다 \"서버 상태 확인 중...\" 메시지를 출력하며 기다리는 스크립트를 작성해주세요."
          },
          "briefing": {
            "character": "sena",
            "subtitle": "직속 선임의 팁",
            "title": "`while`로 기다리기",
            "content": "이럴 땐 특정 조건이 만족될 때까지 계속 같은 행동을 반복해야 하죠. <span class='font-bold text-teal-300'>`while` 반복문</span>이 딱이에요. '`server_status`가 `\"running\"`이 아닌 동안' 계속 반복하라고 시키면 되겠죠? 아, 그리고 <span class='font-bold text-teal-300'>무한 루프(infinite loop)에 빠지지 않도록 조심</span>해야 해요! 루프 안에서 언젠가는 상태가 바뀌도록 코드를 짜야 한답니다."
          },
          "lecture": {
            "character": "profKim",
            "title": "강의 노트: while 반복문",
            "keyTakeaway": "`while`문은 특정 조건이 참인 동안 코드를 계속 반복합니다.",
            "sandboxCode": "count = 5\nwhile count > 0:\n    print(f\"카운트 다운: {count}\")\n    count = count - 1 # 이 줄이 없으면 무한 루프에 빠져요!\nprint(\"발사!\")",
            "sections": [
              {
                "heading": "핵심 개념",
                "text": "`while`문은 주어진 '조건(condition)'이 참(True)인 '동안(while)' 코드 블록을 계속해서 반복 실행합니다. 조건이 거짓(False)이 되면 반복을 멈추고 다음 코드로 넘어갑니다.",
                "code": null
              },
              {
                "heading": "기본 문법",
                "text": "조건문 뒤에 콜론(:)을, 반복할 코드는 들여쓰기를 해야 합니다.",
                "code": "while 조건:\n    # 조건이 참인 동안 반복해서 실행할 코드"
              },
              {
                "heading": "활용 사례",
                "text": "사용자가 올바른 값을 입력할 때까지 계속 재입력 받기, 게임에서 플레이어의 체력이 0보다 클 동안 계속 게임 진행하기 등 특정 조건 하에 반복이 필요할 때 사용됩니다.",
                "code": null
              },
              {
                "heading": "주의점 및 팁",
                "text": "가장 주의할 점은 '무한 루프'입니다. `while`문의 조건이 항상 참(True)으로 유지되면 프로그램이 멈추지 않고 영원히 반복합니다. 루프 내에서 조건을 변경하는 코드가 반드시 포함되어야 합니다.",
                "code": null
              }
            ]
          },
          "feedback": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "모니터링 스크립트 완성",
              "content": "좋습니다. 서버 상태가 바뀔 때까지 루프가 잘 돌다가, 상태가 바뀌니 정확하게 멈추는군요. <span class='font-bold text-green-300'>`while`문을 잘 이해하고 있습니다.</span> 이런 방식은 시스템의 상태를 감시할 때 자주 사용됩니다."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "루프 조건이나 순서를 확인해볼까요?",
              "content": "결과가 조금 이상하게 나왔어요. {{ERROR_MESSAGE}} `while`문의 조건이 정확한지, 그리고 루프 안에서 상태를 확인하고 메시지를 추가하는 순서가 맞는지 다시 한번 확인해주세요."
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, 무한 루프!",
              "content": "코드가 끝나지 않고 계속 실행되는 것 같아요! 이건 '무한 루프'에 빠진 거예요. 루프 안에서 `server_status` 변수의 값을 바꿔주는 코드를 빠뜨린 건 아닐까요? 루프의 조건이 언젠가는 거짓(False)이 되도록 만들어야 해요."
            }
          }
        },
        {
          "title": "순회 반복 (for)",
          "syntax_key": "for_loop",
          "filename": "broadcast.py",
          "starterCode": "server_list = ['server-alpha', 'server-beta', 'server-gamma']\n\ndef send_notifications():\n    sent_messages = []\n    # TODO: for 문을 사용하여 server_list의 모든 서버 이름을 하나씩 순회하세요.\n    # 루프 안에서 f-string을 이용해 아래 형식의 메시지를 만들어 sent_messages 리스트에 추가해야 합니다.\n    # 형식: \"[서버이름]에 점검 예고 메시지를 발송했습니다.\"\n    \n    # 이 곳에 for 루프를 작성하세요.\n\n\n    return sent_messages\n\n# 아래는 테스트용 코드입니다. 수정하지 마세요.\nfor msg in send_notifications():\n    print(msg)\n",
          "testCode": "expected = [\n    \"server-alpha에 점검 예고 메시지를 발송했습니다.\",\n    \"server-beta에 점검 예고 메시지를 발송했습니다.\",\n    \"server-gamma에 점검 예고 메시지를 발송했습니다.\"\n]\nactual = send_notifications()\nassert actual == expected, f\"생성된 메시지 목록이 기대와 다릅니다.\\n기대값: {expected}\\n실제값: {actual}\"",
          "task": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "전체 서버에 공지 발송",
            "content": "긴급 공지입니다. 우리 회사에서 관리하는 <span class='font-bold text-yellow-300'>모든 서버 목록(`server_list`)</span>에 시스템 점검 예고 메시지를 보내야 합니다. 리스트에 있는 <span class='font-bold text-yellow-300'>서버 이름을 하나씩 꺼내서</span>, \"[서버이름]에 점검 예고 메시지를 발송했습니다.\" 라고 출력하는 스크립트를 작성해주세요."
          },
          "briefing": {
            "character": "sena",
            "subtitle": "직속 선임의 팁",
            "title": "목록 순회는 `for`문 전문가",
            "content": "방금 전 `while`문은 '조건'이 중요했지만, 이번엔 <span class='font-bold text-teal-300'>'목록에 있는 모든 항목에 대해 한 번씩'</span> 작업을 해야 하죠? 이럴 땐 `for` 반복문이 훨씬 간결하고 안전해요. '리스트에 있는 각 아이템에 대하여' 라는 의미로 `for item in my_list:` 처럼 사용하면 된답니다. 무한 루프 걱정도 없고요!"
          },
          "lecture": {
            "character": "profKim",
            "title": "강의 노트: for 반복문",
            "keyTakeaway": "`for`문은 리스트와 같은 데이터 묶음의 모든 항목을 하나씩 순회하며 반복합니다.",
            "sandboxCode": "fruits = [\"사과\", \"바나나\", \"딸기\"]\nfor fruit in fruits:\n    print(f\"{fruit} 맛있어요!\")",
            "sections": [
              {
                "heading": "핵심 개념",
                "text": "`for`문은 리스트, 튜플, 문자열과 같은 '순회 가능한(iterable)' 데이터 구조의 각 항목(item)을 처음부터 끝까지 차례대로 하나씩 꺼내어 코드 블록을 반복 실행합니다.",
                "code": null
              },
              {
                "heading": "기본 문법",
                "text": "`range()` 함수와 함께 사용하면 특정 횟수만큼 반복하는 코드를 쉽게 작성할 수 있습니다.",
                "code": "# 리스트의 각 항목에 대해 반복\nfor 변수 in 리스트:\n    # 반복 실행할 코드\n\n# range() 함수와 함께 사용하기\nfor i in range(5): # 0부터 4까지 5번 반복\n    print(i)"
              },
              {
                "heading": "활용 사례",
                "text": "사용자 목록 전체에 이메일 보내기, 파일의 모든 줄을 한 줄씩 읽어서 처리하기, 특정 횟수만큼 작업 반복하기 등 정해진 범위나 목록을 순회할 때 사용됩니다.",
                "code": null
              },
              {
                "heading": "주의점 및 팁",
                "text": "`while`은 조건 기반, `for`는 순회 기반이라는 차이점을 이해하는 것이 중요합니다. `for`문과 함께 자주 사용되는 `range(n)` 함수는 0부터 n-1까지의 숫자를 만들어냅니다.",
                "code": null
              }
            ]
          },
          "feedback": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "자동화 스크립트 완성",
              "content": "완벽합니다. 서버 목록에 있는 모든 서버에 대해 메시지가 정확히 출력되었네요. <span class='font-bold text-green-300'>이제 수십, 수백 개의 서버가 추가되어도 이 코드 하나면 충분</span>하겠군요. 반복적인 작업을 자동화하는 능력, 개발자의 핵심 역량입니다. 수고했어요."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "메시지 내용이 다른데요?",
              "content": "생성된 메시지 목록이 요청과 다르네요. {{ERROR_MESSAGE}} 혹시 `for`문 안에서 f-string을 사용해서 메시지를 만들 때 오타가 있거나 형식이 잘못된 건 아닐까요? 띄어쓰기나 문장부호까지 똑같은지 확인해주세요."
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, 문법 오류!",
              "content": "코드를 실행하다가 오류가 발생했어요. `for ... in ...:` 구문은 정확하게 작성하셨나요? `in`을 빠뜨리거나, 맨 끝에 콜론(`:`)을 잊어버리는 실수를 자주 하곤 해요. 들여쓰기도 다시 한번 확인해보세요!"
            }
          }
        }
      ]
    },

    {
      "week": 4,
      "title": "코드 재사용의 시작: 함수 정의와 활용",
      "cycles": [
        {
          "title": "함수의 정의와 호출 (def)",
          "syntax_key": "function_def",
          "filename": "utils.py",
          "starterCode": "# TODO: 'show_welcome_message'라는 이름의 함수를 정의하세요.\n# 이 함수는 \"Welcome to LogiCore Tech!\" 라는 문장을 출력해야 합니다.\n\n# 아래에 함수를 정의하세요.\n\n\n\n# 아래는 정의된 함수를 호출하는 코드입니다. 수정하지 마세요.\nshow_welcome_message()\n",
          "testCode": "import io\nfrom contextlib import redirect_stdout\n\nassert 'show_welcome_message' in locals() and callable(show_welcome_message), \"'show_welcome_message' 라는 이름의 함수가 정의되지 않았습니다.\"\n\nf = io.StringIO()\nwith redirect_stdout(f):\n    show_welcome_message()\noutput = f.getvalue().strip()\nexpected = \"Welcome to LogiCore Tech!\"\nassert output == expected, f\"함수 출력값이 다릅니다. 기대값: '{expected}', 실제값: '{output}'\"",
          "task": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "반복 작업 개선하기",
            "content": "최근 여러 스크립트를 작성하면서, 시작할 때마다 회사의 공식 환영 메시지를 계속 복사-붙여넣기 하고 있더군요. 이건 좋은 방법이 아닙니다. 이 <span class='font-bold text-yellow-300'>반복되는 환영 메시지 출력 코드를 재사용 가능한 하나의 덩어리</span>로 만들어 주세요. 파이썬에서는 이걸 <span class='font-bold text-yellow-300'>'함수(function)'</span>라고 부릅니다."
          },
          "briefing": {
            "character": "sena",
            "subtitle": "직속 선임의 OJT",
            "title": "나만의 명령어 만들기",
            "content": "아, 리팩토링(refactoring) 작업이네요! 코드를 복사-붙여넣기 하면 나중에 메시지가 바뀔 때마다 모든 파일을 찾아다니며 수정해야 해서 끔찍한 상황이 생겨요. 이럴 때 <span class='font-bold text-teal-300'>`def` 키워드로 함수를 만들면</span>, 코드를 한 곳에서만 관리할 수 있죠. <span class='font-bold text-teal-300'>함수는 '나만의 새로운 명령어'를 만드는 것</span>과 같아요. 한번 만들어두면, 이름만 불러서 계속 쓸 수 있답니다."
          },
          "lecture": {
            "character": "profKim",
            "title": "강의 노트: 함수 (Function)",
            "keyTakeaway": "함수는 `def`로 정의하고, 이름()으로 호출하는 재사용 가능한 코드 블록입니다.",
            "sandboxCode": "def show_my_name():\n    name = \"김신입\"\n    print(f\"제 이름은 {name}입니다.\")\n\n# 아래에 함수를 호출해서 이름을 출력해보세요.\nshow_my_name()",
            "sections": [
              {
                "heading": "핵심 개념",
                "text": "함수(Function)는 특정 작업을 수행하는 코드 덩어리에 이름을 붙인 것입니다. 프로그램을 논리적인 단위로 나눌 수 있게 해주며, 코드의 재사용성을 극대화합니다. 잘 정의된 함수는 '무엇을 하는지'는 알려주지만 '어떻게 하는지'는 숨겨주는 '추상화'의 첫걸음입니다.",
                "code": null
              },
              {
                "heading": "기본 문법",
                "text": "함수를 정의하는 것을 '선언'이라 하고, 사용하는 것을 '호출'이라고 합니다.",
                "code": "# 함수 정의하기(선언)\ndef 함수이름():\n    # 이 블록 안에 재사용할 코드를 작성\n    print(\"Hello Function!\")\n\n# 함수 호출하기(사용)\n함수이름()"
              },
              {
                "heading": "활용 사례",
                "text": "프로그램의 시작 부분에 환영 메시지 출력하기, 복잡한 계산 수행하기, 파일 내용 읽어오기 등 반복적으로 사용될 가능성이 있는 모든 코드 묶음에 활용됩니다.",
                "code": null
              },
              {
                "heading": "주의점 및 팁",
                "text": "함수 이름은 소문자와 밑줄(_)을 사용하여 만드는 것이 일반적입니다. 함수를 정의(`def`)만 하고 호출하지 않으면 코드는 실행되지 않습니다. 반드시 이름으로 호출해야 합니다.",
                "code": null
              }
            ]
          },
          "feedback": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "유지보수성 향상",
              "content": "<span class='font-bold text-green-300'>좋습니다. 이제 환영 메시지가 바뀌더라도 우리는 이 함수 하나만 수정</span>하면 되겠군요. 이렇게 코드를 재사용 가능하게 만드는 것이 <span class='font-bold text-green-300'>유지보수가 쉬운 코드를 만드는 첫걸음</span>입니다."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "출력 메시지를 확인해볼까요?",
              "content": "함수는 잘 만들어졌는데, 출력된 메시지가 요청한 내용과 조금 다르네요. {{ERROR_MESSAGE}} 함수 안에 있는 `print`문의 문자열에 오타가 없는지 다시 한번 확인해주세요."
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, 함수를 찾을 수 없어요!",
              "content": "함수를 호출하는 부분에서 오류가 발생했어요. 혹시 함수를 정의할 때 `def 함수이름():` 형식을 정확하게 지키셨나요? 함수 이름에 오타가 있거나, 정의하는 부분의 들여쓰기가 잘못되었을 수도 있으니 확인해보세요."
            }
          }
        },
        {
          "title": "값의 전달과 반환 (매개변수와 return)",
          "syntax_key": "function_params_return",
          "filename": "hr_system.py",
          "starterCode": "def get_personalized_greeting(username):\n    # TODO: username을 사용하여 \"Welcome, [username]!\" 형식의 문자열을 반환(return)하세요.\n    # 예를 들어, username이 \"Alex\"라면 \"Welcome, Alex!\"를 반환해야 합니다.\n    return \"\"\n\ndef calculate_bonus(score):\n    # TODO: score의 10%를 보너스로 계산하여 그 결과를 반환(return)하세요. (score * 0.1)\n    return 0\n\n# 아래는 테스트용 코드입니다. 수정하지 마세요.\nprint(get_personalized_greeting(\"Alex\"))\nprint(calculate_bonus(1000))\n",
          "testCode": "assert get_personalized_greeting('Alex') == \"Welcome, Alex!\", \"get_personalized_greeting('Alex')의 반환값이 'Welcome, Alex!'여야 합니다.\"\nassert get_personalized_greeting('Sena') == \"Welcome, Sena!\", \"get_personalized_greeting('Sena')의 반환값이 'Welcome, Sena!'여야 합니다.\"\nassert calculate_bonus(1000) == 100, \"calculate_bonus(1000)의 반환값이 100이어야 합니다.\"\nassert calculate_bonus(500) == 50, \"calculate_bonus(500)의 반환값이 50이어야 합니다.\"",
          "task": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "함수 동적으로 만들기",
            "content": "이전 함수를 개선해봅시다. 모든 사용자에게 똑같은 메시지를 보여주는 대신, <span class='font-bold text-yellow-300'>사용자 이름(username)을 함수에 전달</span>하여 개인화된 메시지를 출력하도록 수정해주세요. 추가로, 사용자의 <span class='font-bold text-yellow-300'>성과 점수(score)를 입력받아 보너스 금액을 계산하고, 그 결과를 반환</span>하는 `calculate_bonus` 함수도 만들어주세요."
          },
          "briefing": {
            "character": "sena",
            "subtitle": "직속 선임의 팁",
            "title": "함수의 입구와 출구",
            "content": "함수를 더 유용하게 만들려면 입출구가 필요해요. 함수에 데이터를 넣는 입구가 <span class='font-bold text-teal-300'>'매개변수(parameter)'</span>이고, 함수에서 계산 결과를 밖으로 내보내는 출구가 <span class='font-bold text-teal-300'>`return`</span>이에요. `print()`는 그냥 화면에 보여주고 끝나지만, `return`은 값을 돌려줘서 다른 변수에 저장하거나 또 다른 계산에 쓸 수 있게 해준다는 차이가 있죠."
          },
          "lecture": {
            "character": "profKim",
            "title": "강의 노트: 매개변수와 Return",
            "keyTakeaway": "매개변수로 데이터를 받고, `return`으로 결과를 돌려주어 함수를 유연하게 활용할 수 있습니다.",
            "sandboxCode": "def get_greeting(name):\n    return f\"{name}님, 안녕하세요!\"\n\nmessage = get_greeting(\"김선임\")\nprint(message)",
            "sections": [
              {
                "heading": "핵심 개념",
                "text": "매개변수(Parameter)는 함수가 작업을 수행하는 데 필요한 외부 데이터를 받아들이는 '입력' 통로입니다. `return`문은 함수의 작업 결과를 호출한 곳으로 되돌려주는 '출력' 통로입니다.",
                "code": null
              },
              {
                "heading": "기본 문법",
                "text": "함수 정의 시 소괄호 안에 매개변수 이름을, 함수 코드 블록 안에 `return`을 사용합니다.",
                "code": "# 매개변수가 있는 함수 정의\ndef add(a, b):\n    result = a + b\n    return result\n\n# 함수 호출 및 결과 저장\nsum_value = add(10, 5)\nprint(sum_value) # 15 출력"
              },
              {
                "heading": "활용 사례",
                "text": "사용자 이름을 받아 환영 메시지를 꾸미거나, 두 숫자를 받아 계산 결과를 얻는 등 함수의 동작을 외부 값에 따라 유연하게 바꾸고 싶을 때 사용됩니다.",
                "code": null
              },
              {
                "heading": "주의점 및 팁",
                "text": "함수를 호출할 때 넘겨주는 값(인자)의 순서는 매개변수의 순서와 일치해야 합니다. `return`문이 실행되면 함수는 즉시 종료됩니다. `return` 아래에 있는 코드는 실행되지 않습니다.",
                "code": null
              }
            ]
          },
          "feedback": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "훌륭한 함수 설계",
              "content": "완벽합니다. 이제 함수를 통해 <span class='font-bold text-green-300'>개인화된 메시지</span>를 만들 수 있고, 보너스 계산 결과를 <span class='font-bold text-green-300'>다른 변수에 저장하여 재사용</span>할 수도 있겠군요. 함수 설계의 핵심을 잘 이해했습니다."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "반환값을 확인해볼까요?",
              "content": "함수에서 돌려준 값이 예상과 조금 다르네요. {{ERROR_MESSAGE}} 인사말을 만드는 함수에서는 f-string이 정확한지, 보너스 계산 함수에서는 계산식이 올바른지 다시 한번 확인해주세요."
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, 매개변수 오류!",
              "content": "함수를 호출하거나 정의하는 부분에서 오류가 발생했어요. 함수를 정의할 때 `def 함수이름(매개변수):` 형식으로 괄호 안에 매개변수 이름을 잘 넣어주셨나요? 혹은 함수 안에서 `return` 키워드를 빠뜨린 건 아닐까요?"
            }
          }
        },
        {
          "title": "변수의 유효 범위 (Scope)",
          "syntax_key": "variable_scope",
          "filename": "task_manager.py",
          "starterCode": "total_task_count = 0 # 전역 변수\n\ndef complete_task():\n    # TODO: 전역 변수 total_task_count의 값을 1 증가시키세요.\n    # 함수 안에서 전역 변수의 값을 바꾸려면 무엇을 해야 할까요?\n    \n    pass # 이 부분을 수정하여 코드를 작성하세요.\n\n# 아래는 테스트용 코드입니다. 수정하지 마세요.\nprint(f\"호출 전: {total_task_count}\")\ncomplete_task()\nprint(f\"1회 호출 후: {total_task_count}\")\ncomplete_task()\nprint(f\"2회 호출 후: {total_task_count}\")\n",
          "testCode": "total_task_count = 0\ncomplete_task()\nassert total_task_count == 1, \"complete_task()를 한 번 호출하면 total_task_count가 1이어야 합니다.\"\ncomplete_task()\ncomplete_task()\nassert total_task_count == 3, \"complete_task()를 총 세 번 호출하면 total_task_count가 3이어야 합니다.\"",
          "task": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "전역 상태 관리",
            "content": "우리 애플리케이션 전체에서 공유되는 <span class='font-bold text-yellow-300'>'총 작업 횟수(total_task_count)' 변수</span>가 있습니다. 사용자가 특정 작업을 완료할 때마다 호출되는 함수 `complete_task()`를 만들고, 이 함수 안에서 <span class='font-bold text-yellow-300'>바깥에 있는 `total_task_count`의 값을 1 증가</span>시키도록 구현해주세요."
          },
          "briefing": {
            "character": "sena",
            "subtitle": "직속 선임의 팁",
            "title": "함수 안과 밖은 다른 세상",
            "content": "이거 신입 때 많이 하는 실수인데, 함수 안에서 바깥에 있는 변수를 그냥 바꾸려고 하면 에러가 날 거예요. 파이썬은 기본적으로 함수 안을 독립된 공간으로 보거든요. 함수 안에서 바깥 세상에 있는 변수를 직접 수정하고 싶다면, <span class='font-bold text-teal-300'>'이 변수는 바깥에 있는 전역 변수입니다!'</span>라고 알려주는 <span class='font-bold text-teal-300'>`global`</span> 키워드를 써야 해요."
          },
          "lecture": {
            "character": "profKim",
            "title": "강의 노트: 변수의 범위 (Scope)",
            "keyTakeaway": "함수 안에서 바깥의 전역 변수 값을 바꾸려면 `global` 키워드가 필요합니다.",
            "sandboxCode": "message = \"바깥 메시지\"\n\ndef change_message():\n    # 이 함수 안에서 message 변수의 값을\n    # \"안쪽 메시지\"로 바꿔보세요.\n    global message\n    message = \"안쪽 메시지\"\n\nchange_message()\nprint(message)",
            "sections": [
              {
                "heading": "핵심 개념",
                "text": "변수가 유효한 범위를 스코프(Scope)라고 합니다. 함수 안에서 만들어진 변수는 '지역 변수(Local Variable)'라 하며, 함수 안에서만 사용할 수 있고 함수가 끝나면 사라집니다. 함수 바깥 최상단에서 만들어진 변수는 '전역 변수(Global Variable)'라 하며, 프로그램 어디서든 접근할 수 있습니다.",
                "code": null
              },
              {
                "heading": "기본 문법",
                "text": "함수 안에서 전역 변수의 값을 '변경'하려면 `global` 키워드를 사용해야 합니다.",
                "code": "count = 0 # 전역 변수\n\ndef increment():\n    global count # 전역 변수 count를 수정하겠다고 선언\n    count = count + 1"
              },
              {
                "heading": "활용 사례",
                "text": "프로그램의 전체 설정값이나 상태를 저장하는 전역 변수를 여러 함수에서 읽거나, 지금처럼 값을 변경해야 할 때 사용됩니다.",
                "code": null
              },
              {
                "heading": "주의점 및 팁",
                "text": "전역 변수를 너무 많이 사용하면 코드의 흐름을 파악하기 어려워집니다. 함수 안에서 전역 변수를 '읽는 것'은 `global` 선언 없이도 가능하지만, '값을 변경(할당)'하려면 반드시 `global` 선언이 필요합니다.",
                "code": null
              }
            ]
          },
          "feedback": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "변수 범위 마스터",
              "content": "<span class='font-bold text-green-300'>전역 카운터가 정상적으로 증가하는 것을 확인했습니다.</span> 변수의 유효 범위를 이해하는 것은 여러 함수가 상호작용하는 복잡한 프로그램을 만들 때 매우 중요합니다. 핵심 개념을 잘 습득했네요. 수고했습니다."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "전역 변수가 그대로인데요?",
              "content": "함수를 호출했는데도 전역 변수의 값이 바뀌지 않았어요. {{ERROR_MESSAGE}} 혹시 함수 안에서 `global` 키워드를 사용해서 이 변수가 전역 변수임을 알려주는 코드를 빠뜨린 건 아닐까요?"
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, UnboundLocalError!",
              "content": "오류 메시지에 `UnboundLocalError`라고 나오네요. 이 오류는 함수 안에서 `global` 선언 없이 전역 변수를 수정하려고 할 때 자주 발생해요. 파이썬이 이 변수를 지역 변수로 착각해서 생기는 문제랍니다. `global` 키워드를 추가해보세요!"
            }
          }
        }
      ]
    },

    {
      "week": 5,
      "title": "자료구조 (1): 순서가 있는 데이터 묶음, 리스트와 튜플",
      "cycles": [
        {
          "title": "리스트 생성 및 기본 조작",
          "syntax_key": "list_basic",
          "filename": "task_list.py",
          "starterCode": "# TODO: 1. 'sprint_tasks'라는 이름의 비어있는 리스트를 만드세요.\n\n\n# TODO: 2. 'sprint_tasks' 리스트에 '사용자 로그인 기능 개발'을 추가하세요.\n\n\n# TODO: 3. 'sprint_tasks' 리스트에 '게시판 UI 개선'을 추가하세요.\n\n\n# 아래는 테스트용 코드입니다. 수정하지 마세요.\nprint(sprint_tasks)\n",
          "testCode": "assert 'sprint_tasks' in locals(), \"'sprint_tasks' 변수가 존재하지 않습니다.\"; assert isinstance(sprint_tasks, list), \"'sprint_tasks' 변수는 리스트(list)여야 합니다.\"; expected = ['사용자 로그인 기능 개발', '게시판 UI 개선']; assert sprint_tasks == expected, f\"리스트의 내용이 기대와 다릅니다. 기대값: {expected}, 실제값: {sprint_tasks}\"",
          "task": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "스프린트 업무 목록 관리",
            "content": "다음 스프린트에서 진행할 업무 목록을 관리해야 합니다. 먼저 <span class='font-bold text-yellow-300'>`sprint_tasks` 라는 이름의 비어있는 리스트</span>를 하나 만들어주세요. 그 다음, 목록에 <span class='font-bold text-yellow-300'>'사용자 로그인 기능 개발'</span>과 <span class='font-bold text-yellow-300'>'게시판 UI 개선'</span>이라는 두 가지 업무를 추가해주세요."
          },
          "briefing": {
            "character": "sena",
            "subtitle": "직속 선임의 OJT",
            "title": "여러 개를 담는 보관함, 리스트",
            "content": "지금까지는 변수에 값을 하나씩만 담았죠? <span class='font-bold text-teal-300'>리스트(List)</span>는 여러 개의 값을 순서대로 담을 수 있는 만능 보관함이에요. <span class='font-bold text-teal-300'>`[]`(대괄호)</span>로 빈 리스트를 만들 수 있고, <span class='font-bold text-teal-300'>`.append()`</span> 라는 메소드를 쓰면 리스트의 맨 뒤에 새 항목을 간단하게 추가할 수 있답니다."
          },
          "lecture": {
            "character": "profKim",
            "title": "강의 노트: 리스트 (List)",
            "keyTakeaway": "리스트는 `[]`로 만들며, `.append()`로 항목을 추가하고 `del`로 삭제하는 '변경 가능한' 데이터 묶음입니다.",
            "sandboxCode": "todo_list = []\ntodo_list.append(\"파이썬 공부\")\ntodo_list.append(\"저녁 식사\")\nprint(todo_list)",
            "sections": [
              {
                "heading": "핵심 개념",
                "text": "리스트(List)는 여러 데이터를 순서대로 담을 수 있는 자료구조입니다. 리스트의 가장 큰 특징은 생성된 후에도 값을 추가, 삭제, 변경할 수 있다는 점입니다. 이를 '변경 가능(mutable)'하다고 합니다.",
                "code": null
              },
              {
                "heading": "기본 문법",
                "text": "대괄호 `[]`를 사용해 만들고, `.append()` 메소드로 항목을 추가합니다.",
                "code": "# 빈 리스트 생성\nmy_list = []\n\n# 항목 추가하기\nmy_list.append(\"사과\")\nmy_list.append(100)\n\n# 항목 삭제하기 (첫 번째 항목)\ndel my_list[0]"
              },
              {
                "heading": "활용 사례",
                "text": "사용자 목록, 할 일 목록, 점수 목록 등 순서가 있고 내용이 계속 바뀔 수 있는 데이터를 관리할 때 매우 유용하게 사용됩니다.",
                "code": null
              },
              {
                "heading": "주의점 및 팁",
                "text": "리스트의 첫 번째 항목의 위치(인덱스)는 1이 아닌 0입니다. `.append()`는 항상 리스트의 맨 마지막에 항목을 추가합니다.",
                "code": null
              }
            ]
          },
          "feedback": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "업무 목록 생성 완료",
              "content": "<span class='font-bold text-green-300'>정확하게 리스트를 만들고 항목들을 추가했군요.</span> 좋습니다. 이제 이 리스트를 바탕으로 프로젝트의 진행 상황을 추적할 수 있겠습니다. 다음은 이 목록을 좀 더 다루는 방법을 알아보죠."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "리스트 내용이 다른데요?",
              "content": "생성된 리스트의 내용이 요청과 조금 다르네요. {{ERROR_MESSAGE}} `.append()` 메소드를 사용해서 두 업무를 순서대로 추가했는지 확인해볼까요? 문자열에 오타가 있을 수도 있어요."
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, 문법 오류!",
              "content": "코드를 실행하다가 오류가 발생했어요. 비어있는 리스트를 만들 때 `sprint_tasks = []` 처럼 대괄호를 사용하셨나요? `.append()` 메소드를 사용할 때 괄호 안에 추가할 항목을 잘 넣었는지도 확인해주세요."
            }
          }
        },
        {
          "title": "리스트 고급 활용 (인덱싱, 슬라이싱, 정렬)",
          "syntax_key": "list_advanced",
          "filename": "report_generator.py",
          "starterCode": "sprint_tasks = ['사용자 로그인 기능 개발', '게시판 UI 개선', '결제 시스템 연동']\n\n# TODO: 1. 인덱싱을 사용해 첫 번째 업무를 'first_task' 변수에 저장하세요.\nfirst_task = \"\"\n\n# TODO: 2. 'sprint_tasks' 리스트를 알파벳 순으로 정렬하세요.\n\n\n# TODO: 3. 정렬된 리스트에서 처음 두 개의 업무를 'main_tasks' 변수에 슬라이싱하여 저장하세요.\nmain_tasks = []\n\n# 아래는 테스트용 코드입니다. 수정하지 마세요.\nprint(f\"첫 번째 업무: {first_task}\")\nprint(f\"정렬된 전체 업무: {sprint_tasks}\")\nprint(f\"핵심 업무: {main_tasks}\")\n",
          "testCode": "first_task_expected = '사용자 로그인 기능 개발'; assert 'first_task' in locals() and first_task == first_task_expected, f\"first_task의 값이 다릅니다. 기대값: '{first_task_expected}', 실제값: '{locals().get('first_task')}'\"; sorted_tasks_expected = sorted(['사용자 로그인 기능 개발', '게시판 UI 개선', '결제 시스템 연동']); assert 'sprint_tasks' in locals() and sprint_tasks == sorted_tasks_expected, f\"리스트가 올바르게 정렬되지 않았습니다. 기대값: {sorted_tasks_expected}, 실제값: {locals().get('sprint_tasks')}\"; main_tasks_expected = sorted_tasks_expected[:2]; assert 'main_tasks' in locals() and main_tasks == main_tasks_expected, f\"main_tasks의 값이 다릅니다. 기대값: {main_tasks_expected}, 실제값: {locals().get('main_tasks')}\"",
          "task": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "업무 보고서 작성",
            "content": "기획팀에 보고할 자료입니다. `sprint_tasks` 리스트에서 <span class='font-bold text-yellow-300'>가장 첫 번째 업무가 무엇인지</span> 알려주세요. 그리고 회의 자료에 쓸 수 있도록, 전체 업무 목록을 <span class='font-bold text-yellow-300'>알파벳 순으로 정렬</span>해서 보여주세요. 마지막으로, 정렬된 목록에서 <span class='font-bold text-yellow-300'>처음 두 개의 업무만</span> 따로 뽑아서 보고해주세요."
          },
          "briefing": {
            "character": "sena",
            "subtitle": "직속 선임의 팁",
            "title": "리스트 자유자재로 다루기",
            "content": "리스트에서 특정 항목을 꺼낼 땐 위치 번호, 즉 <span class='font-bold text-teal-300'>'인덱스'</span>를 대괄호 `[]` 안에 써주면 돼요. 첫 번째는 `[0]`인 거 잊지 마세요! 리스트를 정렬할 땐 <span class='font-bold text-teal-300'>`.sort()`</span> 메소드를 쓰면 그 자리에서 바로 정렬돼요. 그리고 여러 개를 잘라낼 땐 콜론(`:`)을 사용한 <span class='font-bold text-teal-300'>'슬라이싱'</span>을 쓰면 아주 편하답니다. `my_list[0:2]` 처럼요."
          },
          "lecture": {
            "character": "profKim",
            "title": "강의 노트: 인덱싱, 슬라이싱, 정렬",
            "keyTakeaway": "인덱싱 `[i]`으로 하나를, 슬라이싱 `[i:j]`으로 여러 개를 꺼내고, `.sort()`로 정렬할 수 있습니다.",
            "sandboxCode": "scores = [90, 75, 100, 80]\nscores.sort()\n\n# 정렬된 리스트에서 가장 높은 점수(맨 마지막 항목)를 출력해보세요.\nprint(scores[-1])",
            "sections": [
              {
                "heading": "핵심 개념",
                "text": "리스트는 순서가 있기 때문에, 각 항목의 위치(인덱스)를 통해 특정 값에 접근하거나, 특정 범위의 값들을 잘라낼 수 있습니다. 또한, 내장된 기능을 통해 손쉽게 정렬할 수 있습니다.",
                "code": null
              },
              {
                "heading": "기본 문법",
                "text": "대괄호 `[]`와 콜론 `:`을 사용해 데이터에 접근하고 잘라냅니다.",
                "code": "my_list = ['b', 'c', 'a']\n\n# 인덱싱 (0번째 항목 접근)\nfirst_item = my_list[0]  # 'b'\n\n# 슬라이싱 (0번째부터 2번째 앞까지)\nslice_items = my_list[0:2] # ['b', 'c']\n\n# 정렬 (리스트 자체를 변경)\nmy_list.sort() # my_list는 이제 ['a', 'b', 'c']"
              },
              {
                "heading": "활용 사례",
                "text": "가장 높은 점수나 가장 낮은 점수 찾기, 특정 기간의 데이터만 추출하기, 이름을 가나다순으로 정렬하여 보여주기 등 데이터의 순서나 특정 위치가 중요할 때 사용됩니다.",
                "code": null
              },
              {
                "heading": "주의점 및 팁",
                "text": "인덱스는 0부터 시작하며, 없는 인덱스에 접근하면 오류가 발생합니다. 슬라이싱 `[a:b]`는 a부터 b-1까지의 항목을 포함합니다. `.sort()`는 리스트 자체를 바꾸므로 원본을 유지하고 싶다면 복사본을 만들어 사용해야 합니다.",
                "code": null
              }
            ]
          },
          "feedback": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "보고 완료",
              "content": "<span class='font-bold text-green-300'>요청한 데이터를 정확하게 추출하고 정렬했네요.</span> 리스트를 다루는 실력이 빠르게 늘고 있군요. 이런 데이터 가공 능력은 분석 업무의 기본입니다. 마지막으로 리스트와 비슷하지만 아주 중요한 차이가 있는 자료구조를 알아보죠."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "결과값이 조금 다른데요?",
              "content": "추출하거나 정렬한 결과가 요청과 조금 다르네요. {{ERROR_MESSAGE}} 인덱싱은 `[0]`부터 시작하는 것, 슬라이싱은 `[:2]`처럼 끝 번호를 지정하는 것을 다시 확인해볼까요? `.sort()` 메소드를 호출하는 것을 잊었을 수도 있어요."
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, 인덱스 오류!",
              "content": "오류 메시지에 `IndexError`라고 나오네요. 리스트에 존재하지 않는 위치의 항목에 접근하려고 할 때 발생하는 오류에요. 리스트의 길이를 벗어나는 인덱스를 사용한 건 아닌지 확인해주세요!"
            }
          }
        },
        {
          "title": "수정 불가능한 튜플의 이해",
          "syntax_key": "tuple_data",
          "filename": "config.py",
          "starterCode": "# TODO: 서버 접속 정보를 담은 튜플 'server_config'를 생성하세요.\n# 값은 순서대로 '192.168.1.1' (IP 주소)와 8080 (포트 번호)입니다.\n\nserver_config = () # 이 부분을 수정하세요.\n\n# 아래는 테스트용 코드입니다. 수정하지 마세요.\nprint(f\"서버 IP: {server_config[0]}\")\nprint(f\"서버 포트: {server_config[1]}\")\n",
          "testCode": "assert 'server_config' in locals(), \"'server_config' 변수가 존재하지 않습니다.\"; assert isinstance(server_config, tuple), \"'server_config' 변수는 튜플(tuple)이어야 합니다.\"; expected = ('192.168.1.1', 8080); assert server_config == expected, f\"튜플의 내용이 기대와 다릅니다. 기대값: {expected}, 실제값: {server_config}\"",
          "task": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "고정 데이터 관리",
            "content": "서비스의 <span class='font-bold text-yellow-300'>핵심 설정값</span>을 저장해야 합니다. 예를 들어, 서버 접속 정보(IP 주소, 포트 번호)처럼 프로그램 실행 중에 <span class='font-bold text-yellow-300'>절대로 바뀌어서는 안 되는 고정된 값</span>들이죠. 이런 데이터는 실수로 변경되는 것을 막기 위해 리스트가 아닌 **'튜플(Tuple)'**을 사용해 저장해주세요."
          },
          "briefing": {
            "character": "sena",
            "subtitle": "직속 선임의 팁",
            "title": "안전한 보관함, 튜플",
            "content": "<span class='font-bold text-teal-300'>튜플(Tuple)</span>은 리스트와 거의 똑같이 생겼는데, 딱 한 가지 다른 점이 있어요. 바로 <span class='font-bold text-teal-300'>한번 만들면 절대 내용을 바꿀 수 없다</span>는 거예요. '불변(immutable)'하다고 하죠. 대괄호 `[]` 대신 소괄호 `()`를 써서 만들어요. 데이터가 절대 바뀌지 않을 거라고 보장해야 할 때 사용하면 코드가 훨씬 안전해진답니다."
          },
          "lecture": {
            "character": "profKim",
            "title": "강의 노트: 튜플 (Tuple)",
            "keyTakeaway": "튜플은 `()`로 만들며, 한번 만들면 내용을 바꿀 수 없는 '안전한' 데이터 묶음입니다.",
            "sandboxCode": "# x, y 좌표를 튜플로 저장하고 y좌표를 출력해보세요.\npoint = (10, 20)\nprint(point[1])",
            "sections": [
              {
                "heading": "핵심 개념",
                "text": "튜플(Tuple)은 리스트처럼 순서가 있는 데이터 묶음이지만, 생성된 후에는 항목을 추가, 삭제, 변경할 수 없는 '변경 불가능(immutable)'한 자료구조입니다. 이 불변성 덕분에 데이터의 무결성을 보장해야 할 때 유용합니다.",
                "code": null
              },
              {
                "heading": "기본 문법",
                "text": "소괄호 `()`를 사용하여 생성합니다. 접근은 리스트와 같이 인덱싱을 사용합니다.",
                "code": "# 튜플 생성\nmy_tuple = (1, 2, 'c')\n\n# 인덱싱으로 접근 가능\nfirst_item = my_tuple[0] # 1\n\n# 변경 시도 시 오류 발생!\n# my_tuple[0] = 5  # TypeError 발생"
              },
              {
                "heading": "활용 사례",
                "text": "함수에서 여러 개의 값을 반환할 때, 좌표(x, y)값처럼 변하면 안 되는 순서쌍을 저장할 때, 딕셔너리의 키(Key)로 사용할 때 등 데이터의 일관성과 안정성이 중요할 때 사용됩니다.",
                "code": null
              },
              {
                "heading": "주의점 및 팁",
                "text": "항목이 하나인 튜플을 만들 때는 반드시 항목 뒤에 쉼표를 붙여야 합니다. 예: `(5,)`. 쉼표가 없으면 `(5)`는 그냥 숫자 5로 인식됩니다.",
                "code": null
              }
            ]
          },
          "feedback": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "안정적인 코드 작성",
              "content": "<span class='font-bold text-green-300'>튜플을 적재적소에 잘 사용했네요.</span> 이제 이 설정값은 다른 개발자가 실수로 변경할 염려가 없겠습니다. <span class='font-bold text-green-300'>언제 리스트를 써야 하고, 언제 튜플을 써야 하는지 구분</span>할 수 있다는 건 매우 중요한 역량입니다."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "튜플 내용이 다른데요?",
              "content": "튜플에 저장된 값이 요청과 조금 다르네요. {{ERROR_MESSAGE}} IP 주소와 포트 번호가 순서대로 올바르게 들어갔는지 확인해주세요. IP 주소는 문자열이니까 따옴표로 감싸는 것 잊지 마세요!"
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, 문법 오류!",
              "content": "튜플을 만들 때 오류가 발생했어요. 튜플은 `()` 소괄호로 만드는 거 기억하시죠? 그리고 각 항목은 쉼표(`,`)로 구분해야 해요. `('192.168.1.1', 8080)` 이런 식으로요."
            }
          }
        }
      ]
    },
    {
      "week": 6,
      "title": "자료구조 (2): Key-Value 데이터, 딕셔너리와 집합",
      "cycles": [
        {
          "title": "Key-Value 쌍, 딕셔너리 기초",
          "syntax_key": "dict_basic",
          "filename": "profile.py",
          "starterCode": "# TODO: 'user_profile'이라는 이름의 딕셔너리를 만드세요.\n# 이 딕셔너리에는 아래의 키-값 쌍이 포함되어야 합니다.\n# 1. 'username' 키에는 'rookie' 라는 문자열 값을 할당하세요.\n# 2. 'level' 키에는 1 이라는 숫자 값을 할당하세요.\n# 3. 'team' 키에는 '솔루션개발팀' 이라는 문자열 값을 할당하세요.\n\nuser_profile = {}\n\n# 아래는 테스트용 코드입니다. 수정하지 마세요.\nprint(user_profile)\n",
          "testCode": "assert 'user_profile' in locals() and isinstance(user_profile, dict), \"user_profile 변수는 딕셔너리여야 합니다.\"; expected = {'username': 'rookie', 'level': 1, 'team': '솔루션개발팀'}; assert user_profile == expected, f\"딕셔너리의 내용이 기대와 다릅니다. 기대값: {expected}, 실제값: {user_profile}\"",
          "task": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "사용자 프로필 데이터 구조화",
            "content": "지금까지 사용자 정보를 개별 변수로 관리했는데, 한계가 명확하네요. <span class='font-bold text-yellow-300'>한 명의 사용자 프로필 정보</span>(예: 아이디, 닉네임, 레벨)를 하나의 묶음으로 관리해야 합니다. 이런 '이름표가 붙은 데이터'를 다룰 때는 **'딕셔너리(Dictionary)'**가 가장 적합합니다. OOO님의 <span class='font-bold text-yellow-300'>개인 프로필 정보를 담은 딕셔너리</span>를 만들어주세요."
          },
          "briefing": {
            "character": "sena",
            "subtitle": "직속 선임의 OJT",
            "title": "이름표를 붙여 정리하기",
            "content": "리스트는 순서가 중요했지만, '몇 번째'인지보다 '무엇'인지가 더 중요할 때가 있죠? <span class='font-bold text-teal-300'>딕셔너리</span>는 마치 모든 물건에 이름표를 붙여놓은 서랍장 같아요. <span class='font-bold text-teal-300'>`{}`(중괄호)</span>를 쓰고, <span class='font-bold text-teal-300'>`'이름표(Key)': 값(Value)`</span> 형태로 데이터를 저장하면 돼요. 순서를 외울 필요 없이 이름표만 알면 바로 값을 꺼낼 수 있어서 정말 편리하답니다."
          },
          "lecture": {
            "character": "profKim",
            "title": "강의 노트: 딕셔너리 (Dictionary)",
            "keyTakeaway": "딕셔너리는 `{Key: Value}` 형태로, 순서가 아닌 이름(Key)으로 데이터를 관리하는 자료구조입니다.",
            "sandboxCode": "my_pet = {\n    \"name\": \"Happy\",\n    \"animal_type\": \"Dog\"\n}\n\n# 펫의 이름을 출력해보세요.\nprint(my_pet[\"name\"])",
            "sections": [
              {
                "heading": "핵심 개념",
                "text": "딕셔너리(Dictionary)는 순서 대신 '키(Key)'를 사용하여 각 값(Value)에 접근하는 자료구조입니다. 모든 키는 고유해야 하며, 이 키-값(Key-Value) 쌍들의 묶음으로 데이터를 관리합니다. 마치 사전에서 단어(Key)를 찾아 뜻(Value)을 찾는 것과 같습니다.",
                "code": null
              },
              {
                "heading": "기본 문법",
                "text": "중괄호 `{}`를 사용하며, `키: 값` 형식으로 각 항목을 정의하고 쉼표로 구분합니다.",
                "code": "# 딕셔너리 생성\nmy_profile = {\n    \"username\": \"rookie\",\n    \"level\": 5,\n    \"is_active\": True\n}\n\n# 값에 접근하기 (키 사용)\nprint(my_profile[\"username\"]) # 'rookie' 출력"
              },
              {
                "heading": "활용 사례",
                "text": "사용자 정보, 게임 캐릭터의 능력치, JSON 형식의 API 응답 데이터 등 명확한 이름(Key)으로 각 데이터를 구분해야 할 때 광범위하게 사용됩니다.",
                "code": null
              },
              {
                "heading": "주의점 및 팁",
                "text": "딕셔너리의 키(Key)는 고유해야 하며, 중복될 수 없습니다. 또한, 키는 문자열이나 숫자처럼 '변경 불가능(immutable)'한 값만 사용할 수 있습니다. 없는 키로 값에 접근하려고 하면 오류가 발생합니다.",
                "code": null
              }
            ]
          },
          "feedback": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "데이터 구조화 완료",
              "content": "<span class='font-bold text-green-300'>사용자 정보가 딕셔너리 형태로 잘 정리되었군요.</span> 이제 데이터가 훨씬 명확하고 관리하기 쉬워졌습니다. 앞으로 서버와 데이터를 주고받을 때 이 딕셔너리 구조를 계속 사용하게 될 겁니다."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "딕셔너리 내용을 확인해볼까요?",
              "content": "생성된 딕셔너리의 내용이 요청과 조금 다르네요. {{ERROR_MESSAGE}} 키 이름('username', 'level', 'team')에 오타가 없는지, 그리고 각 키에 맞는 값이 정확하게 들어갔는지 확인해주세요."
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, 문법 오류!",
              "content": "딕셔너리를 만들 때 오류가 발생했어요. 딕셔너리는 `{}` 중괄호를 사용하고, 각 항목은 `'키': 값` 형태로 콜론(:)을 사용해야 해요. 각 항목 사이에는 쉼표(,)를 쓰는 것도 잊지 마세요!"
            }
          }
        },
        {
          "title": "딕셔너리 활용 및 데이터 순회",
          "syntax_key": "dict_methods",
          "filename": "profile_update.py",
          "starterCode": "user_profile = {\n    'username': 'rookie',\n    'level': 1,\n    'team': '솔루션개발팀'\n}\n\n# TODO: 1. 'user_profile' 딕셔너리에 'status' 키와 'online' 값을 추가하세요.\n\n\n# TODO: 2. for 문과 .items() 메소드를 사용하여 딕셔너리의 모든 키와 값을 출력하세요.\n# 형식: \"key: value\" (예: \"username: rookie\")\n\n",
          "testCode": "expected_dict = {'username': 'rookie', 'level': 1, 'team': '솔루션개발팀', 'status': 'online'}; assert 'user_profile' in locals() and user_profile == expected_dict, f\"'status' 키-값 쌍이 올바르게 추가되지 않았거나 딕셔너리의 내용이 다릅니다. 기대값: {expected_dict}, 실제값: {user_profile}\"",
          "task": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "프로필 정보 업데이트 및 출력",
            "content": "방금 만든 프로필 딕셔너리에 <span class='font-bold text-yellow-300'>새로운 정보('status': 'online')를 추가</span>해주세요. 그리고, 프로필에 담긴 <span class='font-bold text-yellow-300'>모든 키와 값을 하나씩 출력</span>해서 전체 프로필 정보를 보고서 형태로 보여주는 코드를 작성해주세요."
          },
          "briefing": {
            "character": "sena",
            "subtitle": "직속 선임의 팁",
            "title": "딕셔너리 서랍장 정리하기",
            "content": "딕셔너리에 새 항목을 추가하는 건 아주 쉬워요. 그냥 `my_dict['새로운 키'] = '새로운 값'`처럼 대입하면 끝이에요. 그리고 서랍장 안의 모든 물건을 꺼내보려면 <span class='font-bold text-teal-300'>`.items()`</span> 라는 메소드를 `for`문과 함께 쓰면 돼요. <span class='font-bold text-teal-300'>`for key, value in my_dict.items():`</span> 라고 하면 키와 값을 한 번에 하나씩 꺼내볼 수 있답니다."
          },
          "lecture": {
            "character": "profKim",
            "title": "강의 노트: 딕셔너리 활용",
            "keyTakeaway": "딕셔너리는 `my_dict[key] = value`로 데이터를 추가/수정하고, `.items()`와 `for`문으로 모든 데이터를 순회할 수 있습니다.",
            "sandboxCode": "scores = {\"math\": 90, \"english\": 85}\n\n# science 점수 100점을 추가해보세요.\nscores[\"science\"] = 100\nprint(scores)",
            "sections": [
              {
                "heading": "핵심 개념",
                "text": "딕셔너리는 키를 통해 값을 추가, 수정, 삭제할 수 있는 '변경 가능(mutable)'한 자료구조입니다. 또한, 반복문과 함께 사용하여 내부에 저장된 모든 데이터를 효율적으로 처리할 수 있습니다.",
                "code": null
              },
              {
                "heading": "기본 문법",
                "text": "새로운 키에 값을 할당하면 항목이 추가되고, 기존 키에 할당하면 값이 수정됩니다.",
                "code": "my_dict = {\"a\": 1}\n\n# 값 추가 및 수정\nmy_dict[\"b\"] = 2\nmy_dict[\"a\"] = 100\n\n# 값 삭제\ndel my_dict[\"b\"]\n\n# 모든 키-값 쌍 순회\nfor key, value in my_dict.items():\n    print(f\"{key}의 값은 {value}입니다.\")"
              },
              {
                "heading": "활용 사례",
                "text": "사용자의 프로필 정보를 업데이트하거나, 설정 파일의 특정 옵션 값을 변경하고, 저장된 모든 데이터를 화면에 목록 형태로 보여줄 때 사용됩니다.",
                "code": null
              },
              {
                "heading": "주의점 및 팁",
                "text": "`.items()`는 키와 값을 모두 가져옵니다. 키만 필요할 때는 `.keys()`, 값만 필요할 때는 `.values()` 메소드를 사용할 수 있습니다. `in` 연산자를 사용하면 특정 키가 딕셔너리에 있는지 확인할 수 있습니다. (예: `if 'username' in my_profile:`)",
                "code": null
              }
            ]
          },
          "feedback": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "데이터 처리 완료",
              "content": "<span class='font-bold text-green-300'>정보 추가와 전체 목록 출력이 완벽하게 동작하네요.</span> 딕셔너리를 자유자재로 다룰 수 있게 된 것 같습니다. 이 능력은 앞으로 데이터를 다루는 모든 업무의 기초가 될 겁니다. 잘했습니다."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "출력 결과가 다른데요?",
              "content": "출력된 내용이 요청과 조금 다르네요. {{ERROR_MESSAGE}} `user_profile['status'] = 'online'` 코드로 새 항목을 잘 추가했는지, 그리고 `for`문 안에서 `print(f\"{key}: {value}\")` 형식으로 잘 출력하고 있는지 확인해주세요."
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, 문법 오류!",
              "content": "코드를 실행하다가 오류가 발생했어요. `for`문 구문인 `for key, value in user_profile.items():` 에서 오타가 난 건 아닐까요? `.items()` 메소드를 호출할 때 괄호`()`를 빠뜨리는 실수도 자주 하니 확인해보세요!"
            }
          }
        },
        {
          "title": "중복 없는 데이터, 집합(Set)",
          "syntax_key": "set_data",
          "filename": "event_manager.py",
          "starterCode": "event_A = ['alex', 'sena', 'kim', 'alex']\nevent_B = ['alex', 'chris', 'sena', 'david']\n\n# TODO: 1. event_A와 event_B를 합쳐 'combined_list'를 만드세요.\ncombined_list = []\n\n# TODO: 2. 'combined_list'를 집합으로 변환하여 'unique_participants'라는 변수에 저장하세요.\nunique_participants = set()\n\n# 아래는 테스트용 코드입니다. 수정하지 마세요.\n# 결과를 보기 쉽게 리스트로 변환 후 정렬하여 출력합니다.\nif unique_participants:\n    print(sorted(list(unique_participants)))\n",
          "testCode": "assert 'unique_participants' in locals(), \"'unique_participants' 변수가 정의되지 않았습니다.\"; expected = {'alex', 'sena', 'kim', 'chris', 'david'}; assert unique_participants == expected, f\"중복 제거된 참여자 명단이 기대와 다릅니다. 기대값: {expected}, 실제값: {unique_participants}\"",
          "task": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "중복 참여자 제거",
            "content": "마케팅팀에서 이벤트 참여자 명단을 두 개(`event_A`, `event_B`) 전달했는데, 양쪽 이벤트에 모두 참여한 중복 인원이 많습니다. <span class='font-bold text-yellow-300'>두 명단에 있는 모든 참여자 중, 중복된 사람을 완벽하게 제거</span>하여 <span class='font-bold text-yellow-300'>'순수한 전체 참여자' 명단</span>을 만들어주세요."
          },
          "briefing": {
            "character": "sena",
            "subtitle": "직속 선임의 팁",
            "title": "중복 제거 전문가, 집합!",
            "content": "이거 `for`문이랑 `if`문으로 중복을 일일이 찾으려면 코드가 엄청 길어져요. 이럴 때 쓰는 비장의 무기가 <span class='font-bold text-teal-300'>'집합(Set)'</span>이에요. 집합은 마법 주머니 같아서, 어떤 데이터를 넣어도 <span class='font-bold text-teal-300'>알아서 중복을 싹 제거</span>해줘요. 리스트를 `set()` 함수로 감싸기만 하면 바로 집합으로 바꿀 수 있답니다. 정말 간단하죠?"
          },
          "lecture": {
            "character": "profKim",
            "title": "강의 노트: 집합 (Set)",
            "keyTakeaway": "집합(Set)은 `set()`으로 만들며, 데이터의 중복을 자동으로 제거하고 순서가 없는 자료구조입니다.",
            "sandboxCode": "numbers = [10, 20, 30, 20, 10]\n\n# numbers 리스트의 중복을 제거한 결과를 출력해보세요.\nunique_numbers = set(numbers)\nprint(unique_numbers)",
            "sections": [
              {
                "heading": "핵심 개념",
                "text": "집합(Set)은 두 가지 중요한 특징을 가진 자료구조입니다. 첫째, **순서가 없고**, 둘째, **중복된 값을 허용하지 않습니다.** 이 특징 덕분에 데이터의 중복을 제거하거나, 두 데이터 묶음 간의 관계(합집합, 교집합 등)를 계산할 때 매우 유용합니다.",
                "code": null
              },
              {
                "heading": "기본 문법",
                "text": "`set()` 함수를 이용해 다른 자료구조로부터 집합을 만들 수 있습니다.",
                "code": "# 리스트를 집합으로 변환하여 중복 제거\ndup_list = [1, 2, 2, 3, 3, 3]\nunique_set = set(dup_list) # {1, 2, 3}\n\n# 두 집합의 합집합\nset_a = {1, 2, 3}\nset_b = {3, 4, 5}\nunion_set = set_a | set_b # {1, 2, 3, 4, 5}"
              },
              {
                "heading": "활용 사례",
                "text": "로그 데이터에서 순수한 방문자(IP 주소) 수 계산, 설문조사 응답 항목의 종류 파악, 두 사용자 그룹의 공통 관심사 찾기 등 데이터의 유일성(uniqueness)이 중요할 때 사용됩니다.",
                "code": null
              },
              {
                "heading": "주의점 및 팁",
                "text": "집합은 순서가 없으므로, 인덱싱(`my_set[0]`)으로 항목에 접근할 수 없습니다. 빈 집합을 만들 때는 `my_set = set()`을 사용해야 합니다. `{}`는 빈 딕셔너리를 의미합니다.",
                "code": null
              }
            ]
          },
          "feedback": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "데이터 정제 완료",
              "content": "<span class='font-bold text-green-300'>중복 참여자가 완벽하게 제거되었네요.</span> 집합을 사용하니 코드가 정말 간결해졌죠? <span class='font-bold text-green-300'>상황에 맞는 최적의 자료구조를 선택</span>하는 것이 바로 실력 있는 개발자의 모습입니다. 이번 주도 수고 많았습니다."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "참여자 명단이 다른데요?",
              "content": "최종 참여자 명단이 예상과 다르네요. {{ERROR_MESSAGE}} 먼저 두 이벤트 참여자 리스트를 `+` 연산자로 하나로 합치고, 그 다음에 `set()` 함수를 사용해서 집합으로 변환했는지 순서를 확인해주세요."
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, 문법 오류!",
              "content": "코드를 실행하다가 오류가 발생했어요. 리스트를 집합으로 바꿀 때는 `set(리스트이름)`처럼 `set()` 함수를 사용해야 해요. 혹시 괄호를 빠뜨리거나 잘못 사용한 건 아닌지 확인해볼까요?"
            }
          }
        }
      ]
    },
    {
      "week": 7,
      "title": "모듈화 및 중간 점검: 나만의 유틸리티 모듈 만들기",
      "cycles": [
        {
          "title": "코드 분리의 시작, 모듈(Module)",
          "syntax_key": "modules",
          "filename": "main.py",
          "starterCode": "# --- 가상 모듈 파일: string_utils.py ---\n# 실제로는 별도 파일에 있어야 하지만, 학습 환경을 위해 여기에 정의합니다.\nclass StringUtilsModule:\n    def reverse_string(self, s):\n        return s[::-1]\nstring_utils = StringUtilsModule()\n# -------------------------------------\n\n# TODO: 1. 위 'string_utils' 객체를 실제 모듈이라고 생각하세요.\n# TODO: 2. string_utils의 reverse_string 함수를 호출하여 \"Hello\"를 뒤집고,\n#         그 결과를 'reversed_text' 변수에 저장하세요.\n\nreversed_text = \"\"\n\n# 아래는 테스트용 코드입니다. 수정하지 마세요.\nprint(reversed_text)\n",
          "testCode": "assert 'reversed_text' in locals(), \"'reversed_text' 변수가 존재하지 않습니다.\"; assert reversed_text == 'olleH', f\"문자열이 올바르게 뒤집히지 않았습니다. 기대값: 'olleH', 실제값: '{reversed_text}'\"",
          "task": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "코드 정리 및 모듈화",
            "content": "프로젝트 규모가 커지면서 하나의 파일에 모든 함수를 작성하는 것이 점점 비효율적으로 변하고 있습니다. <span class='font-bold text-yellow-300'>관련 있는 함수들을 별도의 파일로 분리하여 관리</span>하는 것이 좋습니다. 파이썬에서는 이렇게 분리된 파일을 <span class='font-bold text-yellow-300'>'모듈(Module)'</span>이라고 부릅니다. 모듈을 만들고, 다른 파일에서 그 모듈의 함수를 불러와 사용하는 방법을 익혀주세요."
          },
          "briefing": {
            "character": "sena",
            "subtitle": "직속 선임의 OJT",
            "title": "나만의 도구 상자 만들기",
            "content": "모듈은 일종의 <span class='font-bold text-teal-300'>'나만의 도구 상자'</span>를 만드는 것과 같아요. 예를 들어, 수학 계산 관련 함수들은 `math_utils.py` 파일에 모아두고, 필요할 때마다 `import math_utils` 라고 불러서 쓰는 거죠. 이렇게 하면 코드가 훨씬 깔끔해지고, 다른 프로젝트에서도 이 도구 상자를 재사용할 수 있게 된답니다. <span class='font-bold text-teal-300'>`import` 키워드</span>가 핵심이에요!"
          },
          "lecture": {
            "character": "profKim",
            "title": "강의 노트: 모듈 (Module)",
            "keyTakeaway": "모듈은 함수 등을 모아놓은 `.py` 파일이며, `import` 키워드로 불러와 재사용할 수 있습니다.",
            "sandboxCode": "# 아래는 가상의 my_utils.py 모듈입니다.\ndef say_hello(name):\n    print(f\"{name}님, 안녕하세요!\")\n\n# my_utils 모듈의 say_hello 함수를 호출해보세요.\nsay_hello(\"신입사원\")",
            "sections": [
              {
                "heading": "핵심 개념",
                "text": "모듈(Module)이란 함수, 변수, 클래스를 모아놓은 파이썬 파일(`.py`)입니다. 모듈화는 코드를 기능별로 분리하여 관리할 수 있게 해주므로, 코드의 재사용성과 유지보수성을 크게 향상시킵니다.",
                "code": null
              },
              {
                "heading": "기본 문법",
                "text": "다른 파일(모듈)에 있는 기능을 사용하려면 `import` 문을 사용해야 합니다.",
                "code": "# my_module.py 파일의 함수를 가져올 때\n\n# 방법 1: 모듈 전체를 가져오기\nimport my_module\nmy_module.my_function()\n\n# 방법 2: 모듈에서 특정 함수만 가져오기\nfrom my_module import my_function\nmy_function()"
              },
              {
                "heading": "활용 사례",
                "text": "사용자 인증 관련 함수들을 `auth.py`로, 데이터베이스 처리 함수들을 `database.py`로 분리하여 프로젝트 구조를 체계적으로 관리하는 등 모든 실제 프로젝트에서 필수적으로 사용됩니다.",
                "code": null
              },
              {
                "heading": "주의점 및 팁",
                "text": "다른 사람이 만든 유용한 모듈(라이브러리)도 `import`하여 사용할 수 있습니다. `if __name__ == '__main__':` 구문을 사용하면, 한 파일을 직접 실행할 수도 있고 다른 곳에서 모듈로 불러와 사용할 수도 있게 만들 수 있습니다.",
                "code": null
              }
            ]
          },
          "feedback": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "모듈화 성공",
              "content": "<span class='font-bold text-green-300'>모듈을 만들고 함수를 성공적으로 호출했군요.</span> 좋습니다. 이렇게 코드를 기능별로 분리하는 습관은 대규모 프로젝트를 진행할 때 반드시 필요한 역량입니다. 이제 이 개념을 바탕으로 첫 미니 프로젝트를 진행해보죠."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "결과값이 다른데요?",
              "content": "함수는 호출됐지만 결과가 예상과 다르네요. {{ERROR_MESSAGE}} `string_utils.reverse_string()`처럼 모듈(객체) 이름과 함수 이름을 점(`.`)으로 잘 연결해서 호출했는지, 그리고 함수의 인자로 `\"Hello\"`를 정확히 넘겨줬는지 확인해볼까요?"
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, Import Error!",
              "content": "모듈을 가져오는 데 실패했다는 `ImportError`가 발생했어요. `import string_utils` 처럼 `import` 키워드 뒤에 모듈 이름의 오타가 없는지 확인해주세요. 실제 상황에서는 모듈 파일이 현재 작업하는 파일과 같은 폴더에 있어야 해요."
            }
          }
        },
        {
          "title": "미니 프로젝트 설계 (파일 백업 스크립트)",
          "syntax_key": "os_time_modules",
          "filename": "design_document.txt",
          "starterCode": "# 이 파일에 백업 스크립트의 설계도를 작성해주세요.\n\n# 1. 백업할 파일/폴더 목록 (어떤 변수에 어떤 형태로 저장할까요?):\n# 예: source = ['/path/to/notes', '/path/to/code']\n\n\n# 2. 백업을 저장할 기본 폴더 (어떤 변수에 저장할까요?):\n#\n\n\n# 3. 백업 파일의 이름 규칙 (어떤 모듈과 함수를 사용해야 할까요?):\n#\n\n\n# 4. 실제 백업을 실행할 명령어 (어떤 모듈과 함수를 사용해야 할까요?):\n#\n\n",
          "testCode": "assert True, \"설계 단계는 개념을 평가합니다.\"",
          "task": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "자동 백업 스크립트 개발 프로젝트",
            "content": "첫 미니 프로젝트입니다. 우리 팀의 <span class='font-bold text-yellow-300'>중요한 파일을 지정된 폴더에 ZIP 파일로 압축하여 백업</span>하는 자동화 스크립트를 만들어야 합니다. 핵심 요구사항은 <span class='font-bold text-yellow-300'>백업 파일의 이름이 실행 시점의 날짜와 시간으로 자동 생성</span>되어야 한다는 것입니다."
          },
          "briefing": {
            "character": "sena",
            "subtitle": "직속 선임의 팁",
            "title": "코딩 전에 계획부터!",
            "content": "백업 스크립트! 아주 실용적인 과제네요. 코딩부터 시작하기 전에 계획을 세워보는 게 좋아요. 1) 어떤 파일을 백업할지 정하고, 2) 어디에 저장할지 정하고, 3) 날짜와 시간으로 파일 이름을 어떻게 만들지 고민하고, 4) 마지막으로 어떻게 ZIP 압축 명령을 실행할지. 아마 <span class='font-bold text-teal-300'>`os` 모듈과 `time` 모듈</span>이 큰 도움이 될 거예요."
          },
          "lecture": {
            "character": "profKim",
            "title": "강의 노트: 소프트웨어 개발 단계",
            "keyTakeaway": "문제를 해결하기 전에, 먼저 필요한 기능들을 단계별로 나누어 '설계'하는 습관이 중요합니다.",
            "sandboxCode": "import time\n\n# 현재 시간을 '년월일시분초' 형태의 문자열로 출력해보세요.\n# 예: 20251001113059\nprint(time.strftime('%Y%m%d%H%M%S'))",
            "sections": [
              {
                "heading": "핵심 개념",
                "text": "훌륭한 프로그램은 무작정 코드를 짜는 것이 아니라, 체계적인 단계를 거쳐 만들어집니다. '무엇을 만들까(분석)' → '어떻게 만들까(설계)' → '코드로 구현' → '오류 수정(테스트/디버깅)'의 과정을 거치는 것이 중요합니다.",
                "code": null
              },
              {
                "heading": "유용한 도구 (모듈)",
                "text": "파일 경로를 다루거나 시스템 명령어를 실행할 때는 `os` 모듈, 시간 정보를 다룰 때는 `time` 모듈이 필수적입니다.",
                "code": "# 운영체제(Operating System) 기능 사용\nimport os\n# 폴더가 없으면 만들기: os.mkdir('new_folder')\n# 시스템 명령어 실행: os.system('zip ...')\n\n# 시간 관련 기능 사용\nimport time\n# 현재 시간을 형식에 맞춰 문자열로: time.strftime('%Y%m%d%H%M%S')"
              },
              {
                "heading": "활용 사례",
                "text": "지금 만들려는 '파일 백업 스크립트' 자체가 모든 개념을 종합적으로 활용하는 훌륭한 사례입니다.",
                "code": null
              },
              {
                "heading": "주의점 및 팁",
                "text": "운영체제마다 파일 경로 구분자가 다를 수 있습니다. Windows는 `\\`, macOS/Linux는 `/`를 사용하죠. `os.sep` 변수를 사용하면 운영체제에 맞는 구분자를 자동으로 사용해줘서 편리합니다.",
                "code": null
              }
            ]
          },
          "feedback": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "프로젝트 설계 승인",
              "content": "<span class='font-bold text-green-300'>훌륭한 설계입니다.</span> 문제 해결에 필요한 절차와 사용할 도구를 정확히 파악했군요. 이 설계안대로라면 충분히 좋은 결과물이 나올 것 같습니다. 이제 계획에 따라 구현을 시작해주세요."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "설계 검토",
              "title": "조금만 더 구체적으로!",
              "content": "좋은 시작이에요! 하지만 {{ERROR_MESSAGE}} 파트가 조금 막연하네요. 예를 들어 '날짜와 시간으로 파일 이름 만들기' 부분에 구체적으로 `time.strftime` 함수를 사용하겠다고 적어주면 설계가 더 명확해질 거예요."
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "설계 검토",
              "title": "다시 한번 생각해볼까요?",
              "content": "이 단계는 코딩이 아니라 설계 문서를 작성하는 단계예요. 오류가 발생할 리 없는데... 혹시 코드 대신 설계 계획을 잘 작성해주셨는지 다시 확인해볼까요?"
            }
          }
        },
        {
          "title": "미니 프로젝트 구현 (종합 실습)",
          "syntax_key": "project_integration",
          "filename": "backup.py",
          "starterCode": "import os\nimport time\n\n# 1. 백업할 파일 및 디렉토리 목록을 리스트로 만드세요.\nsource = ['/Users/swa/notes'] # TODO: 실제 자신의 PC에 있는 폴더 경로로 바꿔보세요.\n\n# 2. 백업을 저장할 디렉토리를 문자열 변수로 만드세요.\ntarget_dir = '/Users/swa/backup' # TODO: 백업 파일을 저장할 폴더 경로로 바꿔보세요.\n\n# 3. 백업 파일명 생성 (날짜와 시간 이용)\ntarget = target_dir + os.sep + time.strftime('%Y%m%d%H%M%S') + '.zip'\n\n# 4. 백업 디렉토리 생성 (없는 경우)\nif not os.path.exists(target_dir):\n    os.mkdir(target_dir)\n\n# 5. zip 명령어 생성\n# TODO: zip_command 변수에 실행할 zip 명령어를 f-string을 이용해 만드세요.\n# 명령어 형식: f\"zip -r {target} {' '.join(source)}\"\nzip_command = \"\"\n\n# 6. 백업 실행 및 결과 출력\nprint(f\"Zip command is: {zip_command}\")\nprint(\"Running backup...\")\nif os.system(zip_command) == 0:\n    print('Successful backup to', target)\nelse:\n    print('Backup FAILED')\n",
          "testCode": "import os; source_str = ' '.join(source); expected_command = f\"zip -r {target} {source_str}\"; assert 'zip_command' in locals(), \"'zip_command' 변수가 선언되지 않았습니다.\"; assert zip_command == expected_command, f\"zip_command 문자열이 올바르지 않습니다. 기대값: '{expected_command}', 실제값: '{zip_command}'\"; assert target.startswith(target_dir), \"target 파일 경로가 target_dir로 시작해야 합니다.\"; assert target.endswith('.zip'), \"target 파일명이 .zip으로 끝나야 합니다.\"",
          "task": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "백업 스크립트 구현",
            "content": "방금 승인된 설계안에 따라, <span class='font-bold text-yellow-300'>실제로 동작하는 백업 스크립트의 첫 번째 버전</span>을 완성해주세요. 지금까지 배운 변수, 리스트, 문자열, 그리고 `os`와 `time` 모듈에 대한 지식을 모두 활용해야 합니다."
          },
          "briefing": {
            "character": "sena",
            "subtitle": "직속 선임의 팁",
            "title": "차근차근, 그리고 확인하면서",
            "content": "이제 진짜 만드는 시간이네요! 한 가지 팁을 드리자면, 최종 `zip` 명령어를 문자열로 만든 다음에, <span class='font-bold text-teal-300'>`os.system()`으로 바로 실행하기 전에 먼저 `print()`로 출력</span>해보세요. 내가 만든 명령어가 오타 없이 올바른지 눈으로 먼저 확인하는 거죠. 버그를 잡는 아주 좋은 습관이랍니다!"
          },
          "lecture": {
            "character": "profKim",
            "title": "교수님의 조언: 통합적 사고",
            "keyTakeaway": "훌륭한 개발자는 많은 것을 아는 사람이 아니라, 아는 것을 잘 연결하여 문제를 해결하는 사람입니다.",
            "sandboxCode": null,
            "sections": [
              {
                "heading": "핵심 조언",
                "text": "이번 사이클은 새로운 지식을 배우기보다, 이미 배운 여러 지식을 '연결'하고 '조합'하는 능력을 기르는 데 중점을 둡니다. 막힐 때마다 대시보드의 '지식 노트'와 '문법 인덱스'를 적극적으로 활용하여 필요한 도구를 찾아내고, 그것들을 어떻게 엮어야 문제를 해결할 수 있을지 고민해보세요. 이 과정 자체가 훌륭한 학습입니다.",
                "code": null
              }
            ]
          },
          "feedback": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "첫 프로젝트 성공!",
              "content": "정말 대단합니다. 스크립트가 완벽하게 동작하여 <span class='font-bold text-green-300'>날짜와 시간이 포함된 백업 ZIP 파일을 성공적으로 생성</span>했네요. <span class='font-bold text-green-300'>지난 7주간 배운 개념들을 통합하여 실제 문제를 해결</span>해냈습니다. 이것은 OOO님의 성장에 있어 매우 중요한 이정표입니다. 진심으로 축하합니다."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "디버깅 지원",
              "title": "명령어가 조금 이상해요",
              "content": "백업 실행에 실패했네요. {{ERROR_MESSAGE}} 생성된 `zip_command`를 보니 뭔가 잘못된 것 같아요. `target` 경로와 `source` 경로가 올바르게 들어갔는지, f-string 문법은 맞는지 다시 확인해볼까요?"
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "디버깅 지원",
              "title": "앗, 코드 실행 오류!",
              "content": "백업을 실행하기도 전에 코드에서 오류가 발생했어요. `time.strftime`이나 `os.path.exists` 같은 함수를 호출할 때 오타가 있진 않았나요? 아니면 문자열을 합칠 때 `+` 연산자를 잘못 썼을 수도 있고요. 오류 메시지를 자세히 읽어보면 힌트를 얻을 수 있을 거예요."
            }
          }
        }
      ]
    },
    {
      "week": 8,
      "title": "객체 지향 프로그래밍 (1): 클래스와 객체의 이해",
      "cycles": [
        {
          "title": "왜 객체 지향인가? (클래스와 객체 개념)",
          "syntax_key": "oop_concept",
          "filename": "user_model.py",
          "starterCode": "# TODO: 1. 'User'라는 이름의 비어있는 클래스를 정의하세요.\n# 클래스 내부는 pass 키워드를 사용하여 비워두세요.\n\n\n# TODO: 2. 'User' 클래스의 인스턴스(객체)를 만들어 'user1'이라는 변수에 저장하세요.\n\n\n# 아래는 테스트용 코드입니다.\nprint(user1)\n",
          "testCode": "assert 'User' in locals(), \"'User' 클래스가 정의되지 않았습니다.\"; assert 'user1' in locals(), \"'user1' 변수가 존재하지 않았습니다.\"; assert isinstance(user1, User), \"'user1' 변수는 User 클래스의 객체여야 합니다.\"",
          "task": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "데이터 관리 방식 개선",
            "content": "지금까지 사용자 데이터를 `user_id`, `user_email`처럼 여러 변수에 흩어서 관리했는데, 사용자가 많아지니 코드가 복잡해지고 있습니다. <span class='font-bold text-yellow-300'>한 사용자에 대한 모든 데이터와 관련 기능을 하나의 덩어리로 묶어서 관리</span>할 필요가 있습니다. 이것이 바로 '객체 지향 프로그래밍'의 시작입니다."
          },
          "briefing": {
            "character": "sena",
            "subtitle": "직속 선임의 OJT",
            "title": "설계도와 제품",
            "content": "객체 지향, 말이 좀 어렵죠? 쉽게 생각해서, '의자'를 만든다고 해봐요. 먼저 의자를 어떻게 만들지 정한 <span class='font-bold text-teal-300'>'설계도'가 바로 '클래스(Class)'</span>이고, 그 설계도로 실제 만들어낸 <span class='font-bold text-teal-300'>'의자' 하나하나가 '객체(Object)'</span>예요. 각 의자 객체는 색상, 재질 같은 자기만의 데이터를 가지죠. 이런 식으로 데이터를 관리하면 훨씬 깔끔해져요."
          },
          "lecture": {
            "character": "profKim",
            "title": "강의 노트: 클래스와 객체",
            "keyTakeaway": "클래스는 '설계도', 객체는 그 설계도로 만든 '실제 제품'입니다.",
            "sandboxCode": "class Car:\n    pass\n\n# Car 클래스로부터 my_car 라는 객체를 만들어보세요.\nmy_car = Car()\nprint(my_car)",
            "sections": [
              {
                "heading": "핵심 개념",
                "text": "객체 지향 프로그래밍(OOP)은 연관 있는 데이터(속성)와 그 데이터를 처리하는 기능(메소드)을 하나로 묶어 '객체' 단위로 관리하는 기법입니다. '클래스(Class)'는 객체를 만들기 위한 설계도이며, '객체(Object)'는 그 설계도를 바탕으로 실제로 만들어진 실체(인스턴스)입니다.",
                "code": null
              },
              {
                "heading": "기본 문법",
                "text": "`class` 키워드로 클래스를 정의하고, 클래스 이름에 괄호`()`를 붙여 객체를 생성합니다.",
                "code": "# Person 이라는 이름의 클래스(설계도) 정의\nclass Person:\n    pass\n\n# Person 클래스로부터 p1 이라는 객체(실체) 생성\np1 = Person()"
              },
              {
                "heading": "활용 사례",
                "text": "'사용자', '게시물', '자동차' 등 현실 세계의 대상을 모델링하거나, 데이터와 기능이 밀접하게 연관된 복잡한 시스템을 논리적인 단위로 나누어 관리할 때 사용됩니다.",
                "code": null
              },
              {
                "heading": "주의점 및 팁",
                "text": "클래스는 설계도일 뿐이며, 실제로 메모리 공간을 차지하고 데이터를 담는 것은 객체입니다. 하나의 클래스로부터 수많은 객체를 만들어낼 수 있습니다.",
                "code": null
              }
            ]
          },
          "feedback": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "개념 이해 완료",
              "content": "<span class='font-bold text-green-300'>좋습니다. 클래스와 객체의 기본 개념</span>을 이해했군요. 데이터를 '객체'라는 단위로 생각하기 시작하면, 훨씬 더 체계적으로 프로그램을 설계할 수 있습니다. 이제 이 설계도를 구체화해봅시다."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "클래스와 객체를 확인해볼까요?",
              "content": "음, 테스트를 통과하지 못했어요. {{ERROR_MESSAGE}} 'User'라는 이름으로 클래스를 정확히 만드셨나요? 그리고 `user1 = User()` 코드를 통해 User 클래스로부터 객체를 만들어서 `user1` 변수에 저장했는지 확인해주세요."
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, 문법 오류!",
              "content": "클래스를 만들 때 문법 오류가 발생했어요. 클래스는 `class 이름:` 형식으로 만들어야 해요. `class` 키워드를 빠뜨리거나 이름 뒤에 콜론(`:`)을 잊으신 건 아닐까요?"
            }
          }
        },
        {
          "title": "객체의 설계도, 클래스 정의하기 (`__init__`)",
          "syntax_key": "class_init",
          "filename": "user_model.py",
          "starterCode": "class User:\n    # TODO: __init__ 메소드를 정의하세요.\n    # 이 메소드는 self 외에 username과 email 두 개의 매개변수를 받아야 합니다.\n    # 받은 username과 email을 각각 self.username과 self.email에 저장하세요.\n    pass\n\n# 아래는 테스트용 코드입니다.\nuser1 = User(\"alex_team\", \"alex@logicore.tech\")\nprint(f\"Username: {user1.username}, Email: {user1.email}\")\n",
          "testCode": "assert 'User' in locals() and hasattr(User, '__init__'), \"User 클래스에 __init__ 메소드가 정의되지 않았습니다.\"; test_user = None; try: test_user = User(\"test_user\", \"test@email.com\") except TypeError: assert False, \"__init__ 메소드가 username과 email 매개변수를 제대로 받고 있는지 확인해주세요.\"; assert hasattr(test_user, 'username') and test_user.username == \"test_user\", \"username 속성이 올바르게 저장되지 않았습니다.\"; assert hasattr(test_user, 'email') and test_user.email == \"test@email.com\", \"email 속성이 올바르게 저장되지 않았습니다.\"",
          "task": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "User 클래스 구체화",
            "content": "이제 `User` 클래스를 구체적으로 설계해봅시다. 모든 User 객체는 <span class='font-bold text-yellow-300'>생성되는 순간 반드시 `username`과 `email` 정보</span>를 가져야 합니다. 객체가 처음 만들어질 때 이 초기 값들을 설정해주는 <span class='font-bold text-yellow-300'>'초기화 메소드'</span>를 클래스에 추가해주세요."
          },
          "briefing": {
            "character": "sena",
            "subtitle": "직속 선임의 팁",
            "title": "객체의 공장 초기 설정, `__init__`",
            "content": "클래스에는 <span class='font-bold text-teal-300'>`__init__`</span>이라는 아주 특별한 메소드가 있어요. 밑줄 두 개씩! 이건 객체가 생성될 때 딱 한 번, 자동으로 실행되는 '공장 초기 설정' 같은 거예요. 여기에 `username`과 `email`을 매개변수로 받고, <span class='font-bold text-teal-300'>`self`</span>라는 키워드를 써서 '객체 자기 자신'에게 데이터를 저장해주면 된답니다."
          },
          "lecture": {
            "character": "profKim",
            "title": "강의 노트: __init__ 메소드와 self",
            "keyTakeaway": "`__init__`은 객체 생성 시 호출되는 초기 설정 함수이며, `self`를 통해 객체에 데이터를 저장합니다.",
            "sandboxCode": "class Book:\n    def __init__(self, title, author):\n        self.title = title\n        self.author = author\n\n# 'A Byte of Python'이라는 제목의 책 객체를 만들어보세요.\nmy_book = Book(\"A Byte of Python\", \"Swaroop CH\")\nprint(my_book.title)",
            "sections": [
              {
                "heading": "핵심 개념",
                "text": "`__init__` 메소드는 클래스로부터 객체가 생성(인스턴스화)될 때 자동으로 호출되는 초기화(initializer) 메소드입니다. `self`는 생성되는 객체 자기 자신을 가리키는 특별한 매개변수이며, `self.변수명 = 값` 형태로 객체에 데이터를 저장할 수 있습니다. 이렇게 저장된 변수를 '속성(attribute)'이라고 합니다.",
                "code": null
              },
              {
                "heading": "기본 문법",
                "text": "메소드 이름 앞뒤로 밑줄 두 개(`__`)를 사용하며, 첫 매개변수는 항상 `self`여야 합니다.",
                "code": "class User:\n    # 객체가 생성될 때 username을 받아 self.name에 저장\n    def __init__(self, username):\n        self.name = username\n\n# 객체 생성 시, __init__ 메소드에 인자 전달\nuser1 = User(\"Alex\")"
              },
              {
                "heading": "활용 사례",
                "text": "객체가 생성될 때 반드시 필요한 초기 데이터(예: 사용자의 ID, 캐릭터의 체력)를 설정하여, 데이터 누락 없이 안정적인 객체를 만들 수 있습니다.",
                "code": null
              },
              {
                "heading": "주의점 및 팁",
                "text": "메소드 이름은 밑줄 두 개(`__`)로 시작하고 끝나야 합니다. `self`는 모든 메소드의 첫 번째 매개변수로 항상 포함되어야 하며, 파이썬이 자동으로 값을 전달해줍니다.",
                "code": null
              }
            ]
          },
          "feedback": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "견고한 설계도 완성",
              "content": "완벽합니다. 이제 우리가 만드는 모든 `User` 객체는 <span class='font-bold text-green-300'>누락 없이 `username`과 `email`을 갖게 되었네요.</span> 이렇게 객체의 필수 요소를 `__init__`에서 정의하는 것은 매우 안정적이고 좋은 설계 방식입니다."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "속성이 제대로 저장되지 않았어요",
              "content": "객체는 만들어졌는데, 속성이 제대로 저장되지 않은 것 같아요. {{ERROR_MESSAGE}} `__init__` 메소드 안에서 `self.username = username` 처럼 `self.`를 사용해서 속성을 저장했는지 확인해주세요. `self`가 빠지면 객체에 저장되지 않아요."
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, __init__ 문법 오류!",
              "content": "`__init__` 메소드를 정의할 때 오류가 발생했어요. `def __init__(self, username, email):` 처럼 이름 앞뒤에 밑줄이 두 개씩 있는지, 첫 번째 매개변수로 `self`가 있는지, 마지막에 콜론(`:`)이 있는지 꼼꼼하게 확인해주세요."
            }
          }
        },
        {
          "title": "객체의 행동, 메소드 추가하기",
          "syntax_key": "class_methods",
          "filename": "user_model.py",
          "starterCode": "class User:\n    def __init__(self, username, email):\n        self.username = username\n        self.email = email\n\n    # TODO: 'introduce' 메소드를 추가하세요.\n    # 이 메소드는 \"안녕하세요, 제 이름은 [username]입니다.\" 형식의 문자열을 반환(return)해야 합니다.\n    \n\n# 아래는 테스트용 코드입니다. 수정하지 마세요.\nuser1 = User(\"sena_dev\", \"sena@logicore.tech\")\nmessage = user1.introduce()\nprint(message)\n",
          "testCode": "assert 'User' in locals() and hasattr(User, 'introduce') and callable(User.introduce), \"User 클래스에 'introduce' 메소드가 정의되지 않았습니다.\"; test_user = User(\"Sena\", \"sena@logicore.tech\"); result = test_user.introduce(); expected = \"안녕하세요, 제 이름은 Sena입니다.\"; assert result == expected, f\"introduce 메소드의 반환값이 다릅니다. 기대값: '{expected}', 실제값: '{result}'\"",
          "task": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "객체에 기능 부여하기",
            "content": "이제 데이터뿐만 아니라, 객체에 '행동'을 부여해봅시다. `User` 클래스에 `introduce`라는 이름의 <span class='font-bold text-yellow-300'>'메소드(Method)'</span>를 추가해주세요. 이 메소드를 호출하면, <span class='font-bold text-yellow-300'>객체가 가진 자신의 `username` 정보를 이용</span>하여 \"안녕하세요, 제 이름은 OOO입니다.\"와 같이 자기를 소개하는 문장을 <span class='font-bold text-yellow-300'>반환(return)</span>해야 합니다."
          },
          "briefing": {
            "character": "sena",
            "subtitle": "직속 선임의 팁",
            "title": "객체가 스스로 일하게 만들기",
            "content": "<span class='font-bold text-teal-300'>메소드는 클래스 안에 사는 함수</span>라고 생각하면 돼요. 가장 멋진 점은, 메소드 안에서는 `self`를 통해 <span class='font-bold text-teal-300'>객체 자기 자신의 데이터에 언제든 접근</span>할 수 있다는 거예요. `introduce` 메소드 안에서 `self.username` 이라고 쓰면, 그 객체가 가진 `username` 값을 바로 가져다 쓸 수 있죠. 객체가 스스로 일하게 만드는 거예요!"
          },
          "lecture": {
            "character": "profKim",
            "title": "강의 노트: 메소드 (Method)",
            "keyTakeaway": "메소드는 클래스에 소속된 함수이며, `self`를 통해 객체의 데이터를 활용하여 행동을 정의합니다.",
            "sandboxCode": "class Counter:\n    def __init__(self):\n        self.count = 0\n    \n    def click(self):\n        self.count = self.count + 1\n\n# 카운터 객체를 만들고, click 메소드를 3번 호출한 뒤\n# count 속성을 출력해보세요.\nc = Counter()\nc.click()\nc.click()\nc.click()\nprint(c.count)",
            "sections": [
              {
                "heading": "핵심 개념",
                "text": "메소드(Method)는 클래스 안에 정의된 함수이며, 해당 클래스의 객체가 수행할 수 있는 '행동'을 정의합니다. 메소드는 `self` 매개변수를 통해 객체의 속성(데이터)에 접근하고 조작할 수 있습니다.",
                "code": null
              },
              {
                "heading": "기본 문법",
                "text": "클래스 내부에 `def`를 사용하여 정의하며, 첫 매개변수는 항상 `self`여야 합니다.",
                "code": "class User:\n    def __init__(self, name):\n        self.name = name\n\n    # 메소드 정의 (첫 매개변수는 항상 self)\n    def say_hello(self):\n        print(f\"Hello, {self.name}!\")\n\n# 객체 생성 및 메소드 호출\nuser1 = User(\"Sena\")\nuser1.say_hello() # \"Hello, Sena!\" 출력"
              },
              {
                "heading": "활용 사례",
                "text": "`Car` 객체의 `drive()` 메소드, `User` 객체의 `change_password()` 메소드처럼, 해당 객체의 데이터를 사용하여 특정 동작을 수행해야 할 때 사용됩니다.",
                "code": null
              },
              {
                "heading": "주의점 및 팁",
                "text": "클래스 안에 정의되는 모든 함수, 즉 메소드는 첫 번째 매개변수로 `self`를 반드시 포함해야 합니다.",
                "code": null
              }
            ]
          },
          "feedback": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "객체 지향의 완성",
              "content": "<span class='font-bold text-green-300'>완벽합니다. 객체가 스스로의 데이터를 이용해 멋지게 자기소개를 하는군요.</span> 이로써 OOO님은 데이터(속성)와 기능(메소드)을 하나로 묶은, 완전한 '객체'를 만드는 데 성공했습니다. 이것이 바로 객체 지향 프로그래밍의 핵심입니다. 수고 많았습니다."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "반환값을 확인해볼까요?",
              "content": "메소드가 반환한 자기소개 메시지가 요청과 조금 다르네요. {{ERROR_MESSAGE}} 메소드 안에서 `self.username`을 사용해서 객체의 이름 속성에 접근했는지, 그리고 `return` 키워드를 사용해 최종 문자열을 반환했는지 확인해주세요."
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, 메소드 정의 오류!",
              "content": "`introduce` 메소드를 정의할 때 오류가 발생했어요. `def introduce(self):` 처럼 `self`를 첫 번째 매개변수로 꼭 넣어줘야 해요. `self`를 빼먹으면 '메소드는 최소 1개의 인자를 받아야 합니다' 같은 오류가 발생한답니다."
            }
          }
        }
      ]
    },

    {
      "week": 9,
      "title": "객체 지향 프로그래밍 (2): 상속을 통한 코드 확장",
      "cycles": [
        {
          "title": "코드 재사용의 꽃, 상속(Inheritance)",
          "syntax_key": "oop_inheritance",
          "filename": "admin_model.py",
          "starterCode": "class User:\n    def __init__(self, username, email):\n        self.username = username\n        self.email = email\n        # print(f\"(Initialized User: {self.username})\")\n\n# TODO: User 클래스를 상속받는 Admin 클래스를 정의하세요.\n# 1. 클래스 선언 시 User를 상속받도록 괄호 안에 명시하세요.\n# 2. __init__ 메소드에서 username, email, admin_level 세 개의 인자를 받으세요.\n# 3. 부모 클래스(User)의 __init__ 메소드를 호출하여 username과 email을 초기화하세요.\n# 4. self.admin_level 속성에 admin_level 값을 저장하세요.\n\n\n# 아래는 테스트용 코드입니다. 수정하지 마세요.\nadmin1 = Admin(\"super_admin\", \"admin@logicore.tech\", 1)\nprint(f\"Username: {admin1.username}, Email: {admin1.email}, Level: {admin1.admin_level}\")\n",

          "testCode": "assert 'Admin' in locals(), 'Admin 클래스가 정의되지 않았습니다.'; assert issubclass(Admin, User), 'Admin 클래스는 User 클래스를 상속받아야 합니다.'; test_admin = None; try: test_admin = Admin('test', 'test@test.com', 2) except Exception as e: assert False, f'Admin 객체 생성에 실패했습니다: {e}'; assert test_admin.username == 'test', '부모 클래스의 __init__이 호출되지 않아 username이 설정되지 않았습니다.'; assert hasattr(test_admin, 'admin_level') and test_admin.admin_level == 2, 'admin_level 속성이 올바르게 설정되지 않았습니다.'",
          "task": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "관리자(Admin) 타입 추가",
            "content": "서비스에 특별 권한을 가진 '관리자'가 필요하게 되었습니다. 관리자도 이름과 이메일을 가진 '사용자'의 일종이지만, 추가로 <span class='font-bold text-yellow-300'>'관리 등급(admin_level)'</span>이라는 속성을 가져야 합니다. 기존 `User` 클래스의 코드를 복사하지 말고, <span class='font-bold text-yellow-300'>'상속(Inheritance)'</span>을 사용하여 `User`의 모든 기능을 물려받는 `Admin` 클래스를 만들어주세요."
          },
          "briefing": {
            "character": "sena",
            "subtitle": "직속 선임의 OJT",
            "title": "기본 모델과 디럭스 모델",
            "content": "상속은 '기본 모델' 자동차를 기반으로 '디럭스 모델'을 만드는 것과 같아요. 디럭스 모델은 기본 모델의 모든 기능(엔진, 바퀴)을 그대로 물려받고, 거기에 터보차저 같은 새로운 기능만 추가하죠. <span class='font-bold text-teal-300'>`User`라는 부모 클래스를 만들고, `Admin`이라는 자식 클래스가 그걸 상속</span>받으면, `Admin`은 `User`의 모든 기능을 공짜로 얻는 셈이에요. 코드 재사용의 끝판왕이죠!"
          },
          "lecture": {
            "character": "profKim",
            "title": "강의 노트: 상속 (Inheritance)",
            "keyTakeaway": "상속은 `class 자식(부모):` 형태로, 부모 클래스의 모든 것을 물려받아 코드를 재사용하고 확장하는 기법입니다.",
            "sandboxCode": "class Animal:\n    def __init__(self, name):\n        self.name = name\n    def speak(self):\n        print(\"...\")\n\n# Animal 클래스를 상속받는 Dog 클래스를 만들어보세요.\nclass Dog(Animal):\n    def speak(self):\n        print(\"멍멍!\")\n\nmy_dog = Dog(\"해피\")\nprint(my_dog.name)\nmy_dog.speak()",
            "sections": [
              {
                "heading": "핵심 개념",
                "text": "상속(Inheritance)은 기존 클래스(부모 클래스)의 모든 속성과 메소드를 물려받아 새로운 클래스(자식 클래스)를 만드는 것입니다. 이를 통해 코드의 중복을 피하고, 클래스 간의 논리적인 계층 구조를 만들 수 있습니다. (예: '관리자'는 '사용자'의 한 종류이다.)",
                "code": null
              },
              {
                "heading": "기본 문법",
                "text": "클래스를 정의할 때 소괄호 `()` 안에 부모 클래스의 이름을 넣습니다.",
                "code": "# 부모 클래스를 괄호 안에 넣어 상속\nclass Admin(User):\n    def __init__(self, username, email, level):\n        # 부모 클래스의 __init__을 명시적으로 호출해야 함\n        User.__init__(self, username, email)\n        # 자식 클래스만의 속성 추가\n        self.admin_level = level"
              },
              {
                "heading": "활용 사례",
                "text": "현실 세계의 계층 구조를 모델링할 때 매우 유용합니다. 예를 들어 `동물` > `포유류` > `개` 와 같은 관계를 코드로 표현할 수 있습니다.",
                "code": null
              },
              {
                "heading": "주의점 및 팁",
                "text": "자식 클래스의 `__init__` 메소드에서는, 부모 클래스의 `__init__` 메소드를 명시적으로 호출하여 부모 클래스의 초기화 과정을 수행해줘야 합니다. 파이썬은 이 과정을 자동으로 처리해주지 않습니다.",
                "code": null
              }
            ]
          },
          "feedback": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "효율적인 클래스 확장",
              "content": "<span class='font-bold text-green-300'>코드 중복 없이 `Admin` 클래스를 깔끔하게 만들어냈군요.</span> 상속의 개념을 정확히 이해했습니다. 이제 우리는 `User` 클래스만 개선해도 `Admin` 클래스에 그 기능이 자동으로 반영되는, 매우 효율적인 구조를 갖게 되었습니다."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "초기화가 제대로 안 됐어요",
              "content": "Admin 객체의 속성이 제대로 설정되지 않았네요. {{ERROR_MESSAGE}} `Admin` 클래스의 `__init__` 메소드 안에서 `User.__init__(self, username, email)` 코드를 호출해서 부모 클래스의 초기화 부분을 실행했는지 확인해주세요. 이 부분을 빠뜨리면 `username` 같은 속성이 만들어지지 않아요."
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, 상속 문법 오류!",
              "content": "클래스를 정의하는 부분에서 오류가 발생했어요. 상속을 받으려면 `class Admin(User):` 처럼 클래스 이름 뒤 괄호 안에 부모 클래스 이름을 넣어줘야 해요. 괄호를 빠뜨리진 않았나요? `__init__` 메소드 정의도 다시 한번 확인해주세요."
            }
          }
        },
        {
          "title": "기능 재정의와 다형성",
          "syntax_key": "oop_poly",
          "filename": "admin_model.py",
          "starterCode": "class User:\n    def __init__(self, username, email):\n        self.username = username\n        self.email = email\n    def introduce(self):\n        return f\"안녕하세요, 제 이름은 {self.username}입니다.\"\n\nclass Admin(User):\n    def __init__(self, username, email, admin_level):\n        User.__init__(self, username, email)\n        self.admin_level = admin_level\n\n    # TODO: introduce 메소드를 오버라이딩(재정의)하세요.\n    # \"관리자 [username]입니다. 관리 등급은 [admin_level]입니다.\" 형식의 문자열을 반환(return)해야 합니다.\n    \n\n# 아래는 테스트용 코드입니다. 수정하지 마세요.\nuser1 = User(\"sena_dev\", \"sena@logicore.tech\")\nadmin1 = Admin(\"super_admin\", \"admin@logicore.tech\", 1)\n\nprint(user1.introduce())\nprint(admin1.introduce())\n",
          "testCode": "assert hasattr(Admin, 'introduce') and callable(Admin.introduce), \"Admin 클래스에 'introduce' 메소드가 정의되지 않았습니다.\"; test_admin = Admin('super_admin', 'admin@logicore.tech', 1); result = test_admin.introduce(); expected = '관리자 super_admin입니다. 관리 등급은 1입니다.'; assert result == expected, f\"Admin의 introduce 메소드 반환값이 다릅니다. 기대값: '{expected}', 실제값: '{result}'\"",
          "task": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "관리자 전용 기능 구현",
            "content": "`User` 클래스의 `introduce` 메소드는 일반 사용자에게 적합합니다. `Admin` 객체가 `introduce` 메소드를 호출할 때는 <span class='font-bold text-yellow-300'>\"관리자 OOO입니다. 관리 등급은 X입니다.\"</span> 와 같이 자신만의 특별한 방식으로 소개하도록 `Admin` 클래스의 메소드를 수정해주세요. 같은 이름의 메소드가 다르게 동작하게 만드는 것입니다."
          },
          "briefing": {
            "character": "sena",
            "subtitle": "직속 선임의 팁",
            "title": "같은 이름, 다른 행동",
            "content": "이건 <span class='font-bold text-teal-300'>'메소드 오버라이딩(Method Overriding)'</span>이라고 불러요. 부모한테 물려받은 기능을 자식 클래스에서 자기 입맛에 맞게 재정의하는 거죠. 그냥 `Admin` 클래스 안에 `introduce` 메소드를 똑같은 이름으로 새로 만들기만 하면 돼요. 그러면 `Admin` 객체는 부모의 메소드 대신 자기 자신의 것을 사용하게 된답니다."
          },
          "lecture": {
            "character": "profKim",
            "title": "강의 노트: 메소드 오버라이딩과 다형성",
            "keyTakeaway": "오버라이딩은 부모의 메소드를 자식이 재정의하는 것이며, 이를 통해 같은 이름의 메소드가 객체에 따라 다르게 동작(다형성)하게 만들 수 있습니다.",
            "sandboxCode": "class Parent:\n    def greet(self):\n        print(\"부모의 인사\")\n\nclass Child(Parent):\n    # greet 메소드를 오버라이딩 해보세요.\n    def greet(self):\n        print(\"자식의 인사\")\n\nc = Child()\nc.greet() # 무엇이 출력될까요?",
            "sections": [
              {
                "heading": "핵심 개념",
                "text": "메소드 오버라이딩은 자식 클래스가 부모 클래스로부터 물려받은 메소드를 자신만의 내용으로 새로 정의하는 것입니다. 다형성(Polymorphism)은 이렇게 서로 다른 클래스(User, Admin)의 객체들이 같은 이름의 메소드(`introduce`)를 호출해도, 각자의 클래스에 맞게 서로 다른 행동을 하는 특징을 말합니다.",
                "code": null
              },
              {
                "heading": "기본 문법",
                "text": "자식 클래스에서 부모와 똑같은 이름의 메소드를 다시 정의하면 됩니다.",
                "code": "class Admin(User):\n    # ... __init__ ...\n\n    # introduce 메소드를 새로 정의 (오버라이딩)\n    def introduce(self):\n        print(f\"관리 등급은 {self.admin_level}입니다.\")"
              },
              {
                "heading": "활용 사례",
                "text": "게임에서 모든 캐릭터는 `attack()` 메소드를 가지지만, 전사는 칼로, 마법사는 마법으로 공격하는 것처럼, 같은 명령에 대해 객체마다 다른 동작을 구현할 때 사용됩니다.",
                "code": null
              },
              {
                "heading": "주의점 및 팁",
                "text": "메소드를 오버라이딩할 때는, 부모 클래스의 메소드 이름 및 매개변수 개수를 동일하게 유지하는 것이 일반적입니다.",
                "code": null
              }
            ]
          },
          "feedback": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "유연한 구조 완성",
              "content": "<span class='font-bold text-green-300'>훌륭합니다. 이제 `Admin` 객체는 자신에게 맞는 소개를 하는군요.</span> 이렇게 다형성을 활용하면, 나중에 사용자 목록에 일반 유저와 관리자가 섞여 있어도 똑같이 `introduce` 메소드를 호출하기만 하면 되니 코드가 매우 유연해집니다."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "메시지 내용을 확인해볼까요?",
              "content": "관리자의 자기소개 메시지가 요청과 다르네요. {{ERROR_MESSAGE}} `Admin` 클래스의 `introduce` 메소드 안에서 `self.username`과 `self.admin_level` 속성을 모두 사용해서 문장을 만들었는지 확인해주세요."
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, 메소드 정의 오류!",
              "content": "메소드를 오버라이딩할 때 오류가 발생했어요. `Admin` 클래스 안에 `def introduce(self):` 처럼 메소드를 올바르게 정의했는지 확인해주세요. `self`를 빠뜨리거나 콜론(`:`)을 잊었을 수 있어요."
            }
          }
        }
      ]
    },

    {
      "week": 10,
      "title": "파일 처리와 예외 관리: 데이터 영구 저장 및 오류 대응",
      "cycles": [
        {
          "title": "파일 읽고 쓰기",
          "syntax_key": "file_io",
          "filename": "logger.py",
          "starterCode": "import time\n\n# 현재 시간을 포함한 로그 메시지 생성\nlog_message = f\"{time.strftime('%Y-%m-%d %H:%M:%S')} - Server restarted.\"\n\n# TODO: 1. 'with' 구문을 사용하여 'server.log' 파일을 쓰기('w') 모드로 여세요.\n#    파일 객체의 이름은 'f'로 하고, 한글 처리를 위해 encoding='utf-8'을 추가해주세요.\n\n\n    # TODO: 2. 파일 객체 f의 write 메소드를 사용하여 log_message를 파일에 쓰세요.\n\n\n\n# 파일 쓰기 완료 후, 아래 읽기 부분을 구현하세요.\ncontent = \"\"\n# TODO: 3. 'with' 구문을 사용하여 'server.log' 파일을 다시 읽기('r') 모드로 여세요.\n\n\n    # TODO: 4. 파일의 전체 내용을 읽어 'content' 변수에 저장하세요.\n\n\n\n# 아래는 테스트용 코드입니다. 수정하지 마세요.\nprint(\"파일에 저장된 내용:\")\nprint(content)\n",
          "testCode": "import os, time; assert os.path.exists('server.log'), \"'server.log' 파일이 생성되지 않았습니다.\"; with open('server.log', 'r', encoding='utf-8') as f: file_content = f.read(); expected_end = ' - Server restarted.'; assert file_content.endswith(expected_end), f\"파일에 저장된 로그 메시지의 내용이 올바르지 않습니다.\"; assert 'content' in locals() and content == file_content, '파일에서 읽은 내용이 content 변수에 올바르게 저장되지 않았습니다.'; os.remove('server.log')",
          "task": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "서버 이벤트 로그 기록",
            "content": "서버에서 발생하는 중요한 이벤트를 파일에 기록해야 합니다. 현재 시간을 포함한 로그 메시지(예: '2025-10-13 10:30:00 - Server restarted.')를 <span class='font-bold text-yellow-300'>`server.log` 라는 파일에 새로 쓰는(write)</span> 기능을 만들어주세요. 그리고 기록이 잘 되었는지 확인하기 위해, <span class='font-bold text-yellow-300'>파일의 전체 내용을 다시 읽어서(read)</span> 화면에 출력해야 합니다."
          },
          "briefing": {
            "character": "sena",
            "subtitle": "직속 선임의 OJT",
            "title": "데이터를 파일에 저장하기",
            "content": "지금까지 만든 변수나 객체들은 프로그램이 꺼지면 다 사라져버리죠. 데이터를 영구적으로 저장하려면 파일에 써야 해요. 파이썬에서는 <span class='font-bold text-teal-300'>`open()` 함수</span>로 파일을 열고, `.write()`로 쓰고, `.read()`로 읽을 수 있어요. 아, 그리고 중요한 팁! 파일을 열면 꼭 닫아줘야 하는데, <span class='font-bold text-teal-300'>`with open(...) as f:` 구문</span>을 쓰면 파이썬이 알아서 자동으로 닫아주니까 훨씬 안전하고 편해요."
          },
          "lecture": {
            "character": "profKim",
            "title": "강의 노트: 파일 입출력",
            "keyTakeaway": "`with open()` 구문으로 파일을 안전하게 열고, `.write()`로 쓰고 `.read()`로 읽을 수 있습니다.",
            "sandboxCode": "message = \"이것은 테스트 메시지입니다.\"\n\n# message 변수의 내용을 'test.txt' 파일에 써보세요.\nwith open('test.txt', 'w', encoding='utf-8') as f:\n    f.write(message)\n\nprint(\"'test.txt' 파일이 생성되었습니다.\")",
            "sections": [
              {
                "heading": "핵심 개념",
                "text": "파일 입출력(I/O)은 프로그램이 하드디스크와 같은 저장 장치에 있는 파일의 데이터를 읽거나, 파일에 새로운 데이터를 쓰는 것을 의미합니다. 이를 통해 프로그램이 종료되어도 데이터를 영구적으로 보존(persistence)할 수 있습니다.",
                "code": null
              },
              {
                "heading": "기본 문법",
                "text": "`with open()` 구문을 사용하면 파일을 사용한 뒤 자동으로 닫아주어 안전합니다.",
                "code": "# 파일 쓰기 ('w': 덮어쓰기, 'a': 이어쓰기)\nwith open('memo.txt', 'w', encoding='utf-8') as f:\n    f.write(\"안녕하세요\\n\")\n\n# 파일 읽기 ('r')\nwith open('memo.txt', 'r', encoding='utf-8') as f:\n    content = f.read()"
              },
              {
                "heading": "활용 사례",
                "text": "사용자 설정 저장, 게임 진행 상황 저장, 데이터 분석을 위한 로그 파일 기록 등 프로그램의 상태나 결과를 보존해야 하는 모든 곳에 사용됩니다.",
                "code": null
              },
              {
                "heading": "주의점 및 팁",
                "text": "쓰기 모드('w')는 기존 파일 내용을 전부 삭제하고 새로 씁니다. 기존 내용 뒤에 이어 쓰려면 추가 모드('a')를 사용하세요. 파일을 다 쓴 후에는 반드시 닫아야 하며, `with` 구문을 사용하면 이를 자동으로 처리해줘서 매우 편리합니다.",
                "code": null
              }
            ]
          },
          "feedback": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "로그 기록 성공",
              "content": "<span class='font-bold text-green-300'>파일에 정확히 기록되고, 다시 읽어오는 것까지 확인했습니다.</span> 훌륭합니다. 데이터를 파일로 다룰 수 있게 되었으니, 이제 우리 프로그램은 훨씬 더 많은 일을 할 수 있게 될 겁니다. 하지만, 만약 파일이 없다면 어떻게 될까요?"
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "파일 내용이 달라요",
              "content": "파일에 쓰거나 읽어온 내용이 요청과 다르네요. {{ERROR_MESSAGE}} `f.write(log_message)` 처럼 `write` 메소드를 올바르게 호출했는지, 그리고 `content = f.read()` 처럼 `read` 메소드의 결과를 `content` 변수에 잘 저장했는지 확인해볼까요?"
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, 파일 처리 오류!",
              "content": "파일을 다루는 코드에서 오류가 발생했어요. `with open('server.log', 'w', encoding='utf-8') as f:` 와 같이 파일 이름과 모드('w', 'r'), `as` 키워드를 정확하게 사용했는지 확인해주세요. 콜론(`:`)이나 들여쓰기를 빠뜨렸을 수도 있어요."
            }
          }
        },
        {
          "title": "안정적인 프로그램 만들기 (예외 처리)",
          "syntax_key": "exceptions",
          "filename": "safe_reader.py",
          "starterCode": "# TODO: 'non_existent_log.log' 파일을 읽으려고 시도하는 코드를 작성하세요.\n# 이 파일은 존재하지 않으므로 FileNotFoundError가 발생할 것입니다.\n# try-except 구문을 사용하여 이 오류를 처리하고,\n# \"로그 파일을 찾을 수 없습니다.\"라고 출력하세요.\n\n\n",
          "testCode": "assert 'try:' in source_code and 'except FileNotFoundError:' in source_code, \"'try'와 'except FileNotFoundError' 구문을 사용해야 합니다.\"; assert 'expected_output' in locals() and expected_output == '로그 파일을 찾을 수 없습니다.', f\"오류 발생 시 출력 메시지가 다릅니다. 기대값: '로그 파일을 찾을 수 없습니다.', 실제값: '{locals().get('expected_output', '')}'\"",
          "task": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "파일 읽기 오류 방지",
            "content": "이전 로그 읽기 기능에 치명적인 약점이 있습니다. 만약 <span class='font-bold text-yellow-300'>로그 파일이 존재하지 않으면</span> 프로그램이 오류를 내며 그대로 멈춰버립니다. <span class='font-bold text-yellow-300'>파일이 없더라도 프로그램이 멈추지 않고</span>, 대신 '로그 파일을 찾을 수 없습니다.'라는 메시지를 출력하도록 코드를 수정해주세요."
          },
          "briefing": {
            "character": "sena",
            "subtitle": "직속 선임의 팁",
            "title": "비상 상황 대비하기, `try-except`",
            "content": "프로그램은 언제나 예상치 못한 상황을 만날 수 있어요. 파일이 갑자기 사라지는 것처럼요. 이럴 때를 대비한 안전장치가 바로 <span class='font-bold text-teal-300'>`try-except`</span> 블록이에요. '일단 이걸 시도해보고(`try`), 만약 이런 오류가 발생하면(`except`), 대신 이걸 실행해' 라고 알려주는 거죠. <span class='font-bold text-teal-300'>오류가 날 만한 코드를 `try`로 감싸주기</span>만 하면 된답니다."
          },
          "lecture": {
            "character": "profKim",
            "title": "강의 노트: 예외 처리 (Exception Handling)",
            "keyTakeaway": "`try` 블록으로 위험한 코드를 감싸고, `except` 블록으로 특정 오류가 발생했을 때의 대처 방법을 정의합니다.",
            "sandboxCode": "try:\n    num = int(\"안녕하세요\")\n    print(num)\nexcept ValueError:\n    print(\"숫자로 바꿀 수 없는 값입니다!\")",
            "sections": [
              {
                "heading": "핵심 개념",
                "text": "예외(Exception)란 프로그램 실행 중에 발생하는 예기치 않은 오류를 의미합니다. 예외 처리는 이러한 오류가 발생했을 때 프로그램이 강제 종료되지 않고, 미리 정의된 대응 절차를 수행하도록 하여 프로그램의 안정성을 높이는 기법입니다.",
                "code": null
              },
              {
                "heading": "기본 문법",
                "text": "`try` 블록에 오류 발생 가능 코드를, `except` 블록에 오류 발생 시 처리할 코드를 작성합니다.",
                "code": "try:\n    # 오류가 발생할 가능성이 있는 코드\n    f = open('non_existent_file.txt', 'r')\nexcept FileNotFoundError:\n    # FileNotFoundError가 발생했을 때 실행할 코드\n    print(\"파일을 찾을 수 없습니다.\")\nfinally:\n    # 오류 발생 여부와 상관없이 항상 실행되는 코드\n    print(\"프로그램 실행을 종료합니다.\")"
              },
              {
                "heading": "활용 사례",
                "text": "존재하지 않는 파일을 열려고 할 때, 숫자가 아닌 값을 숫자로 변환하려고 할 때, 인터넷 연결이 끊겼을 때 등 모든 종류의 오류 상황에 대처하는 데 사용됩니다.",
                "code": null
              },
              {
                "heading": "주의점 및 팁",
                "text": "`except` 뒤에 `FileNotFoundError`, `ValueError`처럼 특정 오류를 명시해주는 것이 좋습니다. 그냥 `except:`라고만 쓰면 모든 오류를 다 잡아버려서, 어떤 문제가 발생했는지 알기 어려워질 수 있습니다.",
                "code": null
              }
            ]
          },
          "feedback": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "안정성 강화",
              "content": "<span class='font-bold text-green-300'>훌륭합니다. 이제 로그 파일이 없어도 프로그램이 멈추지 않고 안정적으로 동작</span>하는군요. 예외 처리는 사용자와 시스템 모두를 보호하는 매우 중요한 기술입니다. 신뢰도 높은 프로그램을 만드는 개발자로 성장하고 있네요."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "오류 처리가 안 됐어요",
              "content": "프로그램이 여전히 오류를 내며 멈추거나, 다른 메시지를 출력하네요. {{ERROR_MESSAGE}} `try` 블록 안에 파일을 열려고 시도하는 코드를 넣었는지, 그리고 `except FileNotFoundError:` 블록 안에 올바른 메시지를 출력하는 코드를 넣었는지 확인해주세요."
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, try-except 문법 오류!",
              "content": "`try-except` 구문에서 문법 오류가 발생했어요. `try:`와 `except FileNotFoundError:` 뒤에 콜론(`:`)을 빠뜨리진 않았나요? 그리고 각 블록에 포함되는 코드들은 반드시 들여쓰기를 해야 해요. 다시 한번 확인해볼까요?"
            }
          }
        }
      ]
    },

    {
      "week": 11,
      "title": "파이썬 생태계 첫걸음: 표준 라이브러리와 외부 패키지",
      "cycles": [
        {
          "title": "파이썬의 기본 도구함, 표준 라이브러리",
          "syntax_key": "std_lib",
          "filename": "backup_v2.py",
          "starterCode": "import os\nimport zipfile # zipfile 모듈을 import 합니다.\n\n# 백업할 테스트용 파일을 생성합니다.\nwith open('important_data.txt', 'w', encoding='utf-8') as f:\n    f.write('This is important data.')\n\nsource_file = 'important_data.txt'\ntarget_zip = 'backup.zip'\n\n# TODO: 'with' 구문과 zipfile.ZipFile을 사용하여 'target_zip'이라는 이름의 ZIP 파일을 쓰기('w') 모드로 여세요.\n#       zipfile 객체의 별명은 'myzip'으로 하세요.\n\n\n    # TODO: myzip 객체의 write 메소드를 사용하여 source_file을 압축 파일에 추가하세요.\n\n\n\n# 아래는 테스트용 코드입니다. 수정하지 마세요.\nif os.path.exists(target_zip):\n    print(f\"'{target_zip}' 파일이 성공적으로 생성되었습니다.\")\n",
          "testCode": "import os, zipfile; assert os.path.exists('backup.zip'), \"'backup.zip' 파일이 생성되지 않았습니다.\"; zf = None; try: zf = zipfile.ZipFile('backup.zip', 'r'); file_list = zf.namelist(); assert 'important_data.txt' in file_list, \"ZIP 파일 안에 'important_data.txt' 파일이 포함되어야 합니다.\" except zipfile.BadZipFile: assert False, \"생성된 'backup.zip' 파일이 올바른 ZIP 파일이 아닙니다.\" finally: \n    if zf: zf.close()\n    if os.path.exists('important_data.txt'): os.remove('important_data.txt')\n    if os.path.exists('backup.zip'): os.remove('backup.zip')",
          "task": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "백업 스크립트 기능 개선",
            "content": "7주차에 만들었던 백업 스크립트는 외부 `zip` 명령어에 의존해서, 해당 명령어가 없는 시스템에서는 동작하지 않는 단점이 있습니다. 파이썬에 기본으로 내장된 <span class='font-bold text-yellow-300'>'표준 라이브러리'</span> 중 하나인 <span class='font-bold text-yellow-300'>`zipfile` 모듈</span>을 사용하여, 외부 명령어 없이 순수 파이썬 코드로만 ZIP 압축을 하도록 스크립트를 개선해주세요."
          },
          "briefing": {
            "character": "sena",
            "subtitle": "직속 선임의 OJT",
            "title": "파이썬에 다 들어있어요!",
            "content": "맞아요, `os.system`은 편하긴 한데 다른 컴퓨터에서 실행이 안 될 수도 있죠. 파이썬은 '배터리 포함(Batteries Included)'이라는 철학이 있어서, 웬만한 기능은 <span class='font-bold text-teal-300'>'표준 라이브러리'</span>라는 기본 도구 상자에 다 들어있어요. 우리는 그냥 `import`해서 쓰기만 하면 돼요. 이번엔 <span class='font-bold text-teal-300'>`zipfile`이라는 도구를 꺼내서</span> 압축 문제를 해결해 보죠!"
          },
          "lecture": {
            "character": "profKim",
            "title": "강의 노트: 표준 라이브러리",
            "keyTakeaway": "표준 라이브러리는 파이썬에 내장된 강력한 모듈 모음이며, `import`하여 바로 사용할 수 있습니다.",
            "sandboxCode": "import random\n\n# 1부터 100 사이의 무작위 숫자를 뽑아 출력해보세요.\nrandom_number = random.randint(1, 100)\nprint(f\"1부터 100 사이의 무작위 숫자: {random_number}\")",
            "sections": [
              {
                "heading": "핵심 개념",
                "text": "파이썬 표준 라이브러리는 파이썬을 설치할 때 기본적으로 함께 설치되는 방대한 양의 모듈 모음입니다. 파일 처리, 운영체제 제어, 인터넷 통신, 날짜/시간 관리 등 자주 사용되는 기능들이 미리 만들어져 있어, 개발자는 복잡한 기능을 직접 구현할 필요 없이 가져다 쓰기만 하면 됩니다.",
                "code": null
              },
              {
                "heading": "기본 문법",
                "text": "필요한 모듈을 `import` 키워드로 불러와 사용합니다.",
                "code": "# 표준 라이브러리 모듈을 불러와 사용\nimport zipfile\nimport os\n\n# zipfile 모듈을 사용해 ZIP 파일 생성\nwith zipfile.ZipFile('backup.zip', 'w') as myzip:\n    myzip.write('important_file.txt')"
              },
              {
                "heading": "활용 사례",
                "text": "날짜를 다루는 `datetime`, 수학 계산을 위한 `math`, 무작위 숫자를 만드는 `random`, 파일 시스템을 다루는 `os` 등 모든 종류의 프로그램을 만들 때 필수적으로 사용됩니다.",
                "code": null
              },
              {
                "heading": "주의점 및 팁",
                "text": "어떤 기능이 필요할 때, 직접 만들기 전에 먼저 표준 라이브러리에 있는지 찾아보는 습관은 매우 좋은 습관입니다. 파이썬 공식 문서(Python Docs)에서 모든 표준 라이브러리 목록과 사용법을 확인할 수 있습니다.",
                "code": null
              }
            ]
          },
          "feedback": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "스크립트 의존성 제거",
              "content": "<span class='font-bold text-green-300'>훌륭합니다. 이제 우리 백업 스크립트는 외부 프로그램 없이, 순수 파이썬만으로 동작</span>하는군요. 이렇게 표준 라이브러리를 잘 활용하면 프로그램의 안정성과 이식성을 크게 높일 수 있습니다."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "압축 파일 내용이 달라요",
              "content": "ZIP 파일은 만들어졌는데 내용이 비어있거나 다른 파일이 들어있네요. {{ERROR_MESSAGE}} `with` 블록 안에서 `myzip.write(source_file)` 처럼 `write` 메소드를 올바르게 호출했는지 확인해주세요."
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, zipfile 사용 오류!",
              "content": "`zipfile` 모듈을 사용하는 코드에서 오류가 발생했어요. `with zipfile.ZipFile('backup.zip', 'w') as myzip:` 처럼 파일 이름과 모드('w')를 정확하게 전달했는지, `as` 키워드를 사용했는지 문법을 다시 한번 꼼꼼하게 확인해주세요."
            }
          }
        },
        {
          "title": "외부 라이브러리 설치 및 활용 (pip)",
          "syntax_key": "pip_requests",
          "filename": "time_checker.py",
          "starterCode": "# --- 가상 라이브러리 --- \n# 실제로는 'pip install requests'를 통해 설치해야 하지만,\n# 학습 환경을 위해 requests 객체를 아래와 같이 시뮬레이션합니다.\nclass MockResponse:\n    def json(self):\n        return {'datetime': '2025-10-01T12:30:00+09:00'}\nclass MockRequests:\n    def get(self, url):\n        print(f\"GET {url}\")\n        return MockResponse()\nrequests = MockRequests()\n# --------------------------\n\nurl = \"http://worldtimeapi.org/api/timezone/Asia/Seoul\"\nseoul_time = \"\"\n\n# TODO: 1. 위에서 제공된 가상 requests 객체를 사용하세요.\n# TODO: 2. requests.get() 함수를 사용하여 API를 호출하고,\n#       응답받은 JSON에서 'datetime' 값을 seoul_time 변수에 저장하세요.\n\n\n# 아래는 테스트용 코드입니다.\nprint(seoul_time)\n",
          "testCode": "assert 'seoul_time' in locals(), \"'seoul_time' 변수가 정의되지 않았습니다.\"; expected = '2025-10-01T12:30:00+09:00'; assert seoul_time == expected, f\"seoul_time 변수에 저장된 값이 다릅니다. 기대값: '{expected}', 실제값: '{seoul_time}'\"",
          "task": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "외부 API 연동 기능 개발",
            "content": "서비스에 현재 서울의 시간을 보여주는 기능을 추가하고 싶습니다. 우리 서버 시간 대신, <span class='font-bold text-yellow-300'>인터넷을 통해 정확한 시간 정보를 제공하는 외부 API를 호출</span>하여 시간 정보를 가져와야 합니다. 이를 위해, 파이썬 패키지 관리자인 <span class='font-bold text-yellow-300'>`pip`를 이용해 `requests`라는 외부 라이브러리를 설치</span>하고, 이를 활용해 API를 호출해주세요."
          },
          "briefing": {
            "character": "sena",
            "subtitle": "직속 선임의 팁",
            "title": "파이썬의 진짜 마법, PyPI!",
            "content": "표준 라이브러리도 대단하지만, 파이썬의 진짜 힘은 전 세계 개발자들이 만들어 공유하는 엄청난 양의 '외부 라이브러리'에 있어요. <span class='font-bold text-teal-300'>'PyPI'</span>라는 거대한 온라인 창고에 보관되어 있죠. 우리는 <span class='font-bold text-teal-300'>`pip install requests`</span> 라는 명령어 한 줄로 창고에서 원하는 라이브러리를 바로 가져와 쓸 수 있어요. 개발자들을 위한 앱 스토어 같은 거예요!"
          },
          "lecture": {
            "character": "profKim",
            "title": "강의 노트: pip와 외부 라이브러리",
            "keyTakeaway": "`pip install [패키지명]`으로 외부 라이브러리를 설치하고, `import`하여 강력한 기능들을 활용할 수 있습니다.",
            "sandboxCode": "# requests 라이브러리가 설치되었다고 가정합니다.\nimport requests\n\n# 테스트용 공개 API를 호출합니다.\nresponse = requests.get('https://jsonplaceholder.typicode.com/todos/1')\nprint(response.json())",
            "sections": [
              {
                "heading": "핵심 개념",
                "text": "PyPI(Python Package Index)는 파이썬을 위한 공식 서드파티 소프트웨어 저장소입니다. `pip`는 PyPI에 등록된 패키지(라이브러리)들을 설치하고 관리하는 공식 패키지 관리 도구입니다. 이를 통해 우리는 웹 개발, 데이터 분석 등 거의 모든 분야의 강력한 기능들을 손쉽게 활용할 수 있습니다.",
                "code": null
              },
              {
                "heading": "기본 문법",
                "text": "먼저 터미널에서 패키지를 설치한 후, 파이썬 코드에서 `import`하여 사용합니다.",
                "code": "# 1. 터미널(명령 프롬프트)에서 패키지 설치\n# pip install requests\n\n# 2. 파이썬 코드에서 불러와 사용\nimport requests\n\nresponse = requests.get('https://api.example.com/data')\nprint(response.json())"
              },
              {
                "heading": "활용 사례",
                "text": "웹 프레임워크(Flask, Django), 데이터 과학(Pandas, NumPy), 인공지능(TensorFlow, PyTorch) 등 현대적인 파이썬 개발의 거의 모든 영역이 외부 라이브러리를 기반으로 이루어집니다.",
                "code": null
              },
              {
                "heading": "주의점 및 팁",
                "text": "프로젝트에 사용된 외부 라이브러리 목록을 `requirements.txt` 파일에 기록해두면, 다른 개발자가 `pip install -r requirements.txt` 명령어로 동일한 개발 환경을 쉽게 구축할 수 있습니다.",
                "code": null
              }
            ]
          },
          "feedback": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "외부 세계와의 연결",
              "content": "<span class='font-bold text-green-300'>외부 패키지를 설치하고, 인터넷 API를 호출하여 데이터를 가져오는 데 성공했군요!</span> 이것은 현대적인 웹 서비스 개발의 가장 기본적인 업무 흐름입니다. 이제 OOO님은 파이썬 언어를 넘어, 파이썬 생태계 전체를 활용할 수 있는 개발자로 성장했습니다."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "데이터를 못 가져왔어요",
              "content": "API 호출 결과가 예상과 다르네요. {{ERROR_MESSAGE}} `requests.get(url)` 함수를 올바르게 호출했는지, 그리고 응답받은 데이터에서 `response.json()['datetime']` 처럼 정확한 키를 사용해 값을 추출했는지 확인해주세요."
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "문제 해결 지원",
              "title": "앗, ModuleNotFoundError!",
              "content": "오류 메시지에 `ModuleNotFoundError: No module named 'requests'` 라고 나오네요. `requests` 라이브러리를 찾을 수 없다는 뜻이에요. 터미널을 열고 `pip install requests` 명령어를 실행해서 라이브러리를 먼저 설치해야 `import` 할 수 있어요."
            }
          }
        }
      ]
    },

    {
      "week": 12,
      "title": "최종 프로젝트: 주소록 관리 프로그램 제작",
      "cycles": [
        {
          "title": "최종 프로젝트 설계 및 구조 잡기",
          "syntax_key": "final_project_design",
          "filename": "address_book_design.txt",
          "starterCode": "# 이 파일에 '명령줄 주소록' 프로그램의 설계도를 작성해주세요.\n\n# 1. 데이터 구조 (어떤 클래스와 변수를 사용할까요?):\n# - 한 사람의 정보 (이름, 이메일, 전화번호)를 어떻게 저장할까요?\n#\n\n# - 전체 주소록은 어떤 형태로 관리할까요?\n#\n\n# 2. 핵심 기능 목록 (어떤 기능들이 필요할까요?):\n# - 연락처 추가\n# - \n# - \n\n# 3. 데이터 영속성 (프로그램을 껐다 켜도 데이터가 유지되려면 어떻게 해야 할까요?):\n#\n\n",
          "testCode": "assert True, \"설계 단계는 개념적인 과제입니다.\"",
          "task": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "최종 프로젝트: 명령줄 주소록 개발",
            "content": "그동안의 성과를 바탕으로 최종 프로젝트를 진행합니다. <span class='font-bold text-yellow-300'>연락처를 추가, 검색, 수정, 삭제</span>할 수 있는 '명령줄 주소록 프로그램'을 만들어야 합니다. 이번 사이클의 과업은 코딩이 아닙니다. 대신, 이 프로그램에 <span class='font-bold text-yellow-300'>어떤 기능이 필요하고, 데이터를 어떤 구조(클래스, 딕셔너리)로 저장할지</span> 직접 '설계'하여 제출해주세요."
          },
          "briefing": {
            "character": "sena",
            "subtitle": "직속 선임의 조언",
            "title": "탄탄한 설계가 우선",
            "content": "드디어 최종 프로젝트군요! 좋은 프로그램을 만들려면 코딩보다 설계가 더 중요해요. 제 생각엔, 한 사람의 정보를 담을 <span class='font-bold text-teal-300'>`Person` 클래스</span>를 만들고, 전체 주소록은 <span class='font-bold text-teal-300'>이름을 Key로 하는 딕셔너리</span>로 관리하면 좋을 것 같아요. 프로그램이 꺼져도 데이터가 유지되게 하려면, `pickle` 모듈로 데이터를 파일에 저장하는 방법도 고려해야겠죠?"
          },
          "lecture": {
            "character": "profKim",
            "title": "강의 노트: 소프트웨어 설계",
            "keyTakeaway": "코딩 전에 '무엇을, 어떻게 만들지'를 먼저 정리하는 설계 과정은 프로젝트의 성패를 좌우합니다.",
            "sandboxCode": null,
            "sections": [
              {
                "heading": "핵심 개념",
                "text": "소프트웨어 설계는 큰 문제를 해결 가능한 작은 문제들로 나누는 과정입니다. 먼저 데이터(Data)를 어떻게 표현하고 저장할지 결정하고, 그 다음 사용자 인터페이스(UI)를 어떻게 구성할지, 마지막으로 UI와 데이터를 연결할 로직(Logic)을 어떻게 구현할지 순서대로 생각하는 것이 좋습니다.",
                "code": null
              },
              {
                "heading": "설계 단계 예시",
                "text": "주소록 프로젝트를 다음 단계로 나누어 생각해볼 수 있습니다.",
                "code": "# 1. 데이터: Person 클래스(name, email, phone), 전체 주소록은 딕셔너리\n# 2. 기능: 추가, 검색, 수정, 삭제, 전체 보기, 종료\n# 3. 영속성: 시작 시 pickle 파일에서 로드, 종료 시 파일에 저장"
              },
              {
                "heading": "활용 사례",
                "text": "지금 진행하는 최종 프로젝트 자체가 모든 지식을 활용하는 최고의 사례입니다.",
                "code": null
              },
              {
                "heading": "주의점 및 팁",
                "text": "처음부터 완벽한 설계를 하려고 하기보다, 가장 핵심적인 기능부터 단순하게 설계하고 점차 기능을 확장해나가는 것이 더 효과적입니다.",
                "code": null
              }
            ]
          },
          "feedback": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "설계 승인",
              "content": "<span class='font-bold text-green-300'>매우 체계적인 설계입니다.</span> 필요한 기능과 데이터 구조를 명확하게 정의했군요. 이 설계안이라면 충분히 훌륭한 프로그램을 만들 수 있겠습니다. 설계가 승인되었으니, 다음 사이클부터 핵심 기능 구현을 시작해주세요."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "설계 검토",
              "title": "핵심 기능이 빠졌어요",
              "content": "설계의 방향은 좋은데, {{ERROR_MESSAGE}} 중요한 기능이 빠진 것 같아요. 예를 들어, 연락처를 추가하는 기능은 있는데 삭제하는 기능이 없네요. 사용자가 필요로 할 모든 기능을 다시 한번 생각해보는게 좋을 것 같아요."
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "설계 검토",
              "title": "코드는 나중에!",
              "content": "이 단계는 코드를 작성하는 단계가 아니에요! 지금은 어떤 기능이 필요하고 어떤 데이터 구조를 쓸지 계획하는 '설계' 단계입니다. 작성해주신 계획안을 다시 한번 검토해주세요."
            }
          }
        },
        {
          "title": "핵심 기능 구현",
          "syntax_key": "final_project_core",
          "filename": "address_book.py",
          "starterCode": "class Person:\n    # TODO: __init__ 메소드에서 이름(name)과 이메일(email)을 받아 속성에 저장하세요.\n    def __init__(self, name, email):\n        pass\n\ndef add_contact(address_book, name, email):\n    # TODO: Person 객체를 생성하고, address_book 딕셔너리에 'name'을 키로 하여 추가하세요.\n    pass\n\ndef view_all_contacts(address_book):\n    # TODO: for 문을 사용해 address_book의 모든 연락처를 \"이름: 이메일\" 형식으로 출력하세요.\n    pass\n\n# -- 아래는 프로그램을 실행하고 테스트하기 위한 부분입니다. --\ndef main():\n    address_book = {}\n    add_contact(address_book, \"Alex\", \"alex@example.com\")\n    add_contact(address_book, \"Sena\", \"sena@example.com\")\n    view_all_contacts(address_book)\n\nif __name__ == \"__main__\":\n    main()",
          "testCode": "p = Person('Test', 'test@test.com'); assert p.name == 'Test' and p.email == 'test@test.com', 'Person 클래스의 __init__이 올바르게 동작하지 않습니다.'; ab = {}; add_contact(ab, 'Alex', 'alex@example.com'); assert 'Alex' in ab and isinstance(ab['Alex'], Person), 'add_contact 함수가 딕셔너리에 Person 객체를 추가하지 못했습니다.'; assert ab['Alex'].email == 'alex@example.com', '추가된 Person 객체의 이메일 정보가 올바르지 않습니다.'",
          "task": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "주소록 핵심 기능 구현",
            "content": "설계안을 바탕으로 실제 구현에 들어갑니다. 먼저 <span class='font-bold text-yellow-300'>`Person` 클래스를 정의</span>하고, 프로그램이 계속 실행되도록 하는 메인 루프를 만드세요. 그런 다음, <span class='font-bold text-yellow-300'>'연락처 추가'와 '전체 연락처 보기' 기능</span>을 먼저 구현해주세요. 데이터 저장은 아직 신경 쓰지 않아도 됩니다."
          },
          "briefing": {
            "character": "sena",
            "subtitle": "직속 선임의 팁",
            "title": "하나씩, 그리고 차근차근",
            "content": "이제 진짜 코딩이네요! 가장 복잡해 보이지만, 우리가 지금까지 배운 것들을 조합하기만 하면 돼요. <span class='font-bold text-teal-300'>`while True:`로 메인 루프</span>를 만들고, <span class='font-bold text-teal-300'>`if-elif-else`로 사용자 입력에 따라 분기</span>하면 되겠죠. 새로운 `Person` 객체를 만들어서 딕셔너리에 추가하는 로직에 집중해보세요. 한 번에 하나씩 만들고 테스트하는 게 중요해요!"
          },
          "lecture": {
            "character": "profKim",
            "title": "교수님의 조언: 통합적 사고",
            "keyTakeaway": "훌륭한 개발자는 많은 것을 아는 사람이 아니라, 아는 것을 잘 연결하여 문제를 해결하는 사람입니다.",
            "sandboxCode": null,
            "sections": [
              {
                "heading": "핵심 조언",
                "text": "이번 사이클에는 새로운 지식이 없습니다. 지금까지 배운 모든 지식을 연결하고 조합하는 능력이 필요할 뿐입니다. 클래스, 딕셔너리, `if`문, `for`문, 함수 등 각 도구들이 언제 필요한지 '지식 노트'와 '문법 인덱스'를 참고하며 스스로의 힘으로 해결해보세요. 이 과정 자체가 최고의 학습입니다.",
                "code": null
              }
            ]
          },
          "feedback": {
            "success": {
              "character": "alex",
              "subtitle": "업무 완료 피드백",
              "title": "핵심 기능 동작 확인",
              "content": "<span class='font-bold text-green-300'>새 연락처를 추가하고, 전체 목록을 보는 기능이 완벽하게 동작</span>합니다. 프로그램의 뼈대가 튼튼하게 만들어졌군요. 이제 나머지 기능들을 붙여서 프로그램을 완성해봅시다."
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "디버깅 지원",
              "title": "로직을 다시 살펴볼까요?",
              "content": "핵심 기능이 의도대로 동작하지 않네요. {{ERROR_MESSAGE}} `Person` 객체를 만들 때 `name`과 `email`을 잘 전달했는지, 그리고 `add_contact` 함수에서 이 객체를 딕셔너리에 `address_book[name] = ...` 형태로 잘 추가했는지 확인해주세요."
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "디버깅 지원",
              "title": "앗, 문법 오류!",
              "content": "코드를 실행하다가 오류가 발생했어요. 클래스나 함수를 정의할 때 `def`나 `class` 키워드, 콜론(`:`), 들여쓰기를 올바르게 사용했는지 다시 한번 꼼꼼하게 확인해볼까요?"
            }
          }
        },
        {
          "title": "기능 완성 및 회고",
          "syntax_key": "final_project_complete",
          "filename": "address_book_final.py",
          "starterCode": "import pickle\n\nFILENAME = \"address_book.data\"\n\nclass Person:\n    def __init__(self, name, email):\n        self.name = name\n        self.email = email\n\ndef load_data():\n    try:\n        # TODO: FILENAME을 읽기 바이너리('rb') 모드로 열고 pickle.load로 데이터를 불러와 반환하세요.\n        pass\n    except FileNotFoundError:\n        # TODO: 파일이 없을 경우, 비어있는 딕셔너리를 반환하세요.\n        return {}\n\ndef save_data(address_book):\n    # TODO: FILENAME을 쓰기 바이너리('wb') 모드로 열고 pickle.dump로 address_book을 파일에 저장하세요.\n    pass\n\n# -- 아래는 테스트를 위한 부분입니다. --\naddress_book_data = {\"Alex\": Person(\"Alex\", \"alex@example.com\")}\nsave_data(address_book_data)\nloaded_book = load_data()\nprint(loaded_book)\n",
          "testCode": "import os, pickle; test_data = {'Alex': Person('Alex', 'alex@example.com')}; save_data(test_data); assert os.path.exists(FILENAME), 'save_data 함수가 파일을 생성하지 못했습니다.'; loaded_data = load_data(); assert isinstance(loaded_data, dict) and 'Alex' in loaded_data and loaded_data['Alex'].email == 'alex@example.com', '불러온 데이터의 내용이 올바르지 않습니다.'; os.remove(FILENAME); empty_data = load_data(); assert empty_data == {}, '파일이 없을 때 load_data 함수는 빈 딕셔너리를 반환해야 합니다.'",
          "task": {
            "character": "alex",
            "subtitle": "팀장 과업 지시",
            "title": "주소록 프로그램 완성",
            "content": "마지막 단계입니다. 남은 기능인 <span class='font-bold text-yellow-300'>'연락처 검색'과 '연락처 삭제' 기능을 구현</span>해주세요. 그리고 가장 중요한, <span class='font-bold text-yellow-300'>`pickle` 모듈을 사용하여 주소록 데이터가 프로그램이 종료되어도 사라지지 않도록 파일에 저장하고, 다시 시작할 때 불러오는 기능</span>을 추가하여 프로그램을 완성하세요."
          },
          "briefing": {
            "character": "sena",
            "subtitle": "직속 선임의 팁",
            "title": "데이터에 생명을!",
            "content": "`pickle` 모듈은 정말 마법 같아요! 딕셔너리 같은 복잡한 데이터 구조를 그냥 통째로 파일에 저장하고, 다시 그대로 복원할 수 있거든요. <span class='font-bold text-teal-300'>프로그램 시작할 때 파일이 있으면 데이터를 불러오고, 종료하기 직전에 현재 주소록 데이터를 파일에 저장</span>하는 로직을 추가하면 돼요. <span class='font-bold text-teal-300'>`try-except`로 파일이 없는 경우도 대비</span>하는 것 잊지 마세요!"
          },
          "lecture": {
            "character": "profKim",
            "title": "과정을 돌아보며",
            "keyTakeaway": "이제 여러분은 파이썬 프로그래머입니다. 꾸준히 만들고, 공유하고, 배우며 성장을 멈추지 마세요.",
            "sandboxCode": null,
            "sections": [
              {
                "heading": "12주간의 여정",
                "text": "여러분은 `print`라는 간단한 문장으로 시작하여, 이제 데이터가 영구적으로 저장되고 객체 지향적으로 설계된 완전한 애플리케이션을 스스로의 힘으로 만들 수 있게 되었습니다. 단순히 파이썬 문법을 배운 것이 아니라, 문제를 분석하고, 설계하고, 구현하며, 오류를 해결하는 '개발자처럼 생각하는 법'을 배운 것입니다. 이것은 끝이 아니라, 더 넓은 세계로 나아가는 새로운 시작입니다.",
                "code": null
              }
            ]
          },
          "feedback": {
            "success": {
              "character": "alex",
              "subtitle": "최종 평가",
              "title": "프로젝트 성공! 그리고 새로운 시작",
              "content": "<span class='font-bold text-green-300'>축하합니다, OOO님. 모든 요구사항을 만족하는 주소록 프로그램을 성공적으로 완성했습니다.</span> 지난 12주간의 노력이 담긴 훌륭한 결과물입니다. OOO님은 이제 주어진 문제를 해결할 수 있는 역량을 갖춘 개발자로 성장했습니다. LogiCore Tech의 정식 개발자가 되신 것을 진심으로 환영합니다!"
            },
            "failure_logical": {
              "character": "sena",
              "subtitle": "디버깅 지원",
              "title": "데이터 저장/불러오기가 안돼요",
              "content": "데이터 영속성 기능에 문제가 있네요. {{ERROR_MESSAGE}} 데이터를 저장할 땐 `open(filename, 'wb')` 처럼 '쓰기 바이너리' 모드를, 불러올 땐 `'rb'` 모드를 사용했는지 확인해주세요. `pickle.dump`와 `pickle.load` 함수의 인자 순서도 다시 한번 살펴보는 게 좋겠어요."
            },
            "failure_runtime": {
              "character": "sena",
              "subtitle": "디버깅 지원",
              "title": "앗, Pickle 관련 오류!",
              "content": "파일을 저장하거나 불러오다 오류가 발생했어요. `pickle` 모듈은 바이너리 파일에 데이터를 쓰기 때문에, `open` 함수를 호출할 때 `'wb'`나 `'rb'`처럼 `b` 모드를 꼭 포함해야 해요. 이 부분을 빠뜨린 건 아닐까요?"
            }
          }
        }
      ]
    }
  ]
}
